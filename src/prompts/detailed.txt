### Role: ###
You are a formal verification expert specializing in loop invariant synthesis with emphasis on boundary conditions.

### Understanding Loop Invariants: ###

A loop invariant I must satisfy THREE conditions:
1. **Establishment**: I is true before the loop starts
2. **Preservation**: If I is true and loop condition B is true, then I remains true after one iteration
3. **Sufficiency**: When loop terminates, (I AND NOT(B)) must imply the postcondition

### CRITICAL: Verification Goal Analysis ###

**STEP 1: Identify the postcondition**
- Look for `/*@ assert <condition>; */` AFTER the loop
- Parse ALL conditions in the assert statement
- Example: `assert (n==a+1) && (y == 3*n*n + 3*n + 1) && (x == n*n*n);`

**STEP 2: Analyze loop termination**
- What is the loop condition? (e.g., `while(n <= a)`)
- When does it become false? (e.g., `n > a`)
- What bounds does your invariant need? (e.g., `n <= a + 1`)

**STEP 3: Generate boundary invariants**
- For each variable in the postcondition, determine its bounds
- If postcondition has `n == a + 1`, invariant MUST include `n <= a + 1`
- If postcondition has `x == n*n*n`, invariant MUST include `x == n*n*n`

**STEP 4: Verify sufficiency**
- Check: Does `invariant AND NOT(loop_condition)` imply postcondition?
- If NO, strengthen the invariant (add missing bounds or relationships)

### Boundary Condition Patterns: ###

1. **Loop counter bounds**:
   - If loop is `while(i <= n)`, invariant should include `0 <= i <= n + 1`
   - If loop is `while(i < n)`, invariant should include `0 <= i <= n`

2. **Termination conditions**:
   - If postcondition requires `var == target`, invariant should include `var <= target` (or `var >= target`)
   - When loop exits, combine with negation of loop condition to prove equality

3. **Monotonic variables**:
   - If variable only increases: `var >= initial_value`
   - If variable only decreases: `var <= initial_value`

### Common Invariant Patterns: ###

- **Bounds**: `loop invariant 0 <= i <= n;`
- **Equality relationships**: `loop invariant sum == i * (i + 1) / 2;`
- **Conservation**: `loop invariant total == processed + remaining;`

### Common Mistakes to Avoid: ###

- **MISTAKE 1**: Only including `n >= 0` without upper bound
  - Problem: Cannot prove `n == a + 1` from just `n >= 0` and `n > a`
  - Solution: Add `n <= a + 1`

- **MISTAKE 2**: Missing boundary conditions for loop counter
  - Problem: Cannot prove termination conditions
  - Solution: Always include bounds: `lower <= counter <= upper`

- **MISTAKE 3**: Including relationships but missing bounds
  - Problem: Relationships hold, but cannot prove exact values at termination
  - Solution: Combine relationships with bounds

- **MISTAKE 4**: Using the loop guard as a loop invariant
  - Problem: The loop guard `A > B` is FALSE when the loop exits, so it is NOT an invariant
  - Solution: Weaken the guard: use `A >= B` instead of `A > B`
  - Example: Guard `x > y*q+r` â†’ Invariant `y*q+r <= x`

### Context: ###
{{pre_cond}}

{{cache_reference}}

### Code: ###
```c
{{content}}
```

### Task: ###

1. **Identify the verification goal**: Extract the assert statement after the loop
2. **Analyze loop termination**: What happens when the loop condition becomes false?
3. **Generate boundary invariants**: Add bounds that connect loop state to postcondition
4. **Generate relationship invariants**: Add equality relationships from code analysis
5. **Verify completeness**: Ensure invariant + negation of loop_condition implies postcondition

### Output: ###

Output ONLY the complete C code with loop invariants inserted before the loop.

**Your invariants MUST include**:
1. Boundary conditions (bounds for loop variables)
2. Relationship invariants (equality relationships)
3. Sufficient strength to prove the postcondition
