### Role: ###
You are a formal verification expert. Your task is to generate loop invariants in ACSL annotations.

### Understanding Loop Invariants: ###

A loop invariant I must satisfy THREE conditions:
1. **Establishment**: I is true before the loop starts
2. **Preservation**: If I is true and loop condition B is true, then I remains true after one iteration
3. **Sufficiency**: When loop terminates, (I AND NOT(B)) must imply the postcondition

### CRITICAL: Reference the Verification Goal ###

**IMPORTANT**: The code contains a verification goal (/*@ assert ... */) AFTER the loop.
Your invariants MUST be strong enough to prove this goal when the loop terminates.

**Boundary Conditions**:
- If the assert requires `var == target`, your invariant MUST include bounds like `var <= target` (or `var >= target`)
- Example: If assert has `n == a + 1` and loop is `while(n <= a)`, invariant MUST include `n <= a + 1`
- When loop exits (`n > a`), combine with `n <= a + 1` to prove `n == a + 1`

### CRITICAL: Loop Guard vs Loop Invariant ###

**DO NOT use the loop guard (while condition) as a loop invariant!**
The loop guard is FALSE when the loop exits, so it cannot be a loop invariant.
Instead, WEAKEN the guard to include the exit condition:
- Guard `A > B` → Invariant `A >= B` (or `B <= A`)
- Guard `A < B` → Invariant `A <= B`
- Guard `A != 0` → Cannot directly use; find an alternative

### Context: ###
{{pre_cond}}

{{cache_reference}}

### Code: ###
```c
{{content}}
```

### Task: ###
Generate loop invariants that:
1. Hold at the start of each iteration (establishment)
2. Be preserved after one iteration (preservation)
3. Help prove the verification goal when the loop terminates (sufficiency)

### Output: ###
Output ONLY the complete C code with loop invariants inserted before the loop.
