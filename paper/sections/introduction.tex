%% ============================================================
\section{Introduction}\label{sec:intro}
%% ============================================================

Loop invariants are the cornerstone of deductive program verification.
Given a loop annotated with an appropriate invariant, a verification condition generator
such as Frama-C/WP~\cite{framac} can reduce the correctness of the entire program to
a set of first-order proof obligations that can be discharged automatically.
In practice, however, \emph{finding} the right invariant is the bottleneck:
even expert users spend substantial effort crafting invariants that are simultaneously
\emph{inductive} (preserved by each iteration), \emph{sufficient} (strong enough to
imply the postcondition), and \emph{syntactically admissible} (expressible in the
annotation language).

Classical approaches to invariant synthesis fall into two broad camps.
\emph{Static} techniques such as abstract interpretation~\cite{cousot1977abstract},
template-based constraint solving~\cite{colon2003linear}, and
Houdini-style iterative weakening~\cite{flanagan2001houdini}
offer soundness guarantees but are limited to fixed abstract domains or templates.
\emph{Dynamic} techniques infer candidate invariants from execution traces
using polynomial fitting~\cite{daikon}, machine learning~\cite{si2018learning},
or data-driven enumerative search~\cite{garg2016learning}, but must still close
the gap between empirical observation and formal proof.

Recently, large language models (LLMs) have shown remarkable ability in
code understanding and generation tasks.
Several studies have explored using LLMs to generate loop
invariants~\cite{chakraborty2024towards,pei2023can,kamath2023finding},
demonstrating that LLMs can produce plausible candidates even for non-trivial programs.
However, existing approaches typically rely on a single LLM call or a simple
repair loop, and do not systematically exploit execution traces or
diversified generation strategies.

In this paper we present \textsc{SAM2INV} (\textbf{Sam}pling \textbf{to} \textbf{Inv}ariant),
an end-to-end system that combines the strengths of dynamic sampling, LLM-based generation,
and formal verification into a tightly integrated pipeline.
Our key contributions are:

\begin{enumerate}
\item \textbf{Smart Dynamic Sampling.}
  We propose a tiered sampling strategy that executes the target program with
  carefully ordered inputs---from special boundary values through small, medium,
  and large integers---to collect execution traces that expose loop behaviour
  at different scales.
  The traces are formatted into structured prompts that guide the LLM
  toward discovering mathematical relationships among loop variables.

\item \textbf{Parallel Diverse Generation.}
  Rather than relying on a single LLM query, we issue multiple parallel requests
  with varied prompt templates and elevated sampling temperatures.
  This produces a diverse candidate pool from which invariants are selected
  through trace-based filtering and Houdini-style pruning.

\item \textbf{Iterative Verification--Repair Loop.}
  Candidates that survive initial filtering are verified with Frama-C/WP.
  Failing invariants are pruned in a Houdini fashion (guaranteed to terminate),
  and verification error messages are fed back to the LLM for targeted
  strengthening, closing the loop between generation and formal proof.

\item \textbf{Probabilistic Loop Synthesis DSL.}
  To enable controlled, large-scale evaluation beyond existing benchmarks,
  we design a probabilistic domain-specific language (DSL) that generates
  structured numeric loop programs with tunable arithmetic complexity,
  nesting depth, and variable counts.
\end{enumerate}

The remainder of this paper is organised as follows.
Section~\ref{sec:related} surveys related work.
Section~\ref{sec:overview} gives a high-level overview of the \textsc{SAM2INV} pipeline.
Section~\ref{sec:method} details each component.
Section~\ref{sec:loop-factory} describes the loop synthesis DSL.
Section~\ref{sec:experiments} presents experimental evaluation.
Section~\ref{sec:conclusion} concludes.
