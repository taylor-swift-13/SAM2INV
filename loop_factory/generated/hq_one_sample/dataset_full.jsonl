{"id": "loop_factory_1", "model": "gpt-5-mini", "system_prompt": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "user_prompt": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int x, y, c;\n\n  x=1;\n  y=a;\n  c=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (c<m) {\n      c = c+1;\n      x = x*a+1;\n      y = y*a;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (c<m) {\n      c = c+1;\n      x = x*a+1;\n      y = y*a;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'k', 'm', 'x', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "raw_model_output": "int main1(int a,int k,int m){\n  int x, y, c;\n\n  x=1;\n  y=a;\n  c=1;\n\n  /*@\n    loop invariant (a - 1) * x + 1 == y;\n    loop invariant c >= 1;\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop assigns c, x, y;\n  */\nwhile (c<m) {\n      c = c+1;\n      x = x*a+1;\n      y = y*a;\n  }\n\n}", "raw_c": "int main1(int a,int k,int m){\n  int x, y, c;\n\n  x=1;\n  y=a;\n  c=1;\n\n  while (c<m) {\n      c = c+1;\n      x = x*a+1;\n      y = y*a;\n  }\n\n}\n", "annotated_c": "int main1(int a,int k,int m){\n  int x, y, c;\n\n  x=1;\n  y=a;\n  c=1;\n\n  \n  /*@\n\n    loop invariant (a - 1) * x + 1 == y;\n\n    loop invariant c >= 1;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop assigns c, x, y;\n\n  */\nwhile (c<m) {\n      c = c+1;\n      x = x*a+1;\n      y = y*a;\n  }\n\n}", "invariants": ["(a - 1) * x + 1 == y", "c >= 1", "a == \\at(a, Pre)", "k == \\at(k, Pre)", "m == \\at(m, Pre)"], "quality": {"syntax_pass": true, "valid_pass": true, "non_empty_invariants": true}}
