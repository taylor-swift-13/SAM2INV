{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n){\n  int r, i, v;\n\n  r=63;\n  i=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<r) {\n      if (v+1<r) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 0) && (r == 63) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<r) {\n      if (v+1<r) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 1 >= r at loop-step start; i at loop-step start < r at loop-step start; i at loop-step start < r at loop-step start). Changed: i: i at loop-step start -> i at loop-step start + 1; v: v at loop-step start -> v at loop-step start - v at loop-step start. Unchanged: a keeps a at loop-step start; n keeps n at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'n', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n){\n  int r, i, v;\n\n  r=63;\n  i=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == 0;\n  loop invariant 0 <= i && i <= r && r == 63 && a == \\at(a, Pre) && n == \\at(n, Pre);\n  loop invariant 0 <= i && i <= r;\n  loop invariant r == 63;\n  loop invariant a == \\at(a, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant i >= 0;\n  loop invariant i <= r;\n  loop assigns i, v;\n*/\nwhile (i<r) {\n      if (v+1<r) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k){\n  int o, h, v, j;\n\n  o=71;\n  h=o;\n  v=a;\n  j=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (h>0) {\n      v = v+j+j;\n      v = v+1;\n      h = h-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (j == -8) && (v == \\at(a, Pre)) && (h == 71) && (o == 71) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (h>0) {\n      v = v+j+j;\n      v = v+1;\n      h = h-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (h at loop-step start > 0). Changed: h: h at loop-step start -> h at loop-step start - 1; v: v at loop-step start -> v at loop-step start + j at loop-step start + j at loop-step start + 1. Unchanged: a keeps a at loop-step start; j keeps j at loop-step start; k keeps k at loop-step start; o keeps o at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'h', 'j', 'k', 'o', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k){\n  int o, h, v, j;\n\n  o=71;\n  h=o;\n  v=a;\n  j=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant a == \\at(a, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant j == -8;\n  loop invariant h >= 0;\n  loop invariant h <= 71;\n  loop invariant v == a - 1065 + 15*h;\n  loop invariant v == a + (o - h) * (2*j + 1);\n  loop invariant 0 <= h;\n  loop invariant h <= o;\n  loop invariant v == \\at(a, Pre) + (71 - h) * (2 * j + 1);\n  loop invariant o == 71;\n  loop invariant v + h*(2*j+1) == \\at(a, Pre) + o*(2*j+1);\n  loop invariant v + (2*j + 1) * h == \\at(a, Pre) + (2*j + 1) * 71;\n  loop assigns v, h;\n*/\nwhile (h>0) {\n      v = v+j+j;\n      v = v+1;\n      h = h-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int e, s, q, w, v, t;\n\n  e=48;\n  s=0;\n  q=3;\n  w=s;\n  v=n;\n  t=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<e) {\n      q = q+1;\n      s = s+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (t == \\at(m, Pre)) && (v == \\at(n, Pre)) && (w == 0) && (q == 3) && (s == 0) && (e == 48) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (s<e) {\n      q = q+1;\n      s = s+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start < e at loop-step start). Changed: q: q at loop-step start -> q at loop-step start + 1; s: s at loop-step start -> s at loop-step start + 1. Unchanged: e keeps e at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start; t keeps t at loop-step start; v keeps v at loop-step start; w keeps w at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'm', 'n', 'q', 's']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int e, s, q, w, v, t;\n\n  e=48;\n  s=0;\n  q=3;\n  w=s;\n  v=n;\n  t=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant s <= e;\n  loop invariant q - s == 3;\n  loop invariant 0 <= s;\n  loop invariant e == 48;\n  loop invariant m == \\at(m, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant q == s + 3;\n  loop invariant s >= 0;\n  loop assigns s, q;\n*/\nwhile (s<e) {\n      q = q+1;\n      s = s+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k){\n  int r, u, v, y, d, f;\n\n  r=a;\n  u=0;\n  v=8;\n  y=u;\n  d=-3;\n  f=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<r) {\n      v = v+1;\n      u = u+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<r) {\n      v = v+1;\n      u = u+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'k', 'r', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k){\n  int r, u, v, y, d, f;\n\n  r=a;\n  u=0;\n  v=8;\n  y=u;\n  d=-3;\n  f=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant r == \\at(a, Pre);\n  loop invariant u >= 0;\n  loop invariant r == a;\n  loop invariant u == 0 || u <= r;\n  loop invariant a == \\at(a, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant v == u + 8;\n  loop invariant 0 <= u;\n\n  loop assigns u, v;\n*/\nwhile (u<r) {\n      v = v+1;\n      u = u+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p){\n  int o, e, s;\n\n  o=a;\n  e=0;\n  s=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (e<o) {\n      s = s+e;\n      e = e+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == \\at(p, Pre)) && (e == 0) && (o == \\at(a, Pre)) && (p == \\at(p, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (e<o) {\n      s = s+e;\n      e = e+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (e at loop-step start < o at loop-step start). Changed: e: e at loop-step start -> e at loop-step start + 1; s: s at loop-step start -> s at loop-step start + e at loop-step start. Unchanged: a keeps a at loop-step start; o keeps o at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'e', 'o', 'p', 's']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p){\n  int o, e, s;\n\n  o=a;\n  e=0;\n  s=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant o == \\at(a, Pre);\n  loop invariant s == \\at(p, Pre) + e*(e-1)/2;\n\n  loop invariant p == \\at(p, Pre);\n  loop invariant s == \\at(p, Pre) + (e*(e-1))/2;\n  loop invariant e >= 0;\n  loop invariant (o < 0) || e <= o;\n  loop invariant a == \\at(a,Pre);\n  loop invariant 0 <= e;\n\n  loop assigns s, e;\n*/\nwhile (e<o) {\n      s = s+e;\n      e = e+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int j, d, l, o, u, y;\n\n  j=46;\n  d=j;\n  l=-2;\n  o=j;\n  u=m;\n  y=d;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (d>0) {\n      l = l+4;\n      u = u+2;\n      d = d-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (y == 46) && (u == \\at(m, Pre)) && (o == 46) && (l == -2) && (d == 46) && (j == 46) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (d>0) {\n      l = l+4;\n      u = u+2;\n      d = d-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'j', 'k', 'l', 'm', 'u']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int j, d, l, o, u, y;\n\n  j=46;\n  d=j;\n  l=-2;\n  o=j;\n  u=m;\n  y=d;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= d && d <= j;\n  loop invariant l == -2 + 4*(j - d);\n  loop invariant u == \\at(m, Pre) + 2*(j - d);\n  loop invariant m == \\at(m, Pre);\n  loop invariant l + 4*d == 182;\n  loop invariant u + 2*d == m + 92;\n  loop invariant d >= 0;\n  loop invariant k == \\at(k, Pre);\n  loop invariant u + 2*d == \\at(m, Pre) + 92;\n  loop invariant 0 <= d;\n  loop invariant d <= 46;\n  loop assigns l, u, d;\n*/\nwhile (d>0) {\n      l = l+4;\n      u = u+2;\n      d = d-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int x, i, v, a, l, g;\n\n  x=58;\n  i=0;\n  v=i;\n  a=m;\n  l=m;\n  g=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<x) {\n      v = v+4;\n      a = a+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (g == -6) && (l == \\at(m, Pre)) && (a == \\at(m, Pre)) && (v == 0) && (i == 0) && (x == 58) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i<x) {\n      v = v+4;\n      a = a+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start < x at loop-step start). Changed: a: a at loop-step start -> a at loop-step start + (v at loop-step start + 4; i: i at loop-step start -> i at loop-step start + 1; v: v at loop-step start -> v at loop-step start + 4. Unchanged: g keeps g at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start; x keeps x at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'm', 'n', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int x, i, v, a, l, g;\n\n  x=58;\n  i=0;\n  v=i;\n  a=m;\n  l=m;\n  g=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i <= x;\n  loop invariant v == 4*i;\n  loop invariant a == \\at(m, Pre) + 2*i*(i+1);\n  loop invariant m == \\at(m, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant x == 58;\n  loop invariant i >= 0;\n  loop invariant a == m + 2*i*(i+1);\n  loop invariant a == m + 2*i*i + 2*i;\n  loop invariant 0 <= i;\n  loop assigns v, a, i;\n*/\nwhile (i<x) {\n      v = v+4;\n      a = a+v;\n      i = i+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p){\n  int l, x, v;\n\n  l=38;\n  x=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (x<l) {\n      v = v+1;\n      v = v+4;\n      x = x+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 4) && (x == 0) && (l == 38) && (p == \\at(p, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (x<l) {\n      v = v+1;\n      v = v+4;\n      x = x+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (x at loop-step start < l at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 1 + 4; x: x at loop-step start -> x at loop-step start + 1. Unchanged: l keeps l at loop-step start; n keeps n at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['l', 'n', 'p', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p){\n  int l, x, v;\n\n  l=38;\n  x=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == 4 + 5 * x;\n  loop invariant 0 <= x;\n  loop invariant x <= l;\n  loop invariant l == 38;\n  loop invariant n == \\at(n, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop assigns v, x;\n*/\nwhile (x<l) {\n      v = v+1;\n      v = v+4;\n      x = x+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int n, u, o, v;\n\n  n=60;\n  u=0;\n  o=m;\n  v=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<n) {\n      o = o+1;\n      v = v-1;\n      u = u+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<n) {\n      o = o+1;\n      v = v-1;\n      u = u+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'm', 'n', 'o', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m){\n  int n, u, o, v;\n\n  n=60;\n  u=0;\n  o=m;\n  v=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (0 <= u) && (u <= n);\n  loop invariant o == m + u;\n  loop invariant v == 8 - u;\n  loop invariant u <= n;\n  loop invariant 0 <= u;\n  loop invariant u >= 0;\n  loop invariant m == \\at(m, Pre);\n  loop invariant o == \\at(m, Pre) + u;\n  loop invariant v + u == 8;\n  loop assigns o, u, v;\n*/\nwhile (u<n) {\n      o = o+1;\n      v = v-1;\n      u = u+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p){\n  int f, j, o, i, x;\n\n  f=49;\n  j=f;\n  o=1;\n  i=p;\n  x=f;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j>0) {\n      o = o+3;\n      x = x+1;\n      j = j-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (x == 49) && (i == \\at(p, Pre)) && (o == 1) && (j == 49) && (f == 49) && (p == \\at(p, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (j>0) {\n      o = o+3;\n      x = x+1;\n      j = j-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start > 0). Changed: j: j at loop-step start -> j at loop-step start - 1; o: o at loop-step start -> o at loop-step start + 3; x: x at loop-step start -> x at loop-step start + 1. Unchanged: f keeps f at loop-step start; i keeps i at loop-step start; m keeps m at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['f', 'j', 'm', 'o', 'p', 'x']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p){\n  int f, j, o, i, x;\n\n  f=49;\n  j=f;\n  o=1;\n  i=p;\n  x=f;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant x + j == 2*f;\n  loop invariant 0 <= j;\n  loop invariant j <= f;\n  loop invariant p == \\at(p, Pre);\n  loop invariant o == 1 + 3*(f - j);\n  loop invariant x == 2*f - j;\n  loop invariant m == \\at(m, Pre);\n  loop invariant f == 49;\n  loop assigns o, x, j;\n*/\nwhile (j>0) {\n      o = o+3;\n      x = x+1;\n      j = j-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int r, g, v;\n\n  r=54;\n  g=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (g<r) {\n      if (v+7<r) {\n          v = v+g;\n      }\n      g = g+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == \\at(m, Pre)) && (g == 0) && (r == 54) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (g<r) {\n      if (v+7<r) {\n          v = v+g;\n      }\n      g = g+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 7 >= r at loop-step start; g at loop-step start < r at loop-step start; g at loop-step start < r at loop-step start). Changed: g: g at loop-step start -> g at loop-step start + 1; v: v at loop-step start -> v at loop-step start + g at loop-step start. Unchanged: b keeps b at loop-step start; m keeps m at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'g', 'm', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m){\n  int r, g, v;\n\n  r=54;\n  g=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= g && g <= r && r == 54;\n  loop invariant v >= \\at(m,Pre) && v <= \\at(m,Pre) + g*(g-1)/2 && m == \\at(m,Pre);\n  loop invariant r == 54;\n  loop invariant m == \\at(m, Pre);\n  loop invariant b == \\at(b, Pre);\n  loop invariant 0 <= g;\n  loop invariant g <= r;\n  loop invariant v >= m;\n  loop invariant v >= \\at(m, Pre);\n  loop invariant v <= \\at(m, Pre) + (g*(g-1))/2;\n  loop invariant v <= \\at(m, Pre) + g*(g-1)/2;\n  loop invariant v <= m + g*(r-1);\n  loop assigns v, g;\n*/\nwhile (g<r) {\n      if (v+7<r) {\n          v = v+g;\n      }\n      g = g+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p){\n  int s, t, v, z, n, i;\n\n  s=a-9;\n  t=0;\n  v=p;\n  z=p;\n  n=p;\n  i=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v!=0&&z!=0) {\n      if (v>z) {\n          v = v-z;\n      }\n      else {\n          z = z-v;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (i == -1) && (n == \\at(p, Pre)) && (z == \\at(p, Pre)) && (v == \\at(p, Pre)) && (t == 0) && (s == \\at(a, Pre) - 9) && (p == \\at(p, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (v!=0&&z!=0) {\n      if (v>z) {\n          v = v-z;\n      }\n      else {\n          z = z-v;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start > z at loop-step start; z at loop-step start != 0; v at loop-step start != 0; z at loop-step start != 0; v at loop-step start != 0). Changed: z: z at loop-step start -> z at loop-step start - v at loop-step start. Unchanged: a keeps a at loop-step start; i keeps i at loop-step start; n keeps n at loop-step start; p keeps p at loop-step start; s keeps s at loop-step start; t keeps t at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'p', 's', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p){\n  int s, t, v, z, n, i;\n\n  s=a-9;\n  t=0;\n  v=p;\n  z=p;\n  n=p;\n  i=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant s == a - 9;\n  loop invariant a == \\at(a, Pre);\n  loop invariant p == \\at(p, Pre);\n\n  loop invariant ((p >= 0) ==> (0 <= v && v <= p) && (0 <= z && z <= p));\n\n  loop assigns v, z;\n*/\nwhile (v!=0&&z!=0) {\n      if (v>z) {\n          v = v-z;\n      }\n      else {\n          z = z-v;\n      }\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int c, x, l;\n\n  c=p+10;\n  x=0;\n  l=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (x<c) {\n      if (x<q+3) {\n          l = l+1;\n      }\n      x = x+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (x<c) {\n      if (x<q+3) {\n          l = l+1;\n      }\n      x = x+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'l', 'p', 'q', 'x']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int c, x, l;\n\n  c=p+10;\n  x=0;\n  l=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant x >= 0;\n\n  loop invariant c == p + 10;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant 0 <= x;\n  loop invariant l >= 3;\n  loop invariant l <= x + 3;\n  loop invariant (q + 3 <= 0) ==> (l == 3);\n\n  loop invariant (x <= q+3) ==> (l == 3 + x);\n\n  loop invariant (q <= -3 && l == 3) ||\n                   (q > -3 && ((x <= q+3 && l == 3 + x) || (x >= q+3 && l == q + 6)));\n  loop invariant 3 <= l;\n  loop invariant l - 3 <= x;\n  loop assigns x, l;\n*/\nwhile (x<c) {\n      if (x<q+3) {\n          l = l+1;\n      }\n      x = x+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int p){\n  int r, t, v;\n\n  r=20;\n  t=0;\n  v=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t<r) {\n      v = v+1;\n      t = t+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 8) && (t == 0) && (r == 20) && (p == \\at(p, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (t<r) {\n      v = v+1;\n      t = t+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start < r at loop-step start). Changed: t: t at loop-step start -> t at loop-step start + 1; v: v at loop-step start -> v at loop-step start + 1. Unchanged: b keeps b at loop-step start; p keeps p at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'p', 'r', 't', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int p){\n  int r, t, v;\n\n  r=20;\n  t=0;\n  v=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant r == 20;\n  loop invariant t >= 0;\n  loop invariant t <= r;\n  loop invariant v == t + 8;\n  loop invariant b == \\at(b, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant v == 8 + t;\n  loop invariant 0 <= t;\n  loop invariant v - t == 8;\n  loop assigns v, t;\n*/\nwhile (t<r) {\n      v = v+1;\n      t = t+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k){\n  int r, u, i, o, v;\n\n  r=(k%8)+14;\n  u=r;\n  i=r;\n  o=-5;\n  v=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u>0) {\n      i = i+2;\n      o = o+i;\n      u = u-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 3) && (o == -5) && (i == \\at(k, Pre) % 8 + 14) && (u == \\at(k, Pre) % 8 + 14) && (r == \\at(k, Pre) % 8 + 14) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (u>0) {\n      i = i+2;\n      o = o+i;\n      u = u-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'o', 'r', 'u']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k){\n  int r, u, i, o, v;\n\n  r=(k%8)+14;\n  u=r;\n  i=r;\n  o=-5;\n  v=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i == 3*r - 2*u;\n  loop invariant (0 <= u) && (u <= r);\n  loop invariant r <= i <= 3*r;\n  loop invariant o == -5 + (r - u)*r + (r - u)*(r - u + 1);\n  loop invariant r == (k % 8) + 14;\n  loop invariant o == -5 + (r - u) * (2*r - u + 1);\n  loop invariant 0 <= u;\n  loop invariant u <= r;\n  loop invariant i + 2*u == 3 * ((k % 8) + 14);\n  loop invariant i >= ((k % 8) + 14);\n  loop invariant o == -5 + (((k % 8) + 14) - u) * ((k % 8) + 14) + (((k % 8) + 14) - u) * (((k % 8) + 14) - u + 1);\n  loop invariant r == ((k % 8) + 14);\n\n  loop invariant u >= 0 && i >= r;\n  loop invariant 2*u + i == 3*( (\\at(k, Pre) % 8) + 14 );\n  loop invariant u >= 0;\n  loop invariant i <= 3*( (\\at(k, Pre) % 8) + 14 );\n  loop assigns i, o, u;\n*/\nwhile (u>0) {\n      i = i+2;\n      o = o+i;\n      u = u-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int u, e, y;\n\n  u=67;\n  e=0;\n  y=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (e<u) {\n      y = y-y;\n      y = y+y;\n      e = e+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (y == \\at(p, Pre)) && (e == 0) && (u == 67) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (e<u) {\n      y = y-y;\n      y = y+y;\n      e = e+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (e at loop-step start < u at loop-step start). Changed: e: e at loop-step start -> e at loop-step start + 1; y: y at loop-step start -> y at loop-step start - y at loop-step start + (y at loop-step start - y at loop-step start. Unchanged: p keeps p at loop-step start; q keeps q at loop-step start; u keeps u at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'p', 'q', 'u', 'y']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int u, e, y;\n\n  u=67;\n  e=0;\n  y=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant u == 67;\n  loop invariant e <= u;\n  loop invariant ((e == 0) ==> (y == p)) && ((e > 0) ==> (y == 0));\n  loop invariant 0 <= e;\n  loop invariant (e > 0) ==> (y == 0);\n  loop invariant (e == 0) ==> (y == p);\n  loop invariant (e == 0 ==> y == \\at(p, Pre)) && (e >= 1 ==> y == 0);\n  loop invariant e >= 0;\n  loop invariant (e == 0 ==> y == \\at(p, Pre)) && (e > 0 ==> y == 0) && 0 <= e && e <= u;\n  loop assigns e, y;\n*/\nwhile (e<u) {\n      y = y-y;\n      y = y+y;\n      e = e+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int q){\n  int d, b, v, p;\n\n  d=k;\n  b=d;\n  v=b;\n  p=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (b>0) {\n      v = v+p+p;\n      b = b-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (p == \\at(k, Pre)) && (v == \\at(k, Pre)) && (b == \\at(k, Pre)) && (d == \\at(k, Pre)) && (q == \\at(q, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (b>0) {\n      v = v+p+p;\n      b = b-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (b at loop-step start > 0). Changed: b: b at loop-step start -> b at loop-step start - 1; v: v at loop-step start -> v at loop-step start + p at loop-step start + p at loop-step start. Unchanged: d keeps d at loop-step start; k keeps k at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'k', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int q){\n  int d, b, v, p;\n\n  d=k;\n  b=d;\n  v=b;\n  p=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant k == \\at(k, Pre);\n  loop invariant q == \\at(q, Pre);\n\n  loop invariant b <= \\at(k, Pre);\n  loop invariant v == \\at(k, Pre) + 2 * \\at(k, Pre) * (\\at(k, Pre) - b);\n  loop invariant d == k;\n\n  loop invariant v == k + 2*p*(k - b);\n  loop invariant p == k;\n  loop invariant b <= k;\n  loop invariant v == d + 2 * p * (d - b);\n  loop invariant p == d;\n  loop invariant d == \\at(k, Pre);\n  loop invariant b <= d;\n  loop invariant v + 2 * p * b == \\at(k,Pre) + 2 * p * \\at(k,Pre);\n  loop invariant \\at(k,Pre) >= 0 ==> (0 <= b && b <= \\at(k,Pre));\n  loop invariant p == \\at(k,Pre);\n  loop assigns v, b;\n*/\nwhile (b>0) {\n      v = v+p+p;\n      b = b-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n){\n  int t, j, l, z, q, s;\n\n  t=38;\n  j=0;\n  l=t;\n  z=n;\n  q=n;\n  s=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j<t) {\n      l = l+1;\n      z = z+l;\n      j = j+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == -8) && (q == \\at(n, Pre)) && (z == \\at(n, Pre)) && (l == 38) && (j == 0) && (t == 38) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (j<t) {\n      l = l+1;\n      z = z+l;\n      j = j+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'j', 'l', 'n', 't', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n){\n  int t, j, l, z, q, s;\n\n  t=38;\n  j=0;\n  l=t;\n  z=n;\n  q=n;\n  s=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= j <= t && l == t + j;\n  loop invariant z == n + j * t + j*(j+1)/2 && n == \\at(n, Pre) && b == \\at(b, Pre);\n  loop invariant l == t + j;\n  loop invariant z == \\at(n,Pre) + t*j + j*(j+1)/2;\n  loop invariant j <= t;\n  loop invariant b == \\at(b,Pre);\n  loop invariant n == \\at(n,Pre);\n  loop invariant l == j + 38;\n  loop invariant z == n + 38*j + j*(j+1)/2;\n  loop invariant l == 38 + j;\n  loop invariant z == \\at(n, Pre) + 38*j + j*(j+1)/2;\n  loop invariant z == n + t*j + j*(j+1)/2;\n  loop invariant j >= 0;\n  loop assigns j, l, z;\n*/\nwhile (j<t) {\n      l = l+1;\n      z = z+l;\n      j = j+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int f, j, o;\n\n  f=m-3;\n  j=0;\n  o=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j<f) {\n      if ((j%9)==0) {\n          o = o+4;\n      }\n      j = j+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (o == 6) && (j == 0) && (f == \\at(m, Pre) - 3) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (j<f) {\n      if ((j%9)==0) {\n          o = o+4;\n      }\n      j = j+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start % 9 != 0; j at loop-step start < f at loop-step start; j at loop-step start < f at loop-step start). Changed: j: j at loop-step start -> j at loop-step start + 1; o: o at loop-step start -> o at loop-step start + 4. Unchanged: f keeps f at loop-step start; k keeps k at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['f', 'j', 'k', 'm', 'o']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int f, j, o;\n\n  f=m-3;\n  j=0;\n  o=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant f == \\at(m, Pre) - 3;\n  loop invariant o == 6 + 4 * ((j + 8) / 9);\n  loop invariant j >= 0;\n\n  loop invariant k == \\at(k, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant 0 <= j && (j <= f || j == 0) && f == \\at(m, Pre) - 3 && m == \\at(m, Pre) && k == \\at(k, Pre);\n  loop invariant f == m - 3;\n  loop invariant 0 <= j;\n\n  loop assigns o, j;\n*/\nwhile (j<f) {\n      if ((j%9)==0) {\n          o = o+4;\n      }\n      j = j+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int a, g, v;\n\n  a=n;\n  g=0;\n  v=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (g<a) {\n      v = v+v;\n      v = v+g;\n      g = g+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 5) && (g == 0) && (a == \\at(n, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (g<a) {\n      v = v+v;\n      v = v+g;\n      g = g+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (g at loop-step start < a at loop-step start). Changed: g: g at loop-step start -> g at loop-step start + 1; v: v at loop-step start -> v at loop-step start + v at loop-step start + g at loop-step start. Unchanged: a keeps a at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'g', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int a, g, v;\n\n  a=n;\n  g=0;\n  v=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant a == n && m == \\at(m, Pre) && n == \\at(n, Pre);\n\n  loop invariant a == \\at(n,Pre) && n == \\at(n,Pre) && m == \\at(m,Pre);\n  loop invariant g >= 0 && v >= 5 && v >= g;\n  loop invariant a == n;\n\n  loop invariant g >= 0;\n  loop invariant (v - g) % 2 == 1;\n  loop invariant v >= 5;\n  loop invariant a == \\at(n, Pre);\n\n  loop invariant (v % 2) == 1 - (g % 2);\n  loop invariant n == \\at(n, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop assigns v, g;\n*/\nwhile (g<a) {\n      v = v+v;\n      v = v+g;\n      g = g+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int b, d, v, z, p;\n\n  b=54;\n  d=0;\n  v=-4;\n  z=0;\n  p=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (d<b) {\n      v = v+3;\n      p = p+2;\n      d = d+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (p == 4) && (z == 0) && (v == -4) && (d == 0) && (b == 54) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (d<b) {\n      v = v+3;\n      p = p+2;\n      d = d+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (d at loop-step start < b at loop-step start). Changed: d: d at loop-step start -> d at loop-step start + 1; p: p at loop-step start -> p at loop-step start + 2; v: v at loop-step start -> v at loop-step start + 3. Unchanged: b keeps b at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start; z keeps z at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int b, d, v, z, p;\n\n  b=54;\n  d=0;\n  v=-4;\n  z=0;\n  p=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == -4 + 3*d && n == \\at(n, Pre);\n  loop invariant d <= b;\n  loop invariant p == 4 + 2 * d;\n  loop invariant v == -4 + 3 * d;\n  loop invariant 0 <= d;\n  loop invariant b == 54;\n  loop invariant n == \\at(n, Pre) && q == \\at(q, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop assigns d, v, p;\n*/\nwhile (d<b) {\n      v = v+3;\n      p = p+2;\n      d = d+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n){\n  int i, v, c, e;\n\n  i=11;\n  v=i;\n  c=-6;\n  e=v;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v>0) {\n      c = c+1;\n      v = v-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (e == 11) && (c == -6) && (v == 11) && (i == 11) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (v>0) {\n      c = c+1;\n      v = v-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start > 0). Changed: c: c at loop-step start -> c at loop-step start + 1; v: v at loop-step start -> v at loop-step start - 1. Unchanged: b keeps b at loop-step start; e keeps e at loop-step start; i keeps i at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'i', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n){\n  int i, v, c, e;\n\n  i=11;\n  v=i;\n  c=-6;\n  e=v;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant c + v == 5 && v >= 0 && c >= -6;\n  loop invariant v >= 0;\n  loop invariant v <= 11;\n  loop invariant c + v == 5;\n  loop invariant i == 11;\n  loop invariant b == \\at(b, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant (-6 <= c) && (c <= 5);\n  loop invariant (0 <= v) && (v <= 11);\n  loop invariant v <= i;\n  loop invariant 0 <= v;\n  loop invariant c == i - v - 6;\n  loop assigns c, v;\n*/\nwhile (v>0) {\n      c = c+1;\n      v = v-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b){\n  int r, f, v, p;\n\n  r=64;\n  f=0;\n  v=b;\n  p=r;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (f<r) {\n      v = v+p+p;\n      f = f+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (p == 64) && (v == \\at(b, Pre)) && (f == 0) && (r == 64) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (f<r) {\n      v = v+p+p;\n      f = f+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (f at loop-step start < r at loop-step start). Changed: f: f at loop-step start -> f at loop-step start + 1; v: v at loop-step start -> v at loop-step start + p at loop-step start + p at loop-step start. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; p keeps p at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'f', 'p', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b){\n  int r, f, v, p;\n\n  r=64;\n  f=0;\n  v=b;\n  p=r;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == \\at(b, Pre) + 2*p*f;\n  loop invariant p == r;\n  loop invariant f <= r;\n  loop invariant f >= 0;\n  loop invariant b == \\at(b, Pre);\n  loop invariant 0 <= f;\n  loop invariant a == \\at(a, Pre);\n  loop invariant v == b + f*(p+p);\n  loop invariant r == 64;\n  loop invariant v == b + 2*p*f;\n  loop assigns v, f;\n*/\nwhile (f<r) {\n      v = v+p+p;\n      f = f+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k){\n  int m, i, h, v;\n\n  m=35;\n  i=0;\n  h=k;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<m) {\n      h = h+2;\n      v = v+h;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == \\at(b, Pre)) && (h == \\at(k, Pre)) && (i == 0) && (m == 35) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<m) {\n      h = h+2;\n      v = v+h;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start < m at loop-step start). Changed: h: h at loop-step start -> h at loop-step start + 2; i: i at loop-step start -> i at loop-step start + 1; v: v at loop-step start -> v at loop-step start + (h at loop-step start + 2. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'h', 'i', 'k', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k){\n  int m, i, h, v;\n\n  m=35;\n  i=0;\n  h=k;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == 35;\n  loop invariant i <= m;\n  loop invariant i >= 0;\n  loop invariant h == k + 2*i;\n  loop invariant v == b + i*k + i*i + i;\n  loop invariant v == b + i*(k+1) + i*i;\n  loop invariant b == \\at(b, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant h == \\at(k, Pre) + 2*i;\n  loop invariant v == \\at(b, Pre) + i*(\\at(k, Pre) + i + 1);\n  loop invariant 0 <= i;\n  loop invariant v == \\at(b, Pre) + i * \\at(k, Pre) + i * (i + 1);\n  loop invariant v == b + i*k + i*(i+1);\n  loop assigns h, v, i;\n*/\nwhile (i<m) {\n      h = h+2;\n      v = v+h;\n      i = i+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int q){\n  int c, i, v, g;\n\n  c=47;\n  i=0;\n  v=0;\n  g=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<c) {\n      v = v+g+g;\n      v = v+1;\n      i = i+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (g == 47) && (v == 0) && (i == 0) && (c == 47) && (q == \\at(q, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i<c) {\n      v = v+g+g;\n      v = v+1;\n      i = i+2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start < c at loop-step start). Changed: i: i at loop-step start -> i at loop-step start + 2; v: v at loop-step start -> v at loop-step start + g at loop-step start + g at loop-step start + 1. Unchanged: c keeps c at loop-step start; g keeps g at loop-step start; m keeps m at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'g', 'i', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int q){\n  int c, i, v, g;\n\n  c=47;\n  i=0;\n  v=0;\n  g=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == \\at(m, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant g == c;\n  loop invariant c == 47;\n\n  loop invariant 2*v == i*(2*g+1);\n  loop invariant v == 95 * (i / 2);\n  loop invariant i % 2 == 0;\n  loop invariant i <= c + 1;\n  loop invariant i >= 0;\n  loop invariant v == (2*g + 1) * (i / 2);\n  loop assigns v, i;\n*/\nwhile (i<c) {\n      v = v+g+g;\n      v = v+1;\n      i = i+2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int q){\n  int n, f, z, v, x;\n\n  n=77;\n  f=0;\n  z=q;\n  v=n;\n  x=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (f<n) {\n      z = z+1;\n      v = v-1;\n      f = f+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (x == 77) && (v == 77) && (z == \\at(q, Pre)) && (f == 0) && (n == 77) && (q == \\at(q, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (f<n) {\n      z = z+1;\n      v = v-1;\n      f = f+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (f at loop-step start < n at loop-step start). Changed: f: f at loop-step start -> f at loop-step start + 1; v: v at loop-step start -> v at loop-step start - 1; z: z at loop-step start -> z at loop-step start + 1. Unchanged: m keeps m at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start; x keeps x at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['f', 'm', 'n', 'q', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int q){\n  int n, f, z, v, x;\n\n  n=77;\n  f=0;\n  z=q;\n  v=n;\n  x=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant f >= 0 && f <= n && z == q + f && v == n - f && v + z == n + q;\n  loop invariant z - f == q;\n  loop invariant z == \\at(q, Pre) + f && v == n - f;\n  loop invariant 0 <= f && f <= n;\n  loop invariant z == \\at(q, Pre) + f && v == n - f && f <= n;\n  loop invariant m == \\at(m, Pre) && q == \\at(q, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant f <= n;\n  loop invariant f >= 0;\n  loop invariant z == q + f;\n  loop invariant v == n - f;\n  loop invariant n == 77;\n  loop assigns z, v, f;\n*/\nwhile (f<n) {\n      z = z+1;\n      v = v-1;\n      f = f+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int b, f, v;\n\n  b=69;\n  f=0;\n  v=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (f<b) {\n      if (f+1<=n+b) {\n          v = v+v;\n      }\n      else {\n          v = b+v;\n      }\n      f = f+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -2) && (f == 0) && (b == 69) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (f<b) {\n      if (f+1<=n+b) {\n          v = v+v;\n      }\n      else {\n          v = b+v;\n      }\n      f = f+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (f at loop-step start + 1 > n at loop-step start + b at loop-step start; f at loop-step start < b at loop-step start; f at loop-step start < b at loop-step start). Changed: f: f at loop-step start -> f at loop-step start + 1; v: v at loop-step start -> v at loop-step start + v at loop-step start. Unchanged: b keeps b at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'f', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int b, f, v;\n\n  b=69;\n  f=0;\n  v=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant b == 69;\n  loop invariant 0 <= f && f <= b;\n  loop invariant m == \\at(m, Pre) && n == \\at(n, Pre);\n  loop invariant f == 0 ==> v == -2;\n  loop invariant 0 <= f;\n  loop invariant f <= b;\n  loop invariant m == \\at(m, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop assigns f, v;\n*/\nwhile (f<b) {\n      if (f+1<=n+b) {\n          v = v+v;\n      }\n      else {\n          v = b+v;\n      }\n      f = f+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int o, k, h, u;\n\n  o=q+6;\n  k=0;\n  h=8;\n  u=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k<o) {\n      h = h+u+u;\n      k = k+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (u == \\at(q, Pre)) && (h == 8) && (k == 0) && (o == \\at(q, Pre) + 6) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (k<o) {\n      h = h+u+u;\n      k = k+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start < o at loop-step start). Changed: h: h at loop-step start -> h at loop-step start + u at loop-step start + u at loop-step start; k: k at loop-step start -> k at loop-step start + 1. Unchanged: o keeps o at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start; u keeps u at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['h', 'k', 'o', 'p', 'q', 'u']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int o, k, h, u;\n\n  o=q+6;\n  k=0;\n  h=8;\n  u=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant h == 8 + 2*u*k;\n  loop invariant u == \\at(q, Pre);\n  loop invariant o == \\at(q, Pre) + 6;\n\n  loop invariant k >= 0;\n  loop invariant o == q + 6;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n\n  loop invariant q == \\at(q, Pre) && 0 <= k && (o >= 0 ==> k <= o);\n  loop assigns h, k;\n*/\nwhile (k<o) {\n      h = h+u+u;\n      k = k+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int j, v, u;\n\n  j=73;\n  v=0;\n  u=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<j) {\n      if (v+2<=v+j) {\n          u = u+1;\n      }\n      else {\n          u = u+1;\n      }\n      v = v+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (v<j) {\n      if (v+2<=v+j) {\n          u = u+1;\n      }\n      else {\n          u = u+1;\n      }\n      v = v+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['j', 'n', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int j, v, u;\n\n  j=73;\n  v=0;\n  u=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= v && v <= j;\n  loop invariant u == v + 6;\n  loop invariant j == 73;\n  loop invariant n == \\at(n, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant u - v == 6;\n  loop invariant v >= 0;\n  loop invariant v <= j;\n  loop assigns v, u;\n*/\nwhile (v<j) {\n      if (v+2<=v+j) {\n          u = u+1;\n      }\n      else {\n          u = u+1;\n      }\n      v = v+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int q, j, v, g, l, t;\n\n  q=40;\n  j=0;\n  v=b;\n  g=-6;\n  l=3;\n  t=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j<q) {\n      g = g+l;\n      l = l+v;\n      j = j+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (j<q) {\n      g = g+l;\n      l = l+v;\n      j = j+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'g', 'j', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m){\n  int q, j, v, g, l, t;\n\n  q=40;\n  j=0;\n  v=b;\n  g=-6;\n  l=3;\n  t=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == \\at(b, Pre);\n  loop invariant l == 3 + j * v;\n  loop invariant 2 * g + 12 == 6 * j + v * j * (j - 1);\n  loop invariant 0 <= j && j <= q;\n  loop invariant 2*(g + 6 - 3*j) == v * j * (j - 1);\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant g == -6 + 3*j + v * ((j*(j-1))/2);\n  loop invariant v == b;\n  loop invariant g == -6 + 3*j + v*(j*(j-1)/2);\n  loop invariant j <= q;\n  loop invariant j >= 0;\n  loop invariant l == 3 + v * j;\n  loop assigns g, l, j;\n*/\nwhile (j<q) {\n      g = g+l;\n      l = l+v;\n      j = j+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p){\n  int k, j, v;\n\n  k=52;\n  j=k;\n  v=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j>0) {\n      v = a+8;\n      v = v+1;\n      j = j-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -8) && (j == 52) && (k == 52) && (p == \\at(p, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (j>0) {\n      v = a+8;\n      v = v+1;\n      j = j-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start > 0). Changed: j: j at loop-step start -> j at loop-step start - 1; v: v at loop-step start -> a at loop-step start + 8 + 1. Unchanged: a keeps a at loop-step start; k keeps k at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'j', 'k', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p){\n  int k, j, v;\n\n  k=52;\n  j=k;\n  v=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (j >= 0) && (j <= k);\n  loop invariant (a == \\at(a, Pre)) && (p == \\at(p, Pre)) && (k == 52) && ((v == a + 9) || (j == 52 && v == -8));\n  loop invariant (0 <= j) && (j <= 52);\n  loop invariant k == 52;\n  loop invariant a == \\at(a, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant 0 <= j && j <= k;\n  loop invariant (j == k && v == -8) || (j < k && v == a + 9);\n  loop invariant 0 <= j;\n  loop invariant j <= 52;\n  loop invariant 0 <= j <= 52;\n  loop assigns j, v;\n*/\nwhile (j>0) {\n      v = a+8;\n      v = v+1;\n      j = j-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int o, n, v, j, a;\n\n  o=b+20;\n  n=o;\n  v=-4;\n  j=0;\n  a=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (n>0) {\n      v = v+1;\n      j = j+v;\n      n = n-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (a == -3) && (j == 0) && (v == -4) && (n == \\at(b, Pre) + 20) && (o == \\at(b, Pre) + 20) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (n>0) {\n      v = v+1;\n      j = j+v;\n      n = n-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (n at loop-step start > 0). Changed: j: j at loop-step start -> j at loop-step start + (v at loop-step start + 1; n: n at loop-step start -> n at loop-step start - 1; v: v at loop-step start -> v at loop-step start + 1. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; m keeps m at loop-step start; o keeps o at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'j', 'm', 'n', 'o', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m){\n  int o, n, v, j, a;\n\n  o=b+20;\n  n=o;\n  v=-4;\n  j=0;\n  a=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == -4 + (o - n);\n  loop invariant j == (o - n) * (-4) + (o - n) * ((o - n) + 1) / 2;\n  loop invariant o - n >= 0;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant o == b + 20;\n  loop invariant n == o - v - 4;\n  loop invariant j == (v + 4) * (v - 3) / 2;\n  loop invariant v >= -4;\n  loop invariant v == o - n - 4;\n  loop invariant j == ((o - n) * (o - n - 7)) / 2;\n  loop invariant n <= o;\n  loop invariant v + n == \\at(b, Pre) + 16;\n  loop invariant 2*j == (\\at(b, Pre) + 20 - n) * (\\at(b, Pre) + 13 - n);\n\n  loop invariant j == (o - n) * (o - n - 7) / 2;\n\n  loop assigns v, j, n;\n*/\nwhile (n>0) {\n      v = v+1;\n      j = j+v;\n      n = n-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k){\n  int l, i, a;\n\n  l=(k%12)+13;\n  i=0;\n  a=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      a = k+(-5);\n      a = a+a;\n      i = i+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (a == \\at(k, Pre) % 12 + 13) && (i == 0) && (l == \\at(k, Pre) % 12 + 13) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      a = k+(-5);\n      a = a+a;\n      i = i+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start < l at loop-step start). Changed: a: a at loop-step start -> k at loop-step start + -5 + (k at loop-step start + -5; i: i at loop-step start -> i at loop-step start + 3. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; l keeps l at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k){\n  int l, i, a;\n\n  l=(k%12)+13;\n  i=0;\n  a=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == k%12 + 13;\n  loop invariant i % 3 == 0;\n\n  loop invariant (i == 0) ==> (a == l);\n  loop invariant (i > 0) ==> (a == 2*k - 10);\n  loop invariant k == \\at(k, Pre);\n  loop invariant b == \\at(b, Pre);\n  loop invariant 0 <= i && i <= l + 2;\n  loop invariant i == 0 || a == 2 * \\at(k, Pre) - 10;\n  loop invariant l == (\\at(k, Pre) % 12) + 13;\n  loop invariant (i == 0) ==> (a == l) && (i > 0) ==> (a == 2*k - 10);\n  loop invariant l == ((\\at(k, Pre)) % 12) + 13;\n  loop invariant l == (\\at(k, Pre) % 12) + 13 &&\n                   b == \\at(b, Pre) &&\n                   k == \\at(k, Pre);\n\n  loop invariant i >= 0 && i <= l + 2;\n  loop invariant (i == 0 && a == l) || (i > 0 && a == 2*k - 10);\n  loop assigns a, i;\n*/\nwhile (i<l) {\n      a = k+(-5);\n      a = a+a;\n      i = i+3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int p){\n  int v, r, u;\n\n  v=k-4;\n  r=0;\n  u=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (r<v) {\n      u = r+u;\n      r = r+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (u == \\at(k, Pre)) && (r == 0) && (v == \\at(k, Pre) - 4) && (p == \\at(p, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (r<v) {\n      u = r+u;\n      r = r+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (r at loop-step start < v at loop-step start). Changed: r: r at loop-step start -> r at loop-step start + 1; u: u at loop-step start -> r at loop-step start + u at loop-step start. Unchanged: k keeps k at loop-step start; p keeps p at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'p', 'r', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int p){\n  int v, r, u;\n\n  v=k-4;\n  r=0;\n  u=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == k - 4;\n  loop invariant 0 <= r;\n\n  loop invariant 2*(u - k) == r*(r - 1);\n  loop invariant u == \\at(k, Pre) + r*(r-1)/2;\n  loop invariant v == \\at(k, Pre) - 4;\n  loop invariant k == \\at(k, Pre);\n  loop invariant v >= 0 ==> r <= v;\n  loop invariant r >= 0;\n  loop invariant u == k + r*(r-1)/2;\n  loop invariant p == \\at(p,Pre);\n  loop assigns r, u;\n*/\nwhile (r<v) {\n      u = r+u;\n      r = r+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int q){\n  int j, v, t;\n\n  j=(k%18)+18;\n  v=0;\n  t=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<j) {\n      t = t+v;\n      v = v+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (t == \\at(k, Pre)) && (v == 0) && (j == \\at(k, Pre) % 18 + 18) && (q == \\at(q, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (v<j) {\n      t = t+v;\n      v = v+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start < j at loop-step start). Changed: t: t at loop-step start -> t at loop-step start + v at loop-step start; v: v at loop-step start -> v at loop-step start + 1. Unchanged: j keeps j at loop-step start; k keeps k at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['j', 'k', 'q', 't', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int q){\n  int j, v, t;\n\n  j=(k%18)+18;\n  v=0;\n  t=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant t == k + (v*(v-1))/2;\n  loop invariant v <= j;\n  loop invariant 0 <= v;\n  loop invariant j == (k % 18) + 18;\n  loop invariant t == k + v*(v - 1)/2 && j >= 0;\n  loop invariant k == \\at(k, Pre);\n  loop invariant j == (\\at(k, Pre) % 18) + 18;\n  loop invariant t == \\at(k, Pre) + v*(v-1)/2;\n  loop invariant q == \\at(q,Pre);\n  loop invariant t == \\at(k, Pre) + (v*(v-1))/2;\n  loop assigns t, v;\n*/\nwhile (v<j) {\n      t = t+v;\n      v = v+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m){\n  int d, w, o;\n\n  d=a+19;\n  w=0;\n  o=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (w<d) {\n      if (w+6<=d+d) {\n          o = o+2;\n      }\n      w = w+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (o == -1) && (w == 0) && (d == \\at(a, Pre) + 19) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (w<d) {\n      if (w+6<=d+d) {\n          o = o+2;\n      }\n      w = w+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (w at loop-step start + 6 > d at loop-step start + d at loop-step start; w at loop-step start < d at loop-step start; w at loop-step start < d at loop-step start). Changed: o: o at loop-step start -> o at loop-step start + 2; w: w at loop-step start -> w at loop-step start + 1. Unchanged: a keeps a at loop-step start; d keeps d at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'd', 'm', 'o', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m){\n  int d, w, o;\n\n  d=a+19;\n  w=0;\n  o=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= w;\n  loop invariant (d >= 0) ==> (w <= d);\n  loop invariant o >= -1 && o <= -1 + 2*w;\n  loop invariant d == \\at(a, Pre) + 19;\n  loop invariant a == \\at(a, Pre) && m == \\at(m, Pre);\n  loop invariant a == \\at(a, Pre);\n  loop invariant m == \\at(m, Pre);\n\n  loop invariant (o + 1) % 2 == 0;\n\n  loop invariant o >= -1;\n  loop invariant o <= 2*w - 1;\n  loop invariant o <= -1 + 2*w;\n  loop assigns w, o;\n*/\nwhile (w<d) {\n      if (w+6<=d+d) {\n          o = o+2;\n      }\n      w = w+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p){\n  int d, i, v;\n\n  d=31;\n  i=0;\n  v=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<d) {\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -5) && (i == 0) && (d == 31) && (p == \\at(p, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i<d) {\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start < d at loop-step start). Changed: i: i at loop-step start -> i at loop-step start + 1; v: v at loop-step start -> v at loop-step start + 1 + (v at loop-step start + 1. Unchanged: d keeps d at loop-step start; m keeps m at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'i', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p){\n  int d, i, v;\n\n  d=31;\n  i=0;\n  v=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= i && i <= d;\n  loop invariant d == 31;\n  loop invariant m == \\at(m, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant i >= 0;\n  loop invariant i <= d;\n  loop invariant i == 0 ==> v == -5;\n  loop invariant i > 0 ==> v % 2 == 0;\n  loop assigns v, i;\n*/\nwhile (i<d) {\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p){\n  int f, m, x;\n\n  f=a+18;\n  m=0;\n  x=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (m<f) {\n      x = x+m;\n      m = m+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (x == 1) && (m == 0) && (f == \\at(a, Pre) + 18) && (p == \\at(p, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (m<f) {\n      x = x+m;\n      m = m+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (m at loop-step start < f at loop-step start). Changed: m: m at loop-step start -> m at loop-step start + 1; x: x at loop-step start -> x at loop-step start + m at loop-step start. Unchanged: a keeps a at loop-step start; f keeps f at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'f', 'm', 'p', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p){\n  int f, m, x;\n\n  f=a+18;\n  m=0;\n  x=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant x == 1 + (m*(m-1))/2;\n\n  loop invariant f == \\at(a, Pre) + 18;\n  loop invariant a == \\at(a, Pre) && p == \\at(p, Pre);\n  loop invariant a == \\at(a, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant f == a + 18;\n  loop invariant x == 1 + m*(m-1)/2;\n  loop invariant m >= 0;\n  loop invariant (m <= f) || (f < 0);\n  loop invariant 0 <= m;\n\n\n  loop assigns x, m;\n*/\nwhile (m<f) {\n      x = x+m;\n      m = m+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int q){\n  int j, u, v, g, e, r;\n\n  j=a;\n  u=0;\n  v=a;\n  g=q;\n  e=j;\n  r=u;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<j) {\n      r = v+g+e;\n      u = u+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<j) {\n      r = v+g+e;\n      u = u+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'e', 'g', 'j', 'q', 'r', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int q){\n  int j, u, v, g, e, r;\n\n  j=a;\n  u=0;\n  v=a;\n  g=q;\n  e=j;\n  r=u;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == a && g == q && e == a && j == a && v == e;\n  loop invariant u >= 0;\n  loop invariant j == \\at(a, Pre);\n  loop invariant v == \\at(a, Pre) && g == \\at(q, Pre) && e == j;\n\n  loop invariant u > 0 ==> r == v + g + e;\n  loop invariant j == a;\n  loop invariant ((u == 0) ==> (r == u)) && ((u > 0) ==> (r == v + g + e)) && (v == a) && (g == q) && (e == j);\n  loop invariant j == a && v == a && e == a && 0 <= u && (u == 0 ==> r == 0) && (u > 0 ==> r == v + g + e);\n  loop invariant a == \\at(a,Pre);\n  loop invariant 0 <= u;\n  loop invariant j < 0 || u <= j;\n  loop invariant (u > 0) ==> r == v + g + e;\n  loop invariant e == j;\n  loop invariant v == j;\n  loop invariant g == \\at(q, Pre);\n  loop assigns r, u;\n*/\nwhile (u<j) {\n      r = v+g+e;\n      u = u+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int q){\n  int j, t, x, s, v, d;\n\n  j=b;\n  t=0;\n  x=j;\n  s=0;\n  v=q;\n  d=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t<j) {\n      s = s+v;\n      t = t+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (d == -3) && (v == \\at(q, Pre)) && (s == 0) && (x == \\at(b, Pre)) && (t == 0) && (j == \\at(b, Pre)) && (q == \\at(q, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (t<j) {\n      s = s+v;\n      t = t+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start < j at loop-step start). Changed: s: s at loop-step start -> s at loop-step start + v at loop-step start; t: t at loop-step start -> t at loop-step start + 3. Unchanged: b keeps b at loop-step start; d keeps d at loop-step start; j keeps j at loop-step start; q keeps q at loop-step start; v keeps v at loop-step start; x keeps x at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'j', 'q', 's', 't', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int q){\n  int j, t, x, s, v, d;\n\n  j=b;\n  t=0;\n  x=j;\n  s=0;\n  v=q;\n  d=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 3*s == v*t;\n\n  loop invariant t >= 0;\n  loop invariant v == \\at(q, Pre);\n  loop invariant j == \\at(b, Pre);\n  loop invariant t % 3 == 0;\n  loop invariant s == v * (t / 3);\n  loop invariant (j <= 0) || t <= j + 2;\n\n\n  loop invariant v == q;\n  loop invariant j == b;\n  loop invariant s == (t/3) * v;\n  loop assigns s, t;\n*/\nwhile (t<j) {\n      s = s+v;\n      t = t+3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int d, q, e, v, o, h;\n\n  d=68;\n  q=0;\n  e=0;\n  v=m;\n  o=q;\n  h=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (q<d) {\n      h = e+v+o;\n      q = q+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (h == \\at(k, Pre)) && (o == 0) && (v == \\at(m, Pre)) && (e == 0) && (q == 0) && (d == 68) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (q<d) {\n      h = e+v+o;\n      q = q+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (q at loop-step start < d at loop-step start). Changed: h: h at loop-step start -> e at loop-step start + v at loop-step start + o at loop-step start; q: q at loop-step start -> q at loop-step start + 1. Unchanged: d keeps d at loop-step start; e keeps e at loop-step start; k keeps k at loop-step start; m keeps m at loop-step start; o keeps o at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'e', 'h', 'k', 'm', 'o', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int d, q, e, v, o, h;\n\n  d=68;\n  q=0;\n  e=0;\n  v=m;\n  o=q;\n  h=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant q >= 0 && q <= d;\n  loop invariant (q == 0 && h == k) || (q >= 1 && h == e + v + o);\n  loop invariant e == 0 && o == 0;\n  loop invariant v == \\at(m, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant 0 <= q && q <= d;\n  loop invariant e == 0;\n  loop invariant o == 0;\n  loop invariant (q == 0) ==> (h == \\at(k, Pre));\n  loop invariant (q >= 1) ==> (h == e + v + o);\n  loop invariant m == \\at(m, Pre);\n  loop invariant v == m;\n  loop invariant h == k || h == e+v+o;\n  loop invariant d == 68;\n  loop invariant (q == 0 && h == k) || (q > 0 && h == e + v + o);\n  loop invariant (q > 0) ==> (h == e + v + o);\n  loop assigns h, q;\n*/\nwhile (q<d) {\n      h = e+v+o;\n      q = q+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m){\n  int h, i, l, w;\n\n  h=m-3;\n  i=0;\n  l=3;\n  w=h;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<h) {\n      l = l+w+w;\n      l = l+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (i<h) {\n      l = l+w+w;\n      l = l+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'h', 'i', 'l', 'm', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m){\n  int h, i, l, w;\n\n  h=m-3;\n  i=0;\n  l=3;\n  w=h;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i >= 0;\n  loop invariant l == 3 + i*(2*w + 1);\n  loop invariant w == h;\n  loop invariant h == \\at(m, Pre) - 3;\n\n  loop invariant h == m - 3;\n  loop invariant m == \\at(m, Pre);\n  loop invariant a == \\at(a, Pre);\n  loop invariant h >= 0 ==> i <= h;\n\n  loop invariant 0 <= i;\n  loop invariant l == 3 + i*(2*h + 1);\n  loop assigns l, i;\n*/\nwhile (i<h) {\n      l = l+w+w;\n      l = l+1;\n      i = i+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int h, i, v, d;\n\n  h=53;\n  i=0;\n  v=i;\n  d=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<h) {\n      v = v+d+d;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (d == -6) && (v == 0) && (i == 0) && (h == 53) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<h) {\n      v = v+d+d;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start < h at loop-step start). Changed: i: i at loop-step start -> i at loop-step start + 1; v: v at loop-step start -> v at loop-step start + d at loop-step start + d at loop-step start. Unchanged: b keeps b at loop-step start; d keeps d at loop-step start; h keeps h at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'h', 'i', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m){\n  int h, i, v, d;\n\n  h=53;\n  i=0;\n  v=i;\n  d=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == -12 * i;\n  loop invariant i <= h;\n  loop invariant i >= 0;\n  loop invariant h == 53;\n  loop invariant v == i * (d + d);\n  loop invariant 0 <= i;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant v <= 0;\n  loop assigns i, v;\n*/\nwhile (i<h) {\n      v = v+d+d;\n      i = i+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int x, z, s;\n\n  x=40;\n  z=0;\n  s=z;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (z<x) {\n      s = p;\n      s = s-s;\n      z = z+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == 0) && (z == 0) && (x == 40) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (z<x) {\n      s = p;\n      s = s-s;\n      z = z+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (z at loop-step start < x at loop-step start). Changed: s: s at loop-step start -> p at loop-step start - p at loop-step start; z: z at loop-step start -> z at loop-step start + 1. Unchanged: p keeps p at loop-step start; q keeps q at loop-step start; x keeps x at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['p', 'q', 's', 'x', 'z']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int x, z, s;\n\n  x=40;\n  z=0;\n  s=z;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant s == 0;\n  loop invariant 0 <= z && z <= x;\n  loop invariant x == 40;\n  loop invariant p == \\at(p, Pre);\n  loop invariant z <= x;\n  loop invariant q == \\at(q, Pre);\n  loop invariant z >= 0;\n  loop assigns s, z;\n*/\nwhile (z<x) {\n      s = p;\n      s = s-s;\n      z = z+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int q){\n  int m, d, v, o, y, h;\n\n  m=a-10;\n  d=0;\n  v=-1;\n  o=-8;\n  y=-8;\n  h=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (d<m) {\n      h = v+o+y;\n      v = v+1;\n      d = d+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (h == \\at(q, Pre)) && (y == -8) && (o == -8) && (v == -1) && (d == 0) && (m == \\at(a, Pre) - 10) && (q == \\at(q, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (d<m) {\n      h = v+o+y;\n      v = v+1;\n      d = d+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (d at loop-step start < m at loop-step start). Changed: d: d at loop-step start -> d at loop-step start + 1; h: h at loop-step start -> v at loop-step start + o at loop-step start + y at loop-step start; v: v at loop-step start -> v at loop-step start + 1. Unchanged: a keeps a at loop-step start; m keeps m at loop-step start; o keeps o at loop-step start; q keeps q at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'd', 'h', 'm', 'o', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int q){\n  int m, d, v, o, y, h;\n\n  m=a-10;\n  d=0;\n  v=-1;\n  o=-8;\n  y=-8;\n  h=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == d - 1;\n  loop invariant (d == 0 ==> h == \\at(q, Pre)) && (d > 0 ==> h == d - 2 + o + y);\n  loop invariant o == -8 && y == -8;\n  loop invariant m == \\at(a, Pre) - 10;\n  loop invariant a == \\at(a, Pre) && q == \\at(q, Pre);\n  loop invariant (d == 0) ==> h == \\at(q, Pre);\n  loop invariant d >= 1 ==> h == d - 2 + o + y;\n  loop invariant d <= m || d == 0;\n  loop invariant a == \\at(a, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant o == -8;\n  loop invariant y == -8;\n  loop invariant 0 <= d;\n  loop invariant m == a - 10;\n  loop invariant (d == 0) ==> (h == q);\n\n  loop invariant (d >= 1) ==> (h == v - 17);\n  loop assigns d, v, h;\n*/\nwhile (d<m) {\n      h = v+o+y;\n      v = v+1;\n      d = d+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int m, c, w;\n\n  m=33;\n  c=m;\n  w=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (c>0) {\n      w = w-w;\n      w = w+c;\n      c = c-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (w == 6) && (c == 33) && (m == 33) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (c>0) {\n      w = w-w;\n      w = w+c;\n      c = c-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (c at loop-step start > 0). Changed: c: c at loop-step start -> c at loop-step start - 1; w: w at loop-step start -> w at loop-step start - w at loop-step start + c at loop-step start. Unchanged: m keeps m at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'm', 'p', 'q', 'w']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int m, c, w;\n\n  m=33;\n  c=m;\n  w=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == 33;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant 0 <= c && c <= 33;\n  loop invariant 0 <= w && w <= 33;\n  loop invariant c >= 0;\n  loop invariant w >= 0;\n  loop invariant w <= c + 1;\n  loop invariant (c == 33 && w == 6) || (w == c + 1);\n  loop invariant c <= m;\n  loop invariant ((c == 33 && w == 6) || w == c + 1);\n  loop invariant 0 <= c;\n  loop invariant c <= 33;\n  loop invariant (c == m && w == 6) || w == c + 1;\n  loop assigns w, c;\n*/\nwhile (c>0) {\n      w = w-w;\n      w = w+c;\n      c = c-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p){\n  int i, u, z, v, y, b;\n\n  i=41;\n  u=0;\n  z=1;\n  v=u;\n  y=i;\n  b=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<i) {\n      b = z+v+y;\n      u = u+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<i) {\n      b = z+v+y;\n      u = u+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'p', 'u', 'v', 'y', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p){\n  int i, u, z, v, y, b;\n\n  i=41;\n  u=0;\n  z=1;\n  v=u;\n  y=i;\n  b=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i == 41;\n  loop invariant z == 1;\n  loop invariant v == 0;\n  loop invariant y == i;\n\n  loop invariant (0 <= u) && (u <= i);\n  loop invariant 0 <= u && u <= i;\n  loop invariant z == 1 && v == 0 && y == 41 && u <= i && ((u == 0) ==> (b == a));\n  loop invariant a == \\at(a, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant (u > 0) ==> (b == z + v + y);\n  loop invariant u <= i;\n  loop invariant (u != 0) ==> (b == z + v + y);\n  loop assigns b, u;\n*/\nwhile (u<i) {\n      b = z+v+y;\n      u = u+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (b<i) {\n      v = v+v;\n      b = b+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 1) && (b == 0) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (b<i) {\n      v = v+v;\n      b = b+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (b at loop-step start < i at loop-step start). Changed: b: b at loop-step start -> b at loop-step start + 1; v: v at loop-step start -> v at loop-step start + v at loop-step start. Unchanged: i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i == 53;\n  loop invariant p == \\at(p, Pre) && q == \\at(q, Pre) && 0 <= b && b <= i && v >= 1;\n  loop invariant (0 <= b) && (b <= i);\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant b >= 0 && b <= i;\n\n  loop invariant 0 <= b && b <= i;\n  loop invariant 0 <= b;\n  loop invariant b <= i;\n  loop invariant v >= 1;\n  loop invariant v >= 2*b;\n  loop assigns b, v;\n*/\nwhile (b<i) {\n      v = v+v;\n      b = b+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int p){\n  int h, o, v, s, w, x;\n\n  h=(k%12)+16;\n  o=0;\n  v=h;\n  s=k;\n  w=k;\n  x=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (o<h) {\n      s = s+w;\n      w = w+v;\n      o = o+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (x == 2) && (w == \\at(k, Pre)) && (s == \\at(k, Pre)) && (v == \\at(k, Pre) % 12 + 16) && (o == 0) && (h == \\at(k, Pre) % 12 + 16) && (p == \\at(p, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (o<h) {\n      s = s+w;\n      w = w+v;\n      o = o+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (o at loop-step start < h at loop-step start). Changed: o: o at loop-step start -> o at loop-step start + 1; s: s at loop-step start -> s at loop-step start + w at loop-step start; w: w at loop-step start -> w at loop-step start + v at loop-step start. Unchanged: h keeps h at loop-step start; k keeps k at loop-step start; p keeps p at loop-step start; v keeps v at loop-step start; x keeps x at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['h', 'k', 'o', 'p', 's', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int p){\n  int h, o, v, s, w, x;\n\n  h=(k%12)+16;\n  o=0;\n  v=h;\n  s=k;\n  w=k;\n  x=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant o <= h;\n  loop invariant o >= 0;\n  loop invariant w == k + o*v;\n  loop invariant s == k*(1+o) + v*o*(o-1)/2;\n  loop invariant h == (\\at(k,Pre) % 12) + 16;\n  loop invariant v == h;\n  loop invariant s == k*(o+1) + v*o*(o-1)/2;\n  loop invariant w == k + v*o;\n  loop invariant 2*s == 2*k*(o+1) + v*o*(o-1);\n  loop invariant k == \\at(k, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant v == (\\at(k, Pre) % 12) + 16;\n  loop invariant 0 <= o;\n  loop invariant w == \\at(k, Pre) + o * v;\n\n  loop assigns s, w, o;\n*/\nwhile (o<h) {\n      s = s+w;\n      w = w+v;\n      o = o+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int l, s, k, v;\n\n  l=52;\n  s=0;\n  k=-8;\n  v=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<l) {\n      k = k+v+v;\n      k = k+1;\n      s = s+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -6) && (k == -8) && (s == 0) && (l == 52) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s<l) {\n      k = k+v+v;\n      k = k+1;\n      s = s+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start < l at loop-step start). Changed: k: k at loop-step start -> k at loop-step start + v at loop-step start + v at loop-step start + 1; s: s at loop-step start -> s at loop-step start + 1. Unchanged: b keeps b at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m){\n  int l, s, k, v;\n\n  l=52;\n  s=0;\n  k=-8;\n  v=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant k + 11*s == -8 && l == 52 && v == -6 && m == \\at(m, Pre) && b == \\at(b, Pre);\n  loop invariant s <= l;\n  loop invariant k == -8 + s*(2*v + 1);\n  loop invariant 0 <= s;\n  loop invariant v == -6;\n  loop invariant l == 52;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant k == -8 - 11*s;\n  loop invariant k + 11*s == -8;\n  loop invariant s >= 0;\n  loop assigns k, s;\n*/\nwhile (s<l) {\n      k = k+v+v;\n      k = k+1;\n      s = s+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p){\n  int w, e, c, v, k;\n\n  w=59;\n  e=0;\n  c=-4;\n  v=w;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (e<w) {\n      c = c+3;\n      k = k+2;\n      e = e+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (k == -6) && (v == 59) && (c == -4) && (e == 0) && (w == 59) && (p == \\at(p, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (e<w) {\n      c = c+3;\n      k = k+2;\n      e = e+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (e at loop-step start < w at loop-step start). Changed: c: c at loop-step start -> c at loop-step start + 3; e: e at loop-step start -> e at loop-step start + 1; k: k at loop-step start -> k at loop-step start + 2. Unchanged: m keeps m at loop-step start; p keeps p at loop-step start; v keeps v at loop-step start; w keeps w at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'e', 'k', 'm', 'p', 'w']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p){\n  int w, e, c, v, k;\n\n  w=59;\n  e=0;\n  c=-4;\n  v=w;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant c == -4 + 3*e;\n  loop invariant k == -6 + 2*e;\n  loop invariant 0 <= e && e <= w;\n  loop invariant m == \\at(m, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant e >= 0;\n  loop invariant e <= w;\n  loop assigns c, k, e;\n*/\nwhile (e<w) {\n      c = c+3;\n      k = k+2;\n      e = e+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b){\n  int x, c, v, o;\n\n  x=40;\n  c=x;\n  v=c;\n  o=x;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (c>0) {\n      v = v+4;\n      c = c-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (o == 40) && (v == 40) && (c == 40) && (x == 40) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (c>0) {\n      v = v+4;\n      c = c-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (c at loop-step start > 0). Changed: c: c at loop-step start -> c at loop-step start - 1; v: v at loop-step start -> v at loop-step start + 4. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; o keeps o at loop-step start; x keeps x at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b){\n  int x, c, v, o;\n\n  x=40;\n  c=x;\n  v=c;\n  o=x;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant c >= 0;\n  loop invariant c <= x;\n  loop invariant v == x + 4*(x - c);\n  loop invariant a == \\at(a, Pre);\n  loop invariant b == \\at(b, Pre);\n  loop invariant x == 40;\n  loop invariant v == 200 - 4*c;\n  loop invariant v + 4 * c == 200;\n  loop invariant c <= 40;\n  loop invariant 0 <= c;\n  loop invariant 40 <= v && v <= 200;\n  loop assigns v, c;\n*/\nwhile (c>0) {\n      v = v+4;\n      c = c-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int p){\n  int g, l, m, v, d;\n\n  g=54;\n  l=g;\n  m=k;\n  v=2;\n  d=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (l>0) {\n      m = m+v+d;\n      m = m+1;\n      l = l-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (d == -4) && (v == 2) && (m == \\at(k, Pre)) && (l == 54) && (g == 54) && (p == \\at(p, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (l>0) {\n      m = m+v+d;\n      m = m+1;\n      l = l-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'g', 'k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int p){\n  int g, l, m, v, d;\n\n  g=54;\n  l=g;\n  m=k;\n  v=2;\n  d=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == \\at(k, Pre) + l - 54;\n  loop invariant (0 <= l) && (l <= 54);\n  loop invariant k == \\at(k, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant g == 54;\n  loop invariant m - l == k - 54;\n  loop invariant 0 <= l && l <= 54;\n  loop invariant m - l == \\at(k, Pre) - 54;\n  loop invariant v == 2;\n  loop invariant d == -4;\n  loop invariant 0 <= l;\n  loop invariant l <= 54;\n  loop invariant l >= 0;\n  loop invariant m <= k;\n  loop invariant m >= k - 54;\n  loop assigns m, l;\n*/\nwhile (l>0) {\n      m = m+v+d;\n      m = m+1;\n      l = l-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n){\n  int b, v, i, f, r, s;\n\n  b=a+13;\n  v=0;\n  i=3;\n  f=-6;\n  r=b;\n  s=v;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<b) {\n      s = i+f+r;\n      i = i+1;\n      v = v+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == 0) && (r == \\at(a, Pre) + 13) && (f == -6) && (i == 3) && (v == 0) && (b == \\at(a, Pre) + 13) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (v<b) {\n      s = i+f+r;\n      i = i+1;\n      v = v+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start < b at loop-step start). Changed: i: i at loop-step start -> i at loop-step start + 1; s: s at loop-step start -> i at loop-step start + f at loop-step start + r at loop-step start; v: v at loop-step start -> v at loop-step start + 1. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; f keeps f at loop-step start; n keeps n at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'f', 'i', 'n', 'r', 's', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n){\n  int b, v, i, f, r, s;\n\n  b=a+13;\n  v=0;\n  i=3;\n  f=-6;\n  r=b;\n  s=v;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i == 3 + v;\n  loop invariant v == 0 || v <= b;\n  loop invariant v >= 0;\n  loop invariant r == b;\n  loop invariant v >= 1 ==> s == v + 2 + f + r;\n  loop invariant a == \\at(a, Pre) && n == \\at(n, Pre);\n  loop invariant b == a + 13;\n  loop invariant i >= 3;\n\n  loop invariant f == -6;\n  loop invariant a == \\at(a, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant (v == 0) ==> (s == 0);\n  loop invariant (v > 0) ==> (s == i + a + 6);\n  loop invariant i == v + 3;\n\n  loop invariant (v == 0 && s == 0) || (v > 0 && s == i - 1 + f + r);\n  loop assigns s, i, v;\n*/\nwhile (v<b) {\n      s = i+f+r;\n      i = i+1;\n      v = v+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n){\n  int q, k, m, g, v;\n\n  q=35;\n  k=q;\n  m=k;\n  g=n;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k>0) {\n      m = m+5;\n      k = k-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == \\at(b, Pre)) && (g == \\at(n, Pre)) && (m == 35) && (k == 35) && (q == 35) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (k>0) {\n      m = m+5;\n      k = k-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start > 0). Changed: k: k at loop-step start -> k at loop-step start - 1; m: m at loop-step start -> m at loop-step start + 5. Unchanged: b keeps b at loop-step start; g keeps g at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'm', 'n', 'q']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n){\n  int q, k, m, g, v;\n\n  q=35;\n  k=q;\n  m=k;\n  g=n;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m + 5 * k == 210;\n  loop invariant 0 <= k && k <= 35;\n  loop invariant 35 <= m && m <= 210;\n  loop invariant k >= 0;\n  loop invariant k <= q;\n  loop invariant b == \\at(b, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant k <= 35;\n  loop invariant q == 35;\n  loop invariant m >= 35 && m <= 210;\n  loop invariant m == 210 - 5*k;\n  loop assigns m, k;\n*/\nwhile (k>0) {\n      m = m+5;\n      k = k-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int b, f, v, x;\n\n  b=62;\n  f=0;\n  v=b;\n  x=f;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (f<b) {\n      x = x+x;\n      f = f+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (x == 0) && (v == 62) && (f == 0) && (b == 62) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (f<b) {\n      x = x+x;\n      f = f+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (f at loop-step start < b at loop-step start). Changed: f: f at loop-step start -> f at loop-step start + 1; x: x at loop-step start -> x at loop-step start + x at loop-step start. Unchanged: b keeps b at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'f', 'm', 'n', 'x']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int b, f, v, x;\n\n  b=62;\n  f=0;\n  v=b;\n  x=f;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant x == 0;\n  loop invariant f <= b;\n  loop invariant m == \\at(m, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant f >= 0;\n  loop invariant 0 <= f;\n  loop assigns x, f;\n*/\nwhile (f<b) {\n      x = x+x;\n      f = f+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p){\n  int u, d, j, z, v, q;\n\n  u=(p%37)+18;\n  d=0;\n  j=d;\n  z=p;\n  v=2;\n  q=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (d<u) {\n      j = j+4;\n      v = v+2;\n      d = d+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (q == -5) && (v == 2) && (z == \\at(p, Pre)) && (j == 0) && (d == 0) && (u == \\at(p, Pre) % 37 + 18) && (p == \\at(p, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (d<u) {\n      j = j+4;\n      v = v+2;\n      d = d+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (d at loop-step start < u at loop-step start). Changed: d: d at loop-step start -> d at loop-step start + 1; j: j at loop-step start -> j at loop-step start + 4; v: v at loop-step start -> v at loop-step start + 2. Unchanged: n keeps n at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start; u keeps u at loop-step start; z keeps z at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'j', 'n', 'p', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p){\n  int u, d, j, z, v, q;\n\n  u=(p%37)+18;\n  d=0;\n  j=d;\n  z=p;\n  v=2;\n  q=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant j == 4*d && v == 2 + 2*d && n == \\at(n, Pre) && p == \\at(p, Pre);\n  loop invariant j == 4 * d;\n  loop invariant v == 2 * d + 2;\n  loop invariant d >= 0 && (u <= 0 || d <= u);\n  loop invariant p == \\at(p, Pre) && n == \\at(n, Pre);\n  loop invariant d >= 0;\n  loop invariant v == 2 + 2*d;\n\n  loop invariant n == \\at(n, Pre) && p == \\at(p, Pre) && u == (\\at(p, Pre) % 37) + 18;\n  loop invariant n == \\at(n, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant u == (\\at(p, Pre) % 37) + 18;\n  loop assigns d, j, v;\n*/\nwhile (d<u) {\n      j = j+4;\n      v = v+2;\n      d = d+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n){\n  int r, w, b, y, x, v;\n\n  r=(k%12)+11;\n  w=0;\n  b=-2;\n  y=4;\n  x=k;\n  v=w;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (w<r) {\n      v = b+y+x;\n      b = b+1;\n      w = w+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 0) && (x == \\at(k, Pre)) && (y == 4) && (b == -2) && (w == 0) && (r == \\at(k, Pre) % 12 + 11) && (n == \\at(n, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (w<r) {\n      v = b+y+x;\n      b = b+1;\n      w = w+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (w at loop-step start < r at loop-step start). Changed: b: b at loop-step start -> b at loop-step start + 1; v: v at loop-step start -> b at loop-step start + y at loop-step start + x at loop-step start; w: w at loop-step start -> w at loop-step start + 1. Unchanged: k keeps k at loop-step start; n keeps n at loop-step start; r keeps r at loop-step start; x keeps x at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'n', 'r', 'v', 'w', 'x', 'y']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n){\n  int r, w, b, y, x, v;\n\n  r=(k%12)+11;\n  w=0;\n  b=-2;\n  y=4;\n  x=k;\n  v=w;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant w <= r;\n  loop invariant b == w - 2;\n  loop invariant x == k;\n  loop invariant y == 4;\n  loop invariant r == (k % 12) + 11;\n  loop invariant k == \\at(k, Pre);\n  loop invariant w >= 0;\n  loop invariant r == (\\at(k, Pre) % 12) + 11;\n  loop invariant n == \\at(n, Pre);\n  loop invariant b == -2 + w;\n  loop invariant 0 <= w;\n  loop invariant x == \\at(k, Pre);\n  loop invariant r == \\at(k, Pre) % 12 + 11;\n  loop invariant (w == 0 ==> v == 0) && (w > 0 ==> v == b - 1 + y + x);\n  loop invariant (w == 0) ==> (v == 0);\n  loop invariant (w != 0) ==> (v == w + k + 1);\n  loop invariant (w==0 ==> v==0) && (w>0 ==> v == b + y + x - 1);\n  loop assigns v, b, w;\n*/\nwhile (w<r) {\n      v = b+y+x;\n      b = b+1;\n      w = w+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b){\n  int e, l, v, j;\n\n  e=a;\n  l=0;\n  v=b;\n  j=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (l<e) {\n      j = j+j;\n      l = l+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (l<e) {\n      j = j+j;\n      l = l+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'e', 'j', 'l']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b){\n  int e, l, v, j;\n\n  e=a;\n  l=0;\n  v=b;\n  j=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l >= 0;\n\n  loop invariant a == \\at(a, Pre) && 0 <= l;\n  loop invariant (0 <= l && e > 0) ==> (l <= e) && (j * a >= 0);\n  loop invariant e == a;\n  loop invariant 0 <= l;\n  loop invariant e == \\at(a, Pre);\n  loop invariant a == \\at(a, Pre);\n  loop assigns l, j;\n*/\nwhile (l<e) {\n      j = j+j;\n      l = l+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int l, r, i;\n\n  l=10;\n  r=l;\n  i=r;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (r>0) {\n      if (i+6<l) {\n          i = i+i;\n      }\n      i = i+3;\n      r = r-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (i == 10) && (r == 10) && (l == 10) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (r>0) {\n      if (i+6<l) {\n          i = i+i;\n      }\n      i = i+3;\n      r = r-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start + 6 < l at loop-step start; r at loop-step start > 0; r at loop-step start > 0). Changed: i: i at loop-step start -> i at loop-step start + 3; r: r at loop-step start -> r at loop-step start - 1. Unchanged: k keeps k at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'r']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int l, r, i;\n\n  l=10;\n  r=l;\n  i=r;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i == 40 - 3*r && 0 <= r && r <= 10;\n  loop invariant l == 10 && k == \\at(k, Pre) && m == \\at(m, Pre);\n  loop invariant r >= 0 && r <= 10;\n  loop invariant l == 10;\n  loop invariant k == \\at(k, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant r >= 0;\n  loop invariant i == 40 - 3*r;\n  loop invariant i + 3*r == 40;\n  loop invariant i <= 40;\n  loop assigns i, r;\n*/\nwhile (r>0) {\n      if (i+6<l) {\n          i = i+i;\n      }\n      i = i+3;\n      r = r-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int t, u, v;\n\n  t=(m%14)+15;\n  u=0;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<t) {\n      v = v+1;\n      v = v+v;\n      u = u+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<t) {\n      v = v+1;\n      v = v+v;\n      u = u+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'm', 't', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int t, u, v;\n\n  t=(m%14)+15;\n  u=0;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= u && u <= t;\n  loop invariant t == (m % 14) + 15;\n  loop invariant v >= 2*u;\n  loop invariant 0 <= u;\n  loop invariant u <= t;\n  loop invariant v >= u + 2;\n  loop invariant v % 2 == 0;\n  loop invariant v + 2 == (1 << (u + 2));\n  loop invariant m == \\at(m, Pre) && k == \\at(k, Pre);\n  loop invariant v >= 2*u + 2;\n  loop invariant k == \\at(k, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop assigns v, u;\n*/\nwhile (u<t) {\n      v = v+1;\n      v = v+v;\n      u = u+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m){\n  int w, k, z;\n\n  w=17;\n  k=0;\n  z=w;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k<w) {\n      z = z+z;\n      z = z-z;\n      k = k+5;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (z == 17) && (k == 0) && (w == 17) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (k<w) {\n      z = z+z;\n      z = z-z;\n      k = k+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start < w at loop-step start). Changed: k: k at loop-step start -> k at loop-step start + 5; z: z at loop-step start -> z at loop-step start + z at loop-step start - (z at loop-step start + z at loop-step start. Unchanged: a keeps a at loop-step start; m keeps m at loop-step start; w keeps w at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'k', 'm', 'w', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m){\n  int w, k, z;\n\n  w=17;\n  k=0;\n  z=w;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant (k == 0 ==> z == w) && (k > 0 ==> z == 0) && a == \\at(a, Pre) && m == \\at(m, Pre) && w == 17;\n  loop invariant (k % 5 == 0) && (a == \\at(a, Pre)) && (m == \\at(m, Pre));\n  loop invariant (k == 0) ==> (z == w);\n  loop invariant (k != 0) ==> (z == 0);\n  loop invariant k % 5 == 0;\n  loop invariant 0 <= k;\n  loop invariant k <= w + 4;\n  loop invariant z == 0 || (k == 0 && z == w);\n  loop invariant a == \\at(a, Pre) && m == \\at(m, Pre);\n  loop invariant w == 17;\n  loop invariant a == \\at(a, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant z == 0 || z == w;\n  loop assigns z, k;\n*/\nwhile (k<w) {\n      z = z+z;\n      z = z-z;\n      k = k+5;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p){\n  int f, t, g;\n\n  f=71;\n  t=f;\n  g=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t>0) {\n      g = g+t;\n      t = t-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (g == \\at(p, Pre)) && (t == 71) && (f == 71) && (p == \\at(p, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (t>0) {\n      g = g+t;\n      t = t-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start > 0). Changed: g: g at loop-step start -> g at loop-step start + t at loop-step start; t: t at loop-step start -> t at loop-step start - 1. Unchanged: f keeps f at loop-step start; n keeps n at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['f', 'g', 'n', 'p', 't']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p){\n  int f, t, g;\n\n  f=71;\n  t=f;\n  g=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant g == p + (f - t) * (f + t + 1) / 2;\n  loop invariant 0 <= t && t <= f;\n  loop invariant g >= p;\n  loop invariant f == 71;\n  loop invariant (0 <= t) && (t <= 71);\n  loop invariant 2*(g - p) == 5112 - t*t - t;\n  loop invariant p == \\at(p, Pre) && n == \\at(n, Pre);\n  loop invariant g == \\at(p, Pre) + 2556 - (t * (t + 1)) / 2;\n  loop invariant 0 <= t && t <= 71;\n  loop invariant t >= 0;\n  loop invariant t <= f;\n  loop invariant g + t*(t+1)/2 == \\at(p, Pre) + f*(f+1)/2;\n  loop invariant g == p + 2556 - t*(t+1)/2;\n  loop invariant t <= 71;\n  loop assigns g, t;\n*/\nwhile (t>0) {\n      g = g+t;\n      t = t-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n){\n  int j, a, e, f;\n\n  j=(b%11)+11;\n  a=j;\n  e=a;\n  f=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (a>0) {\n      e = e+1;\n      f = f-1;\n      a = a-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (f == \\at(n, Pre)) && (e == \\at(b, Pre) % 11 + 11) && (a == \\at(b, Pre) % 11 + 11) && (j == \\at(b, Pre) % 11 + 11) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (a>0) {\n      e = e+1;\n      f = f-1;\n      a = a-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (a at loop-step start > 0). Changed: a: a at loop-step start -> a at loop-step start - 1; e: e at loop-step start -> e at loop-step start + 1; f: f at loop-step start -> f at loop-step start - 1. Unchanged: b keeps b at loop-step start; j keeps j at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'e', 'f', 'j', 'n']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n){\n  int j, a, e, f;\n\n  j=(b%11)+11;\n  a=j;\n  e=a;\n  f=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant e + f == ((b % 11) + 11) + n;\n  loop invariant a >= 0 && a <= ((b % 11) + 11) && j == ((b % 11) + 11) && f <= n;\n  loop invariant a >= 0;\n  loop invariant a <= ((b % 11) + 11);\n  loop invariant b == \\at(b, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant e >= a;\n  loop invariant e + a == 2 * j;\n  loop invariant f - a == n - j;\n  loop invariant a <= j;\n  loop invariant j == ((\\at(b, Pre)) % 11) + 11;\n  loop invariant e == 2*j - a;\n  loop invariant f == n - j + a;\n  loop invariant a + e == 2 * j;\n  loop invariant j == (b % 11) + 11;\n  loop assigns a, e, f;\n*/\nwhile (a>0) {\n      e = e+1;\n      f = f-1;\n      a = a-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p){\n  int n, j, k, r, i, a;\n\n  n=30;\n  j=0;\n  k=p;\n  r=0;\n  i=3;\n  a=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j<n) {\n      r = r+i;\n      i = i+k;\n      j = j+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (a == 2) && (i == 3) && (r == 0) && (k == \\at(p, Pre)) && (j == 0) && (n == 30) && (p == \\at(p, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (j<n) {\n      r = r+i;\n      i = i+k;\n      j = j+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start < n at loop-step start). Changed: i: i at loop-step start -> i at loop-step start + k at loop-step start; j: j at loop-step start -> j at loop-step start + 1; r: r at loop-step start -> r at loop-step start + i at loop-step start. Unchanged: a keeps a at loop-step start; k keeps k at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'j', 'k', 'm', 'n', 'p', 'r']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p){\n  int n, j, k, r, i, a;\n\n  n=30;\n  j=0;\n  k=p;\n  r=0;\n  i=3;\n  a=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant j >= 0;\n  loop invariant j <= n;\n  loop invariant i == 3 + j * k;\n  loop invariant r == 3 * j + k * j * (j - 1) / 2;\n  loop invariant k == p;\n  loop invariant n == 30;\n  loop invariant k == \\at(p, Pre);\n  loop invariant 0 <= j;\n\n  loop assigns r, i, j;\n*/\nwhile (j<n) {\n      r = r+i;\n      i = i+k;\n      j = j+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int q){\n  int z, w, v;\n\n  z=44;\n  w=0;\n  v=w;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (w<z) {\n      v = v-v;\n      w = w+5;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 0) && (w == 0) && (z == 44) && (q == \\at(q, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (w<z) {\n      v = v-v;\n      w = w+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (w at loop-step start < z at loop-step start). Changed: v: v at loop-step start -> v at loop-step start - v at loop-step start; w: w at loop-step start -> w at loop-step start + 5. Unchanged: k keeps k at loop-step start; q keeps q at loop-step start; z keeps z at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'q', 'v', 'w', 'z']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int q){\n  int z, w, v;\n\n  z=44;\n  w=0;\n  v=w;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant z == 44;\n  loop invariant v == 0;\n  loop invariant w % 5 == 0;\n  loop invariant k == \\at(k, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant w >= 0;\n  loop invariant 0 <= w;\n  loop invariant w <= z + 4;\n\n  loop assigns v, w;\n*/\nwhile (w<z) {\n      v = v-v;\n      w = w+5;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int q){\n  int e, u, j, v, f;\n\n  e=(m%12)+16;\n  u=0;\n  j=-8;\n  v=m;\n  f=e;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<e) {\n      j = j+v+f;\n      u = u+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<e) {\n      j = j+v+f;\n      u = u+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'f', 'j', 'm', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int q){\n  int e, u, j, v, f;\n\n  e=(m%12)+16;\n  u=0;\n  j=-8;\n  v=m;\n  f=e;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant e == (m % 12) + 16;\n  loop invariant v == m;\n  loop invariant f == e;\n  loop invariant j == -8 + u*(v+f);\n  loop invariant 0 <= u && u <= e;\n  loop invariant m == \\at(m, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v == \\at(m, Pre);\n  loop invariant (0 <= u) && (u <= e);\n  loop assigns j, u;\n*/\nwhile (u<e) {\n      j = j+v+f;\n      u = u+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int q){\n  int n, t, f;\n\n  n=(q%38)+9;\n  t=n;\n  f=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t>0) {\n      f = q+5;\n      t = t-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (f == \\at(q, Pre) % 38 + 9) && (t == \\at(q, Pre) % 38 + 9) && (n == \\at(q, Pre) % 38 + 9) && (q == \\at(q, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (t>0) {\n      f = q+5;\n      t = t-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start > 0). Changed: f: f at loop-step start -> q at loop-step start + 5; t: t at loop-step start -> t at loop-step start - 1. Unchanged: m keeps m at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['f', 'm', 'n', 'q', 't']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int q){\n  int n, t, f;\n\n  n=(q%38)+9;\n  t=n;\n  f=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant n == (q % 38) + 9;\n  loop invariant m == \\at(m, Pre);\n  loop invariant q == \\at(q, Pre);\n\n  loop invariant (t > 0) ==> (f == q + 5 || f == n);\n  loop invariant n == (\\at(q, Pre) % 38) + 9;\n\n  loop invariant (t == n && f == n) || (t < n && f == q + 5);\n  loop invariant n == ((\\at(q, Pre) % 38) + 9);\n  loop invariant n == \\at(q, Pre) % 38 + 9;\n\n  loop invariant (t < n) ==> f == q + 5;\n  loop invariant (t == n) ==> f == n;\n  loop assigns f, t;\n*/\nwhile (t>0) {\n      f = q+5;\n      t = t-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int q){\n  int i, v, a, t, y, b;\n\n  i=(k%15)+20;\n  v=0;\n  a=v;\n  t=2;\n  y=k;\n  b=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<i) {\n      t = t+y;\n      v = v+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (b == \\at(q, Pre)) && (y == \\at(k, Pre)) && (t == 2) && (a == 0) && (v == 0) && (i == \\at(k, Pre) % 15 + 20) && (q == \\at(q, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (v<i) {\n      t = t+y;\n      v = v+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start < i at loop-step start). Changed: t: t at loop-step start -> t at loop-step start + y at loop-step start; v: v at loop-step start -> v at loop-step start + 1. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; i keeps i at loop-step start; k keeps k at loop-step start; q keeps q at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'q', 't', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int q){\n  int i, v, a, t, y, b;\n\n  i=(k%15)+20;\n  v=0;\n  a=v;\n  t=2;\n  y=k;\n  b=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant t == 2 + v * y;\n  loop invariant 0 <= v && v <= i;\n  loop invariant y == \\at(k, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant i == (\\at(k, Pre) % 15) + 20;\n  loop invariant v <= i;\n  loop invariant y == k;\n  loop invariant (0 <= v) && (v <= i);\n  loop invariant i == (k % 15) + 20;\n  loop assigns t, v;\n*/\nwhile (v<i) {\n      t = t+y;\n      v = v+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int s, i, g, v, k;\n\n  s=14;\n  i=s;\n  g=q;\n  v=i;\n  k=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      g = g+5;\n      v = v+g;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (k == 0) && (v == 14) && (g == \\at(q, Pre)) && (i == 14) && (s == 14) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      g = g+5;\n      v = v+g;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start > 0). Changed: g: g at loop-step start -> g at loop-step start + 5; i: i at loop-step start -> i at loop-step start - 1; v: v at loop-step start -> v at loop-step start + (g at loop-step start + 5. Unchanged: k keeps k at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start; s keeps s at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['g', 'i', 'n', 'q', 's', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int s, i, g, v, k;\n\n  s=14;\n  i=s;\n  g=q;\n  v=i;\n  k=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant g + 5*i == \\at(q, Pre) + 70;\n  loop invariant i >= 0;\n  loop invariant i <= s;\n  loop invariant v == s + (s - i) * \\at(q, Pre) + 5 * (s - i) * (s - i + 1) / 2;\n  loop invariant g <= \\at(q, Pre) + 5 * s;\n  loop invariant i <= 14;\n  loop invariant g == q + 5*(14 - i);\n  loop invariant n == \\at(n, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant 0 <= i;\n  loop invariant g == \\at(q, Pre) + 5 * (s - i);\n  loop invariant s == 14;\n  loop invariant v == s + (s - i)*\\at(q, Pre) + 5*((s - i)*(s - i + 1))/2;\n  loop invariant g == q + 5*(s - i);\n  loop invariant v == s + (s - i) * q + 5 * ((s - i) * (s - i + 1) / 2);\n  loop assigns g, v, i;\n*/\nwhile (i>0) {\n      g = g+5;\n      v = v+g;\n      i = i-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int p){\n  int c, m, j, b, a;\n\n  c=k;\n  m=0;\n  j=k;\n  b=p;\n  a=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (m<c) {\n      b = b+a;\n      m = m+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (a == \\at(p, Pre)) && (b == \\at(p, Pre)) && (j == \\at(k, Pre)) && (m == 0) && (c == \\at(k, Pre)) && (p == \\at(p, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (m<c) {\n      b = b+a;\n      m = m+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (m at loop-step start < c at loop-step start). Changed: b: b at loop-step start -> b at loop-step start + a at loop-step start; m: m at loop-step start -> m at loop-step start + 1. Unchanged: a keeps a at loop-step start; c keeps c at loop-step start; j keeps j at loop-step start; k keeps k at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'k', 'm', 'p']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int p){\n  int c, m, j, b, a;\n\n  c=k;\n  m=0;\n  j=k;\n  b=p;\n  a=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant a == p;\n  loop invariant b == p + a * m;\n  loop invariant c == \\at(k, Pre);\n\n  loop invariant p == \\at(p, Pre);\n  loop invariant a == \\at(p, Pre);\n  loop invariant b == \\at(p, Pre) + m * a;\n  loop invariant m >= 0;\n  loop invariant (c >= 0) ==> m <= c;\n  loop invariant c == k;\n  loop invariant 0 <= m;\n  loop invariant b == a * m + \\at(p, Pre);\n\n  loop invariant k == \\at(k, Pre);\n  loop invariant b == p*(m+1);\n  loop assigns b, m;\n*/\nwhile (m<c) {\n      b = b+a;\n      m = m+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k){\n  int r, g, d;\n\n  r=(k%14)+14;\n  g=0;\n  d=g;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (g<r) {\n      d = d+d;\n      d = d+1;\n      g = g+4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (d == 0) && (g == 0) && (r == \\at(k, Pre) % 14 + 14) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (g<r) {\n      d = d+d;\n      d = d+1;\n      g = g+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (g at loop-step start < r at loop-step start). Changed: d: d at loop-step start -> d at loop-step start + d at loop-step start + 1; g: g at loop-step start -> g at loop-step start + 4. Unchanged: a keeps a at loop-step start; k keeps k at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'd', 'g', 'k', 'r']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k){\n  int r, g, d;\n\n  r=(k%14)+14;\n  g=0;\n  d=g;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant g % 4 == 0;\n  loop invariant g >= 0;\n  loop invariant d == 0 || d % 2 == 1;\n  loop invariant d >= g/4;\n  loop invariant r == (k % 14) + 14;\n  loop invariant r == ((\\at(k,Pre) % 14) + 14);\n  loop invariant k == \\at(k,Pre);\n  loop invariant a == \\at(a,Pre);\n\n  loop invariant r == \\at(k, Pre) % 14 + 14;\n\n\n  loop invariant (d == 0) || (d % 2 == 1);\n  loop invariant r == (\\at(k, Pre) % 14) + 14;\n  loop invariant d >= 0;\n  loop invariant g <= r + 3;\n  loop assigns d, g;\n*/\nwhile (g<r) {\n      d = d+d;\n      d = d+1;\n      g = g+4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b){\n  int i, k, l;\n\n  i=(a%27)+13;\n  k=0;\n  l=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k<i) {\n      l = l+k;\n      l = a-6;\n      k = k+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (l == -8) && (k == 0) && (i == \\at(a, Pre) % 27 + 13) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (k<i) {\n      l = l+k;\n      l = a-6;\n      k = k+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start < i at loop-step start). Changed: k: k at loop-step start -> k at loop-step start + 1; l: l at loop-step start -> a at loop-step start - 6. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; i keeps i at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b){\n  int i, k, l;\n\n  i=(a%27)+13;\n  k=0;\n  l=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= k;\n  loop invariant (k == 0 && l == -8) || l == a - 6;\n  loop invariant k == 0 || k <= i;\n  loop invariant a == \\at(a, Pre);\n  loop invariant b == \\at(b, Pre);\n  loop invariant i == (\\at(a, Pre) % 27) + 13;\n  loop invariant ((l == -8) || (l == a - 6)) && (0 <= k);\n\n  loop invariant (k==0 ==> l == -8) && (k>0 ==> l == a-6);\n  loop invariant i == \\at(a, Pre) % 27 + 13;\n  loop invariant i == (a % 27) + 13;\n  loop invariant (((k == 0) ==> (l == -8)) && ((k > 0) ==> (l == a - 6)) && (a == \\at(a, Pre)) && (b == \\at(b, Pre)) && (0 <= k));\n  loop invariant k >= 0;\n  loop invariant (k == 0 ==> l == -8) && (k >= 1 ==> l == a - 6);\n  loop assigns k, l;\n*/\nwhile (k<i) {\n      l = l+k;\n      l = a-6;\n      k = k+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int q){\n  int i, e, o;\n\n  i=(q%17)+16;\n  e=0;\n  o=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (e<i) {\n      o = o+(-8);\n      e = e+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (o == \\at(m, Pre)) && (e == 0) && (i == \\at(q, Pre) % 17 + 16) && (q == \\at(q, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (e<i) {\n      o = o+(-8);\n      e = e+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (e at loop-step start < i at loop-step start). Changed: e: e at loop-step start -> e at loop-step start + 1; o: o at loop-step start -> o at loop-step start + -8. Unchanged: i keeps i at loop-step start; m keeps m at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'i', 'm', 'o', 'q']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int q){\n  int i, e, o;\n\n  i=(q%17)+16;\n  e=0;\n  o=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant o == \\at(m, Pre) - 8*e;\n  loop invariant 0 <= e && e <= i;\n  loop invariant i == \\at(q, Pre) % 17 + 16;\n  loop invariant m == \\at(m, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant o == m - 8*e;\n  loop invariant i == (\\at(q, Pre) % 17) + 16;\n  loop invariant e <= i;\n  loop invariant i == (q % 17) + 16;\n\n  loop assigns o, e;\n*/\nwhile (e<i) {\n      o = o+(-8);\n      e = e+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int r, c, w;\n\n  r=32;\n  c=0;\n  w=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (c<r) {\n      if (w+7<r) {\n          w = w-w;\n      }\n      w = w+4;\n      c = c+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (w == 3) && (c == 0) && (r == 32) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (c<r) {\n      if (w+7<r) {\n          w = w-w;\n      }\n      w = w+4;\n      c = c+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (w at loop-step start + 7 < r at loop-step start; c at loop-step start < r at loop-step start; c at loop-step start < r at loop-step start). Changed: c: c at loop-step start -> c at loop-step start + 1; w: w at loop-step start -> w at loop-step start + 4. Unchanged: n keeps n at loop-step start; q keeps q at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'n', 'q', 'r', 'w']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int r, c, w;\n\n  r=32;\n  c=0;\n  w=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= c && c <= r;\n  loop invariant (c==0 && w==3) || (c>=1 && w==4);\n  loop invariant 3 <= w && w <= 4;\n  loop invariant n == \\at(n, Pre) && q == \\at(q, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant r == 32;\n  loop invariant w == 3 || w == 4;\n  loop invariant 0 <= w && w <= 4*c + 3;\n  loop invariant c <= r;\n  loop invariant (c == 0) ==> (w == 3);\n  loop invariant (c == 0 ==> w == 3) && (c >= 1 ==> w == 4);\n  loop assigns c, w;\n*/\nwhile (c<r) {\n      if (w+7<r) {\n          w = w-w;\n      }\n      w = w+4;\n      c = c+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int p){\n  int l, j, v, f, z;\n\n  l=30;\n  j=l;\n  v=p;\n  f=1;\n  z=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j>0) {\n      v = v+f+z;\n      v = v+1;\n      j = j-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (z == -2) && (f == 1) && (v == \\at(p, Pre)) && (j == 30) && (l == 30) && (p == \\at(p, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (j>0) {\n      v = v+f+z;\n      v = v+1;\n      j = j-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start > 0). Changed: j: j at loop-step start -> j at loop-step start - 1; v: v at loop-step start -> v at loop-step start + f at loop-step start + z at loop-step start + 1. Unchanged: b keeps b at loop-step start; f keeps f at loop-step start; l keeps l at loop-step start; p keeps p at loop-step start; z keeps z at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'f', 'j', 'l', 'p', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int p){\n  int l, j, v, f, z;\n\n  l=30;\n  j=l;\n  v=p;\n  f=1;\n  z=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == \\at(p, Pre);\n  loop invariant 0 <= j && j <= l;\n  loop invariant l == 30;\n  loop invariant f == 1 && z == -2;\n  loop invariant p == \\at(p, Pre) && b == \\at(b, Pre);\n  loop invariant v == p;\n  loop invariant j >= 0;\n  loop invariant j <= 30;\n  loop invariant f == 1;\n  loop invariant z == -2;\n  loop invariant j <= l;\n  loop invariant p == \\at(p, Pre);\n  loop invariant v == \\at(p, Pre) + (l - j) * (f + z + 1);\n  loop invariant b == \\at(b, Pre);\n  loop assigns v, j;\n*/\nwhile (j>0) {\n      v = v+f+z;\n      v = v+1;\n      j = j-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n){\n  int y, i, c, v, p;\n\n  y=40;\n  i=0;\n  c=a;\n  v=a;\n  p=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<y) {\n      c = c+v+p;\n      c = c+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (p == -8) && (v == \\at(a, Pre)) && (c == \\at(a, Pre)) && (i == 0) && (y == 40) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<y) {\n      c = c+v+p;\n      c = c+1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start < y at loop-step start). Changed: c: c at loop-step start -> c at loop-step start + v at loop-step start + p at loop-step start + 1; i: i at loop-step start -> i at loop-step start + 1. Unchanged: a keeps a at loop-step start; n keeps n at loop-step start; p keeps p at loop-step start; v keeps v at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'i', 'n', 'p', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n){\n  int y, i, c, v, p;\n\n  y=40;\n  i=0;\n  c=a;\n  v=a;\n  p=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= i && i <= y;\n  loop invariant a == \\at(a, Pre);\n  loop invariant v == \\at(a, Pre);\n  loop invariant p == -8;\n  loop invariant c == \\at(a, Pre) + i*(v + p + 1);\n  loop invariant n == \\at(n, Pre);\n  loop invariant c == a + i*(a - 7);\n  loop invariant 0 <= i;\n  loop invariant i <= y;\n  loop assigns c, i;\n*/\nwhile (i<y) {\n      c = c+v+p;\n      c = c+1;\n      i = i+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int l, j, i, k, b;\n\n  l=m+19;\n  j=0;\n  i=m;\n  k=-2;\n  b=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j<l) {\n      i = i+k+b;\n      i = i+1;\n      j = j+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (b == 5) && (k == -2) && (i == \\at(m, Pre)) && (j == 0) && (l == \\at(m, Pre) + 19) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (j<l) {\n      i = i+k+b;\n      i = i+1;\n      j = j+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start < l at loop-step start). Changed: i: i at loop-step start -> i at loop-step start + k at loop-step start + b at loop-step start + 1; j: j at loop-step start -> j at loop-step start + 1. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'j', 'k', 'l', 'm', 'n']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int l, j, i, k, b;\n\n  l=m+19;\n  j=0;\n  i=m;\n  k=-2;\n  b=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i == m + (k + b + 1) * j;\n  loop invariant l == m + 19;\n  loop invariant m == \\at(m, Pre);\n\n  loop invariant n == \\at(n, Pre);\n  loop invariant i - 4*j == \\at(m,Pre) && i == \\at(m,Pre) + 4*j;\n  loop invariant j >= 0 && (l >= 0) ==> (j <= l) && l == m + 19;\n  loop invariant i == m + 4*j;\n  loop invariant k == -2;\n  loop invariant b == 5;\n  loop invariant j >= 0;\n  loop invariant i == \\at(m, Pre) + j*(k + b + 1);\n\n  loop invariant l == \\at(m, Pre) + 19;\n  loop assigns i, j;\n*/\nwhile (j<l) {\n      i = i+k+b;\n      i = i+1;\n      j = j+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n){\n  int i, l, k;\n\n  i=n;\n  l=0;\n  k=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (l<i) {\n      k = k-k;\n      l = l+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (l<i) {\n      k = k-k;\n      l = l+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n){\n  int i, l, k;\n\n  i=n;\n  l=0;\n  k=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (l >= 0);\n\n  loop invariant (i == \\at(n, Pre));\n  loop invariant ((k == 2) || (k == 0));\n  loop invariant i == n;\n\n  loop invariant l >= 0;\n  loop invariant i == \\at(n, Pre);\n  loop invariant (i >= 0) ==> l <= i;\n  loop invariant (l==0 ==> k==2) && (l>=1 ==> k==0);\n\n  loop invariant (l == 0 ==> k == 2) && (l > 0 ==> k == 0);\n  loop invariant a == \\at(a, Pre);\n  loop assigns k, l;\n*/\nwhile (l<i) {\n      k = k-k;\n      l = l+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k){\n  int a, t, x, v, l;\n\n  a=k+4;\n  t=0;\n  x=b;\n  v=b;\n  l=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t<a) {\n      x = x+1;\n      v = v-1;\n      t = t+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (l == -1) && (v == \\at(b, Pre)) && (x == \\at(b, Pre)) && (t == 0) && (a == \\at(k, Pre) + 4) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (t<a) {\n      x = x+1;\n      v = v-1;\n      t = t+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start < a at loop-step start). Changed: t: t at loop-step start -> t at loop-step start + 1; v: v at loop-step start -> v at loop-step start - 1; x: x at loop-step start -> x at loop-step start + 1. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; k keeps k at loop-step start; l keeps l at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'k', 't', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k){\n  int a, t, x, v, l;\n\n  a=k+4;\n  t=0;\n  x=b;\n  v=b;\n  l=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant b == \\at(b, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant a == k + 4;\n\n  loop invariant x == b + t;\n  loop invariant v == b - t;\n  loop invariant t >= 0;\n  loop invariant x == \\at(b, Pre) + t;\n  loop invariant v == \\at(b, Pre) - t;\n  loop invariant a == \\at(k, Pre) + 4;\n  loop invariant 0 <= t;\n  loop invariant a < 0 || t <= a;\n  loop assigns x, v, t;\n*/\nwhile (t<a) {\n      x = x+1;\n      v = v-1;\n      t = t+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int e, y, v;\n\n  e=k+24;\n  y=0;\n  v=e;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (y<e) {\n      v = v-v;\n      if (y+1<=v+e) {\n          v = v+1;\n      }\n      y = y+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == \\at(k, Pre) + 24) && (y == 0) && (e == \\at(k, Pre) + 24) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (y<e) {\n      v = v-v;\n      if (y+1<=v+e) {\n          v = v+1;\n      }\n      y = y+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (y at loop-step start + 1 <= v at loop-step start - v at loop-step start + e at loop-step start; y at loop-step start < e at loop-step start). Changed: v: v at loop-step start -> v at loop-step start - v at loop-step start + 1; y: y at loop-step start -> y at loop-step start + 1. Unchanged: e keeps e at loop-step start; k keeps k at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'k', 'm', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int e, y, v;\n\n  e=k+24;\n  y=0;\n  v=e;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= y;\n  loop invariant y <= e || e < 0;\n  loop invariant v <= e;\n  loop invariant k == \\at(k, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant e == k + 24;\n  loop invariant (y == 0) ==> (v == e);\n  loop invariant (y > 0) ==> (v == 1);\n\n\n  loop invariant y >= 0;\n  loop invariant (((y == 0) ==> (v == e)) && ((y != 0) ==> (v == 1)));\n  loop invariant (k == \\at(k, Pre)) && (m == \\at(m, Pre));\n  loop assigns v, y;\n*/\nwhile (y<e) {\n      v = v-v;\n      if (y+1<=v+e) {\n          v = v+1;\n      }\n      y = y+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int x, l, j, v;\n\n  x=n-9;\n  l=0;\n  j=n;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (l<x) {\n      v = v+v;\n      v = v+j;\n      l = l+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (l<x) {\n      v = v+v;\n      v = v+j;\n      l = l+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['j', 'l', 'm', 'n', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int x, l, j, v;\n\n  x=n-9;\n  l=0;\n  j=n;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant x == \\at(n, Pre) - 9;\n  loop invariant j == \\at(n, Pre);\n\n  loop invariant (l == 0) ==> v == \\at(m, Pre);\n\n  loop invariant j == n;\n  loop invariant x == n - 9;\n\n  loop invariant (l == 0) ==> (v == m);\n  loop invariant 0 <= l;\n  loop invariant (x >= 0) ==> (l <= x);\n\n  loop assigns v, l;\n*/\nwhile (l<x) {\n      v = v+v;\n      v = v+j;\n      l = l+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m){\n  int l, u, v;\n\n  l=m+18;\n  u=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<l) {\n      v = v+1;\n      v = v+v;\n      u = u+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<l) {\n      v = v+1;\n      v = v+v;\n      u = u+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'l', 'm', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m){\n  int l, u, v;\n\n  l=m+18;\n  u=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == \\at(m, Pre);\n  loop invariant a == \\at(a, Pre);\n  loop invariant l == m + 18;\n\n  loop invariant v >= 0;\n  loop invariant v >= 2*u;\n  loop invariant u >= 0;\n  loop invariant v >= 2*u - 2;\n  loop invariant v % 2 == 0;\n  loop invariant (u <= l) || (l < 0);\n  loop invariant l == \\at(m, Pre) + 18;\n\n  loop assigns u, v;\n*/\nwhile (u<l) {\n      v = v+1;\n      v = v+v;\n      u = u+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k){\n  int m, t, i;\n\n  m=b+3;\n  t=0;\n  i=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t<m) {\n      i = i+i;\n      if ((t%9)==0) {\n          i = i+2;\n      }\n      t = t+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (i == -2) && (t == 0) && (m == \\at(b, Pre) + 3) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (t<m) {\n      i = i+i;\n      if ((t%9)==0) {\n          i = i+2;\n      }\n      t = t+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start % 9 != 0; t at loop-step start < m at loop-step start; t at loop-step start < m at loop-step start). Changed: i: i at loop-step start -> i at loop-step start + i at loop-step start + 2; t: t at loop-step start -> t at loop-step start + 1. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'm', 't']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k){\n  int m, t, i;\n\n  m=b+3;\n  t=0;\n  i=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == b + 3;\n  loop invariant b == \\at(b, Pre);\n  loop invariant k == \\at(k, Pre);\n\n  loop invariant i % 2 == 0;\n  loop invariant m == \\at(b, Pre) + 3;\n\n  loop invariant (t <= m) || (m <= 0);\n  loop invariant t >= 0;\n  loop assigns i, t;\n*/\nwhile (t<m) {\n      i = i+i;\n      if ((t%9)==0) {\n          i = i+2;\n      }\n      t = t+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int o, x, v, w, u;\n\n  o=m;\n  x=0;\n  v=8;\n  w=k;\n  u=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (x<o) {\n      v = v+w+u;\n      x = x+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (u == -8) && (w == \\at(k, Pre)) && (v == 8) && (x == 0) && (o == \\at(m, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (x<o) {\n      v = v+w+u;\n      x = x+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (x at loop-step start < o at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + w at loop-step start + u at loop-step start; x: x at loop-step start -> x at loop-step start + 1. Unchanged: k keeps k at loop-step start; m keeps m at loop-step start; o keeps o at loop-step start; u keeps u at loop-step start; w keeps w at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'm', 'o', 'u', 'v', 'w', 'x']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int o, x, v, w, u;\n\n  o=m;\n  x=0;\n  v=8;\n  w=k;\n  u=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == 8 + x*(w+u);\n  loop invariant o == m;\n  loop invariant w == k;\n  loop invariant u == -8;\n  loop invariant 0 <= x;\n  loop invariant x <= o || o <= 0;\n  loop invariant w == \\at(k, Pre);\n  loop invariant o == \\at(m, Pre);\n\n  loop invariant v == 8 + x*(k - 8);\n\n  loop invariant k == \\at(k, Pre);\n  loop invariant m == \\at(m, Pre);\n\n  loop assigns v, x;\n*/\nwhile (x<o) {\n      v = v+w+u;\n      x = x+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b){\n  int v, t, y;\n\n  v=62;\n  t=0;\n  y=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t<v) {\n      y = y+t;\n      if (t+4<=a+v) {\n          y = y+1;\n      }\n      t = t+4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (y == \\at(b, Pre)) && (t == 0) && (v == 62) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (t<v) {\n      y = y+t;\n      if (t+4<=a+v) {\n          y = y+1;\n      }\n      t = t+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start + 4 > a at loop-step start + v at loop-step start; t at loop-step start < v at loop-step start; t at loop-step start < v at loop-step start). Changed: t: t at loop-step start -> t at loop-step start + 4; y: y at loop-step start -> y at loop-step start + t at loop-step start + 1. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 't', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b){\n  int v, t, y;\n\n  v=62;\n  t=0;\n  y=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == 62 && t % 4 == 0 && 0 <= t;\n  loop invariant y >= b;\n  loop invariant t % 4 == 0;\n  loop invariant t >= 0;\n  loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && v == 62;\n  loop invariant (0 <= t) && (t <= 64);\n  loop invariant a == \\at(a, Pre);\n  loop invariant b == \\at(b, Pre);\n  loop invariant 0 <= t && v == 62 && y >= \\at(b, Pre);\n  loop assigns y, t;\n*/\nwhile (t<v) {\n      y = y+t;\n      if (t+4<=a+v) {\n          y = y+1;\n      }\n      t = t+4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int p){\n  int h, g, s;\n\n  h=p-7;\n  g=0;\n  s=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (g<h) {\n      if (g+6<=g+h) {\n          s = s+s;\n      }\n      g = g+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == -3) && (g == 0) && (h == \\at(p, Pre) - 7) && (p == \\at(p, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (g<h) {\n      if (g+6<=g+h) {\n          s = s+s;\n      }\n      g = g+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (g at loop-step start + 6 > g at loop-step start + h at loop-step start; g at loop-step start < h at loop-step start; g at loop-step start < h at loop-step start). Changed: g: g at loop-step start -> g at loop-step start + 1; s: s at loop-step start -> s at loop-step start + s at loop-step start. Unchanged: h keeps h at loop-step start; k keeps k at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['g', 'h', 'k', 'p', 's']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int p){\n  int h, g, s;\n\n  h=p-7;\n  g=0;\n  s=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant h == \\at(p, Pre) - 7;\n  loop invariant p == \\at(p, Pre) && k == \\at(k, Pre);\n\n  loop invariant h < 6 ==> s == -3;\n  loop invariant p == \\at(p, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant g >= 0;\n  loop invariant (h >= 0) ==> g <= h;\n  loop invariant s % 3 == 0 && s < 0;\n  loop invariant (h < 6) ==> s == -3;\n  loop invariant h == p - 7;\n  loop invariant s <= -3;\n  loop invariant s % 3 == 0;\n  loop invariant (h < 6) ==> (s == -3);\n  loop assigns g, s;\n*/\nwhile (g<h) {\n      if (g+6<=g+h) {\n          s = s+s;\n      }\n      g = g+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int t, l, b;\n\n  t=35;\n  l=0;\n  b=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (l<t) {\n      b = b-b;\n      l = l+4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (l<t) {\n      b = b-b;\n      l = l+4;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'l', 'm', 'n', 't']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int t, l, b;\n\n  t=35;\n  l=0;\n  b=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant b == 0;\n  loop invariant l % 4 == 0;\n  loop invariant 0 <= l && l <= t + 3;\n  loop invariant m == \\at(m,Pre);\n  loop invariant n == \\at(n,Pre);\n  loop invariant l >= 0;\n  loop invariant l <= t + 3;\n  loop invariant t == 35;\n  loop invariant (b == 0);\n  loop invariant ((l % 4) == 0);\n  loop invariant (l <= t + 4);\n  loop invariant l <= t + 1;\n  loop assigns b, l;\n*/\nwhile (l<t) {\n      b = b-b;\n      l = l+4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int q){\n  int h, j, t;\n\n  h=64;\n  j=h;\n  t=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j>0) {\n      if ((j%4)==0) {\n          t = t+t;\n      }\n      j = j-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (t == -5) && (j == 64) && (h == 64) && (q == \\at(q, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (j>0) {\n      if ((j%4)==0) {\n          t = t+t;\n      }\n      j = j-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start % 4 != 0; j at loop-step start > 0; j at loop-step start > 0). Changed: j: j at loop-step start -> j at loop-step start - 1; t: t at loop-step start -> t at loop-step start + t at loop-step start. Unchanged: h keeps h at loop-step start; k keeps k at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['h', 'j', 'k', 'q', 't']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int q){\n  int h, j, t;\n\n  h=64;\n  j=h;\n  t=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= j && j <= 64;\n  loop invariant h == 64;\n  loop invariant k == \\at(k, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant t <= -5;\n  loop invariant t % 5 == 0;\n  loop invariant j >= 0;\n  loop assigns t, j;\n*/\nwhile (j>0) {\n      if ((j%4)==0) {\n          t = t+t;\n      }\n      j = j-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n){\n  int i, v, c;\n\n  i=11;\n  v=i;\n  c=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v>0) {\n      if (i<b+4) {\n          c = c+1;\n      }\n      v = v-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (c == -6) && (v == 11) && (i == 11) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (v>0) {\n      if (i<b+4) {\n          c = c+1;\n      }\n      v = v-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start >= b at loop-step start + 4; v at loop-step start > 0; v at loop-step start > 0). Changed: c: c at loop-step start -> c at loop-step start + 1; v: v at loop-step start -> v at loop-step start - 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'i', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n){\n  int i, v, c;\n\n  i=11;\n  v=i;\n  c=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (i < b + 4) ==> c + v == 5;\n  loop invariant (i >= b + 4) ==> c == -6;\n  loop invariant 0 <= v && v <= 11;\n  loop invariant i == 11;\n  loop invariant b == \\at(b, Pre) && n == \\at(n, Pre);\n  loop invariant b == \\at(b, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant (i < b + 4) ==> c == -6 + (11 - v);\n  loop invariant (b == \\at(b, Pre));\n  loop invariant (n == \\at(n, Pre));\n  loop invariant (0 <= v) && (v <= 11);\n  loop invariant (-6 <= c) && (c <= 5);\n  loop invariant (b > 7) ==> c == -6 + (11 - v);\n  loop invariant v <= 11;\n  loop invariant 0 <= v;\n  loop invariant -6 <= c + v;\n  loop invariant c + v <= 5;\n  loop assigns c, v;\n*/\nwhile (v>0) {\n      if (i<b+4) {\n          c = c+1;\n      }\n      v = v-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k){\n  int z, p, v, a;\n\n  z=55;\n  p=0;\n  v=b;\n  a=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (p<z) {\n      a = a+a;\n      a = a+v;\n      p = p+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (a == -8) && (v == \\at(b, Pre)) && (p == 0) && (z == 55) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (p<z) {\n      a = a+a;\n      a = a+v;\n      p = p+2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (p at loop-step start < z at loop-step start). Changed: a: a at loop-step start -> a at loop-step start + a at loop-step start + v at loop-step start; p: p at loop-step start -> p at loop-step start + 2. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; v keeps v at loop-step start; z keeps z at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'k', 'p', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k){\n  int z, p, v, a;\n\n  z=55;\n  p=0;\n  v=b;\n  a=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant p % 2 == 0;\n\n  loop invariant v == \\at(b, Pre);\n  loop invariant b == \\at(b, Pre);\n  loop invariant z == 55;\n\n  loop invariant v == b;\n  loop invariant 0 <= p;\n  loop invariant p <= z + 1;\n  loop invariant p == 2*(p/2);\n  loop invariant k == \\at(k, Pre);\n\n  loop invariant p >= 0;\n  loop invariant (v == 8) ==> (a == -8);\n\n  loop assigns a, p;\n*/\nwhile (p<z) {\n      a = a+a;\n      a = a+v;\n      p = p+2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int q){\n  int y, a, r;\n\n  y=54;\n  a=0;\n  r=y;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (a<y) {\n      r = r+(-4);\n      a = a+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (r == 54) && (a == 0) && (y == 54) && (q == \\at(q, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (a<y) {\n      r = r+(-4);\n      a = a+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (a at loop-step start < y at loop-step start). Changed: a: a at loop-step start -> a at loop-step start + 1; r: r at loop-step start -> r at loop-step start + -4. Unchanged: b keeps b at loop-step start; q keeps q at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'q', 'r', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int q){\n  int y, a, r;\n\n  y=54;\n  a=0;\n  r=y;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant b == \\at(b, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant a >= 0;\n  loop invariant a <= y;\n  loop invariant r == y - 4*a;\n  loop invariant y == 54;\n  loop invariant r + 4*a == y;\n  loop invariant 0 <= a;\n  loop invariant r == 54 - 4*a;\n  loop assigns a, r;\n*/\nwhile (a<y) {\n      r = r+(-4);\n      a = a+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int q){\n  int n, h, f;\n\n  n=25;\n  h=0;\n  f=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (h<n) {\n      f = q%3;\n      f = f+6;\n      h = h+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (f == 25) && (h == 0) && (n == 25) && (q == \\at(q, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (h<n) {\n      f = q%3;\n      f = f+6;\n      h = h+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (h at loop-step start < n at loop-step start). Changed: f: f at loop-step start -> q at loop-step start % 3 + 6; h: h at loop-step start -> h at loop-step start + 3. Unchanged: a keeps a at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'f', 'h', 'n', 'q']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int q){\n  int n, h, f;\n\n  n=25;\n  h=0;\n  f=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant h >= 0;\n\n  loop invariant h % 3 == 0;\n  loop invariant q == \\at(q, Pre);\n  loop invariant a == \\at(a, Pre);\n  loop invariant n == 25;\n  loop invariant f == 25 || f == (q % 3) + 6;\n  loop invariant (h % 3 == 0);\n\n  loop invariant ((h == 0) ==> (f == 25));\n\n  loop invariant (0 <= h);\n  loop invariant h <= 27;\n  loop invariant 0 <= h;\n  loop invariant h <= n + 2;\n  loop assigns f, h;\n*/\nwhile (h<n) {\n      f = q%3;\n      f = f+6;\n      h = h+3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int x, l, j;\n\n  x=76;\n  l=x;\n  j=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (l>0) {\n      j = j+j;\n      l = l-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (j == 0) && (l == 76) && (x == 76) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (l>0) {\n      j = j+j;\n      l = l-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['j', 'l', 'm', 'n', 'x']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int x, l, j;\n\n  x=76;\n  l=x;\n  j=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant j == 0;\n  loop invariant l >= 0 && l <= 76 && x == 76 && m == \\at(m, Pre) && n == \\at(n, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant 0 <= l;\n  loop invariant l <= 76;\n  loop invariant (0 <= l) && (l <= 76);\n  loop invariant l >= 0;\n  loop invariant x == 76;\n  loop assigns j, l;\n*/\nwhile (l>0) {\n      j = j+j;\n      l = l-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int o, n, v, j;\n\n  o=8;\n  n=o;\n  v=-4;\n  j=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (n>3) {\n      v = v+j+j;\n      n = n-4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (j == 0) && (v == -4) && (n == 8) && (o == 8) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (n>3) {\n      v = v+j+j;\n      n = n-4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (n at loop-step start > 3). Changed: n: n at loop-step start -> n at loop-step start - 4; v: v at loop-step start -> v at loop-step start + j at loop-step start + j at loop-step start. Unchanged: b keeps b at loop-step start; j keeps j at loop-step start; m keeps m at loop-step start; o keeps o at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'j', 'm', 'n', 'o', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m){\n  int o, n, v, j;\n\n  o=8;\n  n=o;\n  v=-4;\n  j=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant j == 0;\n  loop invariant v == -4;\n  loop invariant n % 4 == 0;\n  loop invariant (0 <= n) && (n <= 8);\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant o == 8;\n  loop invariant n >= 0;\n  loop invariant n <= 8;\n  loop invariant n <= o;\n  loop assigns v, n;\n*/\nwhile (n>3) {\n      v = v+j+j;\n      n = n-4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int q){\n  int m, a, v, j;\n\n  m=k;\n  a=0;\n  v=k;\n  j=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (a<m) {\n      j = j+j;\n      j = j+v;\n      a = a+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (j == \\at(q, Pre)) && (v == \\at(k, Pre)) && (a == 0) && (m == \\at(k, Pre)) && (q == \\at(q, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (a<m) {\n      j = j+j;\n      j = j+v;\n      a = a+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (a at loop-step start < m at loop-step start). Changed: a: a at loop-step start -> a at loop-step start + 1; j: j at loop-step start -> j at loop-step start + j at loop-step start + v at loop-step start. Unchanged: k keeps k at loop-step start; m keeps m at loop-step start; q keeps q at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'j', 'k', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int q){\n  int m, a, v, j;\n\n  m=k;\n  a=0;\n  v=k;\n  j=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant 0 <= a;\n  loop invariant m == k;\n  loop invariant v == k;\n  loop invariant q == \\at(q, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant a >= 0;\n  loop invariant (m < 0) || (a <= m);\n  loop invariant (a == 0) ==> (j == q);\n  loop assigns a, j;\n*/\nwhile (a<m) {\n      j = j+j;\n      j = j+v;\n      a = a+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b){\n  int g, u, s;\n\n  g=33;\n  u=0;\n  s=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<g) {\n      s = s+u;\n      u = u+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<g) {\n      s = s+u;\n      u = u+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'g', 's', 'u']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b){\n  int g, u, s;\n\n  g=33;\n  u=0;\n  s=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= u;\n  loop invariant u <= g;\n  loop invariant s == -2 + u*(u-1)/2;\n  loop invariant b == \\at(b, Pre);\n  loop invariant s == u*(u - 1)/2 - 2;\n  loop invariant s == -2 + (u*(u-1))/2;\n  loop invariant g == 33;\n  loop invariant 2*(s + 2) == u*(u - 1);\n  loop assigns s, u;\n*/\nwhile (u<g) {\n      s = s+u;\n      u = u+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n){\n  int r, c, y;\n\n  r=50;\n  c=r;\n  y=r;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (c-2>=0) {\n      c = c-2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (y == 50) && (c == 50) && (r == 50) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (c-2>=0) {\n      c = c-2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (c at loop-step start - 2 >= 0). Changed: c: c at loop-step start -> c at loop-step start - 2. Unchanged: n keeps n at loop-step start; r keeps r at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'n', 'r']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n){\n  int r, c, y;\n\n  r=50;\n  c=r;\n  y=r;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= c;\n  loop invariant c <= 50;\n  loop invariant c % 2 == 0;\n  loop invariant r == 50;\n  loop invariant n == \\at(n, Pre);\n  loop invariant c >= 0;\n  loop invariant c <= r;\n  loop invariant (r - c) % 2 == 0;\n  loop invariant c % 2 == r % 2;\n  loop assigns c;\n*/\nwhile (c-2>=0) {\n      c = c-2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b){\n  int k, j, r;\n\n  k=67;\n  j=k;\n  r=j;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j-2>=0) {\n      j = j-2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (r == 67) && (j == 67) && (k == 67) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (j-2>=0) {\n      j = j-2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start - 2 >= 0). Changed: j: j at loop-step start -> j at loop-step start - 2. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'j', 'k']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b){\n  int k, j, r;\n\n  k=67;\n  j=k;\n  r=j;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant b == \\at(b, Pre);\n  loop invariant j >= 0;\n  loop invariant j <= 67;\n  loop invariant (j % 2 == 1);\n  loop invariant k == 67;\n  loop invariant j >= 1;\n  loop invariant j % 2 == 1;\n  loop invariant 1 <= j;\n  loop invariant 0 <= j;\n  loop invariant j <= k;\n  loop invariant j % 2 == k % 2;\n  loop assigns j;\n*/\nwhile (j-2>=0) {\n      j = j-2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p){\n  int h, t, b, x;\n\n  h=22;\n  t=4;\n  b=-8;\n  x=t;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t<=h-1) {\n      b = b+1;\n      t = t+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (x == 4) && (b == -8) && (t == 4) && (h == 22) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (t<=h-1) {\n      b = b+1;\n      t = t+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start <= h at loop-step start - 1). Changed: b: b at loop-step start -> b at loop-step start + 1; t: t at loop-step start -> t at loop-step start + 1. Unchanged: h keeps h at loop-step start; p keeps p at loop-step start; x keeps x at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'h', 'p', 't']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p){\n  int h, t, b, x;\n\n  h=22;\n  t=4;\n  b=-8;\n  x=t;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant t - b == 12;\n  loop invariant t <= h;\n  loop invariant t >= 4;\n  loop invariant p == \\at(p, Pre);\n  loop invariant b - t == -12;\n  loop invariant 4 <= t;\n  loop invariant h == 22;\n  loop invariant b == t - 12;\n  loop assigns b, t;\n*/\nwhile (t<=h-1) {\n      b = b+1;\n      t = t+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int p, w, v;\n\n  p=25;\n  w=0;\n  v=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (w<p) {\n      w = w+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 1) && (w == 0) && (p == 25) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (w<p) {\n      w = w+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (w at loop-step start < p at loop-step start). Changed: w: w at loop-step start -> w at loop-step start + 1. Unchanged: m keeps m at loop-step start; p keeps p at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['m', 'p', 'w']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int p, w, v;\n\n  p=25;\n  w=0;\n  v=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= w <= p;\n  loop invariant p == 25;\n  loop invariant m == \\at(m, Pre);\n  loop invariant 0 <= w;\n  loop invariant w <= p;\n  loop assigns w;\n*/\nwhile (w<p) {\n      w = w+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n){\n  int y, t, v, e;\n\n  y=15;\n  t=0;\n  v=5;\n  e=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t<=y-5) {\n      v = v+1;\n      e = e-1;\n      t = t+5;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (e == 2) && (v == 5) && (t == 0) && (y == 15) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (t<=y-5) {\n      v = v+1;\n      e = e-1;\n      t = t+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start <= y at loop-step start - 5). Changed: e: e at loop-step start -> e at loop-step start - 1; t: t at loop-step start -> t at loop-step start + 5; v: v at loop-step start -> v at loop-step start + 1. Unchanged: n keeps n at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'n', 't', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n){\n  int y, t, v, e;\n\n  y=15;\n  t=0;\n  v=5;\n  e=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant t == 5*v - 25;\n  loop invariant 0 <= t;\n\n  loop invariant n == \\at(n, Pre);\n  loop invariant y == 15;\n  loop invariant e + v == 7;\n  loop invariant v >= 5;\n  loop invariant v + e == 7;\n  loop invariant t == 5 * (v - 5);\n  loop invariant t <= y;\n  loop invariant t >= 0;\n  loop invariant 5 * (v - 5) == t;\n  loop assigns v, e, t;\n*/\nwhile (t<=y-5) {\n      v = v+1;\n      e = e-1;\n      t = t+5;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int q){\n  int r, o, e, v;\n\n  r=47;\n  o=r;\n  e=o;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (o-2>=0) {\n      o = o-2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == \\at(q, Pre)) && (e == 47) && (o == 47) && (r == 47) && (q == \\at(q, Pre))\n\n2. Loop Code:\n```c\nwhile (o-2>=0) {\n      o = o-2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (o at loop-step start - 2 >= 0). Changed: o: o at loop-step start -> o at loop-step start - 2. Unchanged: e keeps e at loop-step start; q keeps q at loop-step start; r keeps r at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['o', 'q', 'r']\n\n**Function Parameters:**\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int q){\n  int r, o, e, v;\n\n  r=47;\n  o=r;\n  e=o;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant r == 47;\n  loop invariant o <= r;\n  loop invariant o >= 0;\n  loop invariant o % 2 == r % 2;\n  loop invariant q == \\at(q, Pre);\n  loop invariant 0 <= o;\n  loop invariant o <= 47;\n  loop invariant o % 2 == 47 % 2;\n  loop invariant o + 2 * ((47 - o) / 2) == 47;\n  loop invariant o >= 1;\n  loop invariant o % 2 == 1;\n  loop assigns o;\n*/\nwhile (o-2>=0) {\n      o = o-2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int n, q, v;\n\n  n=(m%14)+9;\n  q=0;\n  v=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (q<=n-3) {\n      v = v-v;\n      v = v+q;\n      q = q+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 6) && (q == 0) && (n == \\at(m, Pre) % 14 + 9) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (q<=n-3) {\n      v = v-v;\n      v = v+q;\n      q = q+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (q at loop-step start <= n at loop-step start - 3). Changed: q: q at loop-step start -> q at loop-step start + 3; v: v at loop-step start -> v at loop-step start - v at loop-step start + q at loop-step start. Unchanged: m keeps m at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['m', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int n, q, v;\n\n  n=(m%14)+9;\n  q=0;\n  v=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant m == \\at(m,Pre);\n  loop invariant n == (m % 14) + 9;\n  loop invariant q >= 0;\n  loop invariant (q == 0) ==> (v == 6);\n  loop invariant (q != 0) ==> (v == q - 3);\n  loop invariant q % 3 == 0;\n\n  loop invariant v == 6 || v == q - 3;\n  loop invariant n == \\at(m, Pre) % 14 + 9;\n\n  loop invariant (q == 0 && v == 6) || (q != 0 && v == q - 3);\n\n  loop invariant v >= q - 3;\n  loop assigns v, q;\n*/\nwhile (q<=n-3) {\n      v = v-v;\n      v = v+q;\n      q = q+3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n){\n  int r, q, z, s;\n\n  r=(n%11)+17;\n  q=r;\n  z=8;\n  s=r;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (q-1>=0) {\n      q = q-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == \\at(n, Pre) % 11 + 17) && (z == 8) && (q == \\at(n, Pre) % 11 + 17) && (r == \\at(n, Pre) % 11 + 17) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (q-1>=0) {\n      q = q-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (q at loop-step start - 1 >= 0). Changed: q: q at loop-step start -> q at loop-step start - 1. Unchanged: n keeps n at loop-step start; r keeps r at loop-step start; s keeps s at loop-step start; z keeps z at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['n', 'q', 'r']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n){\n  int r, q, z, s;\n\n  r=(n%11)+17;\n  q=r;\n  z=8;\n  s=r;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant n == \\at(n, Pre);\n  loop invariant r == (\\at(n, Pre) % 11) + 17;\n  loop invariant 0 <= q;\n  loop invariant q <= (\\at(n, Pre) % 11) + 17;\n  loop invariant r == (\\at(n, Pre) % 11 + 17);\n  loop invariant q <= r;\n  loop invariant q >= 0;\n  loop invariant q <= \\at(n,Pre) % 11 + 17;\n  loop invariant r == \\at(n,Pre) % 11 + 17;\n  loop assigns q;\n*/\nwhile (q-1>=0) {\n      q = q-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a){\n  int j, k, f;\n\n  j=25;\n  k=0;\n  f=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k<j) {\n      k = k+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (f == \\at(a, Pre)) && (k == 0) && (j == 25) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (k<j) {\n      k = k+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start < j at loop-step start). Changed: k: k at loop-step start -> k at loop-step start + 1. Unchanged: a keeps a at loop-step start; f keeps f at loop-step start; j keeps j at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'j', 'k']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a){\n  int j, k, f;\n\n  j=25;\n  k=0;\n  f=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant a == \\at(a, Pre);\n  loop invariant j == 25;\n  loop invariant 0 <= k;\n  loop invariant k <= j;\n  loop invariant 0 <= k <= j;\n  loop invariant k >= 0;\n  loop assigns k;\n*/\nwhile (k<j) {\n      k = k+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b){\n  int m, i, h;\n\n  m=b;\n  i=0;\n  h=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<=m-1) {\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (h == \\at(b, Pre)) && (i == 0) && (m == \\at(b, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<=m-1) {\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start <= m at loop-step start - 1). Changed: i: i at loop-step start -> i at loop-step start + 1. Unchanged: b keeps b at loop-step start; h keeps h at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'm']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b){\n  int m, i, h;\n\n  m=b;\n  i=0;\n  h=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == \\at(b, Pre);\n  loop invariant 0 <= i;\n  loop invariant b == \\at(b, Pre);\n  loop invariant i >= 0;\n  loop invariant (m < 0) || i <= m;\n  loop invariant (m < 0) || (i <= m);\n  loop invariant m == b;\n\n  loop assigns i;\n*/\nwhile (i<=m-1) {\n      i = i+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int q){\n  int b, i, r;\n\n  b=54;\n  i=0;\n  r=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i+5<=b) {\n      i = i+5;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (r == 0) && (i == 0) && (b == 54) && (q == \\at(q, Pre))\n\n2. Loop Code:\n```c\nwhile (i+5<=b) {\n      i = i+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start + 5 <= b at loop-step start). Changed: i: i at loop-step start -> i at loop-step start + 5. Unchanged: b keeps b at loop-step start; q keeps q at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'q']\n\n**Function Parameters:**\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int q){\n  int b, i, r;\n\n  b=54;\n  i=0;\n  r=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i >= 0;\n  loop invariant i <= b;\n  loop invariant b == 54;\n  loop invariant q == \\at(q, Pre);\n  loop invariant i % 5 == 0;\n  loop invariant 0 <= i;\n  loop assigns i;\n*/\nwhile (i+5<=b) {\n      i = i+5;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int u, x, v, s;\n\n  u=36;\n  x=0;\n  v=u;\n  s=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (x+1<=u) {\n      x = x+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == \\at(m, Pre)) && (v == 36) && (x == 0) && (u == 36) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (x+1<=u) {\n      x = x+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (x at loop-step start + 1 <= u at loop-step start). Changed: x: x at loop-step start -> x at loop-step start + 1. Unchanged: m keeps m at loop-step start; s keeps s at loop-step start; u keeps u at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['m', 'u', 'x']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int u, x, v, s;\n\n  u=36;\n  x=0;\n  v=u;\n  s=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == \\at(m, Pre);\n  loop invariant u == 36;\n  loop invariant x >= 0;\n  loop invariant x <= u;\n  loop invariant 0 <= x;\n  loop assigns x;\n*/\nwhile (x+1<=u) {\n      x = x+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int l, t, v, a;\n\n  l=57;\n  t=l;\n  v=5;\n  a=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t>0) {\n      t = t-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (a == 57) && (v == 5) && (t == 57) && (l == 57) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (t>0) {\n      t = t-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start > 0). Changed: t: t at loop-step start -> t at loop-step start - 1. Unchanged: a keeps a at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['l', 'm', 't']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int l, t, v, a;\n\n  l=57;\n  t=l;\n  v=5;\n  a=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 57;\n  loop invariant m == \\at(m, Pre);\n  loop invariant t >= 0;\n  loop invariant t <= 57;\n  loop invariant t <= l;\n  loop assigns t;\n*/\nwhile (t>0) {\n      t = t-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k){\n  int q, p, c, v;\n\n  q=59;\n  p=2;\n  c=q;\n  v=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (p<=q-1) {\n      c = c+1;\n      p = p+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -3) && (c == 59) && (p == 2) && (q == 59) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (p<=q-1) {\n      c = c+1;\n      p = p+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (p at loop-step start <= q at loop-step start - 1). Changed: c: c at loop-step start -> c at loop-step start + 1; p: p at loop-step start -> p at loop-step start + 1. Unchanged: k keeps k at loop-step start; q keeps q at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'k', 'p', 'q']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k){\n  int q, p, c, v;\n\n  q=59;\n  p=2;\n  c=q;\n  v=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant c == p + 57;\n  loop invariant p <= q;\n  loop invariant k == \\at(k, Pre);\n  loop invariant c - p == 57;\n  loop invariant p >= 2;\n  loop invariant q == 59;\n  loop invariant c - p == q - 2;\n  loop invariant c >= q;\n  loop assigns c, p;\n*/\nwhile (p<=q-1) {\n      c = c+1;\n      p = p+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a){\n  int y, i, o;\n\n  y=a-10;\n  i=0;\n  o=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<y) {\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (o == \\at(a, Pre)) && (i == 0) && (y == \\at(a, Pre) - 10) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<y) {\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start < y at loop-step start). Changed: i: i at loop-step start -> i at loop-step start + 1. Unchanged: a keeps a at loop-step start; o keeps o at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a){\n  int y, i, o;\n\n  y=a-10;\n  i=0;\n  o=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i >= 0;\n  loop invariant y == a - 10;\n  loop invariant (y >= 0) ==> (i <= y);\n  loop invariant a == \\at(a, Pre);\n  loop invariant y == \\at(a, Pre) - 10;\n  loop assigns i;\n*/\nwhile (i<y) {\n      i = i+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int l, r, j;\n\n  l=47;\n  r=l;\n  j=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (r-4>=0) {\n      r = r-4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (j == -4) && (r == 47) && (l == 47) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (r-4>=0) {\n      r = r-4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (r at loop-step start - 4 >= 0). Changed: r: r at loop-step start -> r at loop-step start - 4. Unchanged: j keeps j at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['l', 'm', 'r']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int l, r, j;\n\n  l=47;\n  r=l;\n  j=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 47;\n  loop invariant m == \\at(m, Pre);\n  loop invariant 0 <= r;\n  loop invariant r <= 47;\n  loop invariant r % 4 == 3;\n  loop invariant r <= l;\n  loop invariant r >= 3;\n  loop invariant (l - r) % 4 == 0;\n  loop invariant (r % 4) == 3;\n  loop invariant r % 4 == l % 4;\n  loop assigns r;\n*/\nwhile (r-4>=0) {\n      r = r-4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int q){\n  int n, k, p, v;\n\n  n=24;\n  k=0;\n  p=k;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k<=n-3) {\n      p = p+1;\n      k = k+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 24) && (p == 0) && (k == 0) && (n == 24) && (q == \\at(q, Pre))\n\n2. Loop Code:\n```c\nwhile (k<=n-3) {\n      p = p+1;\n      k = k+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start <= n at loop-step start - 3). Changed: k: k at loop-step start -> k at loop-step start + 3; p: p at loop-step start -> p at loop-step start + 1. Unchanged: n keeps n at loop-step start; q keeps q at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'n', 'p', 'q']\n\n**Function Parameters:**\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int q){\n  int n, k, p, v;\n\n  n=24;\n  k=0;\n  p=k;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant k == 3*p;\n  loop invariant k <= n;\n  loop invariant p >= 0;\n  loop invariant n == 24;\n  loop invariant q == \\at(q, Pre);\n  loop invariant 3*p == k;\n  loop invariant p <= n/3;\n  loop invariant k >= 0;\n  loop assigns p, k;\n*/\nwhile (k<=n-3) {\n      p = p+1;\n      k = k+3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p){\n  int m, t, q;\n\n  m=19;\n  t=m;\n  q=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t>2) {\n      t = t-3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (q == 3) && (t == 19) && (m == 19) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (t>2) {\n      t = t-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start > 2). Changed: t: t at loop-step start -> t at loop-step start - 3. Unchanged: m keeps m at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['m', 'p', 't']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p){\n  int m, t, q;\n\n  m=19;\n  t=m;\n  q=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant t % 3 == 1;\n  loop invariant p == \\at(p, Pre);\n  loop invariant m == 19;\n  loop invariant t <= m;\n  loop invariant t <= 19;\n  loop invariant t >= 1;\n  loop assigns t;\n*/\nwhile (t>2) {\n      t = t-3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b){\n  int n, m, v, j;\n\n  n=8;\n  m=0;\n  v=b;\n  j=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (m<n) {\n      v = v+1;\n      m = m+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (j == \\at(b, Pre)) && (v == \\at(b, Pre)) && (m == 0) && (n == 8) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (m<n) {\n      v = v+1;\n      m = m+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (m at loop-step start < n at loop-step start). Changed: m: m at loop-step start -> m at loop-step start + 3; v: v at loop-step start -> v at loop-step start + 1. Unchanged: b keeps b at loop-step start; j keeps j at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b){\n  int n, m, v, j;\n\n  n=8;\n  m=0;\n  v=b;\n  j=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == 3*(v - \\at(b, Pre));\n  loop invariant v >= \\at(b, Pre);\n  loop invariant m % 3 == 0;\n  loop invariant v == \\at(b, Pre) + m / 3;\n  loop invariant 0 <= m;\n  loop invariant m <= n + 2;\n  loop invariant b == \\at(b, Pre);\n  loop invariant v == b + m/3;\n  loop invariant n == 8;\n\n  loop assigns m, v;\n*/\nwhile (m<n) {\n      v = v+1;\n      m = m+3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k){\n  int m, v, o, h;\n\n  m=18;\n  v=1;\n  o=v;\n  h=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<m) {\n      v = v+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (h == 18) && (o == 1) && (v == 1) && (m == 18) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (v<m) {\n      v = v+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start < m at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 1. Unchanged: h keeps h at loop-step start; k keeps k at loop-step start; m keeps m at loop-step start; o keeps o at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k){\n  int m, v, o, h;\n\n  m=18;\n  v=1;\n  o=v;\n  h=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (m - v) + v == m;\n  loop invariant 1 <= v;\n  loop invariant v <= m;\n  loop invariant k == \\at(k, Pre);\n  loop invariant v >= 1;\n  loop invariant m == 18;\n  loop assigns v;\n*/\nwhile (v<m) {\n      v = v+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b){\n  int a, k, o;\n\n  a=54;\n  k=a;\n  o=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k>=1) {\n      k = k-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (o == \\at(b, Pre)) && (k == 54) && (a == 54) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (k>=1) {\n      k = k-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start >= 1). Changed: k: k at loop-step start -> k at loop-step start - 1. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; o keeps o at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'k']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b){\n  int a, k, o;\n\n  a=54;\n  k=a;\n  o=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant a == 54;\n  loop invariant b == \\at(b, Pre);\n  loop invariant k <= 54;\n  loop invariant k >= 0;\n  loop invariant k <= a;\n  loop invariant 0 <= k;\n  loop assigns k;\n*/\nwhile (k>=1) {\n      k = k-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a){\n  int u, x, v;\n\n  u=a;\n  x=0;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (x<=u-1) {\n      x = x+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 2) && (x == 0) && (u == \\at(a, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (x<=u-1) {\n      x = x+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'u', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a){\n  int u, x, v;\n\n  u=a;\n  x=0;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant x >= 0 && (u >= 0) ==> (x <= u) && (u < 0) ==> (x == 0);\n  loop invariant u == a;\n\n  loop invariant a == \\at(a, Pre);\n  loop invariant x >= 0;\n  loop invariant (a >= 0) ==> (x <= a);\n  loop invariant u == \\at(a, Pre);\n\n  loop assigns x;\n*/\nwhile (x<=u-1) {\n      x = x+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k){\n  int u, q, j;\n\n  u=(k%6)+4;\n  q=u;\n  j=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (q-2>=0) {\n      j = j+1;\n      if (q+6<=q+u) {\n          j = j+1;\n      }\n      q = q-2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (j == \\at(k, Pre) % 6 + 4) && (q == \\at(k, Pre) % 6 + 4) && (u == \\at(k, Pre) % 6 + 4) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (q-2>=0) {\n      j = j+1;\n      if (q+6<=q+u) {\n          j = j+1;\n      }\n      q = q-2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (q at loop-step start + 6 > q at loop-step start + u at loop-step start; q at loop-step start - 2 >= 0; q at loop-step start - 2 >= 0). Changed: j: j at loop-step start -> j at loop-step start + 1 + 1; q: q at loop-step start -> q at loop-step start - 2. Unchanged: k keeps k at loop-step start; u keeps u at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['j', 'k', 'q', 'u']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k){\n  int u, q, j;\n\n  u=(k%6)+4;\n  q=u;\n  j=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant u == ((\\at(k, Pre) % 6) + 4);\n  loop invariant (q % 2) == (((\\at(k, Pre) % 6) + 4) % 2);\n\n  loop invariant (u >= 6) ==> j == 2*(\\at(k, Pre) % 6 + 4) - q &&\n                   (u < 6)  ==> j == (\\at(k, Pre) % 6 + 4) + ((\\at(k, Pre) % 6 + 4 - q)/2);\n\n  loop invariant q <= \\at(k, Pre) % 6 + 4;\n  loop invariant j >= q;\n\n  loop invariant u == (\\at(k, Pre) % 6) + 4;\n  loop invariant k == \\at(k, Pre);\n\n  loop assigns j, q;\n*/\nwhile (q-2>=0) {\n      j = j+1;\n      if (q+6<=q+u) {\n          j = j+1;\n      }\n      q = q-2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a){\n  int r, k, v;\n\n  r=a;\n  k=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k<=r-1) {\n      v = v+k;\n      if (k+5<=r+r) {\n          v = v-v;\n      }\n      k = k+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 0) && (k == 0) && (r == \\at(a, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (k<=r-1) {\n      v = v+k;\n      if (k+5<=r+r) {\n          v = v-v;\n      }\n      k = k+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start + 5 > r at loop-step start + r at loop-step start; k at loop-step start <= r at loop-step start - 1; k at loop-step start <= r at loop-step start - 1). Changed: k: k at loop-step start -> k at loop-step start + 1; v: v at loop-step start -> v at loop-step start + k at loop-step start - (v at loop-step start + k at loop-step start. Unchanged: a keeps a at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'k', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a){\n  int r, k, v;\n\n  r=a;\n  k=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant (k <= 2*r - 4) ==> (v == 0);\n  loop invariant k >= 0;\n\n  loop invariant v >= 0;\n  loop invariant r == \\at(a, Pre);\n  loop invariant (r >= 4) ==> (v == 0);\n  loop invariant r == a;\n  loop invariant a == \\at(a, Pre);\n  loop invariant v <= r*(r-1)/2;\n\n  loop invariant 0 <= k;\n  loop invariant 0 <= v;\n  loop invariant v <= k*(k-1)/2;\n  loop assigns v, k;\n*/\nwhile (k<=r-1) {\n      v = v+k;\n      if (k+5<=r+r) {\n          v = v-v;\n      }\n      k = k+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int q){\n  int i, j, w, s;\n\n  i=19;\n  j=i;\n  w=i;\n  s=j;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j>3) {\n      w = w+1;\n      s = s-1;\n      j = j-4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == 19) && (w == 19) && (j == 19) && (i == 19) && (q == \\at(q, Pre))\n\n2. Loop Code:\n```c\nwhile (j>3) {\n      w = w+1;\n      s = s-1;\n      j = j-4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start > 3). Changed: j: j at loop-step start -> j at loop-step start - 4; s: s at loop-step start -> s at loop-step start - 1; w: w at loop-step start -> w at loop-step start + 1. Unchanged: i keeps i at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'j', 'q', 's', 'w']\n\n**Function Parameters:**\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int q){\n  int i, j, w, s;\n\n  i=19;\n  j=i;\n  w=i;\n  s=j;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (j - 4*s == -57);\n  loop invariant (w + s == 38);\n  loop invariant (i == 19);\n  loop invariant (q == \\at(q, Pre));\n  loop invariant (s <= 19);\n  loop invariant (j <= 19);\n  loop invariant (w >= 19);\n  loop invariant i == 19;\n  loop invariant q == \\at(q, Pre);\n  loop invariant s + w == 38;\n  loop invariant j == 95 - 4*w;\n  loop invariant j >= 3;\n  loop invariant 3 <= j;\n  loop invariant j <= 19;\n  loop invariant w >= 19;\n  loop assigns w, s, j;\n*/\nwhile (j>3) {\n      w = w+1;\n      s = s-1;\n      j = j-4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int b, v, a, w;\n\n  b=53;\n  v=b;\n  a=v;\n  w=v;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v>3) {\n      a = a+1;\n      w = w-1;\n      v = v-4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (w == 53) && (a == 53) && (v == 53) && (b == 53) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (v>3) {\n      a = a+1;\n      w = w-1;\n      v = v-4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start > 3). Changed: a: a at loop-step start -> a at loop-step start + 1; v: v at loop-step start -> v at loop-step start - 4; w: w at loop-step start -> w at loop-step start - 1. Unchanged: b keeps b at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'm', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int b, v, a, w;\n\n  b=53;\n  v=b;\n  a=v;\n  w=v;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 4*a + v == 5*b;\n  loop invariant a + w == 2*b;\n  loop invariant 0 <= v;\n  loop invariant v <= b;\n  loop invariant m == \\at(m, Pre);\n  loop invariant v % 4 == 1;\n  loop invariant a >= 53;\n  loop invariant w <= 53;\n  loop invariant v <= 53;\n  loop invariant b == 53;\n  loop invariant a <= 66;\n  loop assigns a, v, w;\n*/\nwhile (v>3) {\n      a = a+1;\n      w = w-1;\n      v = v-4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int b, p, r;\n\n  b=20;\n  p=b;\n  r=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (p>=4) {\n      r = r-r;\n      r = r+6;\n      p = p-4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (r == 20) && (p == 20) && (b == 20) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (p>=4) {\n      r = r-r;\n      r = r+6;\n      p = p-4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (p at loop-step start >= 4). Changed: p: p at loop-step start -> p at loop-step start - 4; r: r at loop-step start -> r at loop-step start - r at loop-step start + 6. Unchanged: b keeps b at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'm', 'p', 'r']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int b, p, r;\n\n  b=20;\n  p=b;\n  r=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant p % 4 == 0;\n  loop invariant 0 <= p <= 20;\n  loop invariant (r == 6) || (r == 20);\n  loop invariant m == \\at(m, Pre);\n  loop invariant 0 <= p;\n  loop invariant p <= b;\n  loop invariant (p == b && r == b) || (p <= b - 4 && r == 6);\n  loop invariant b == 20;\n  loop invariant p <= 20;\n  loop invariant (p >= 0) && (p <= 20) && (p % 4 == 0) && ((r == 6) || (r == 20));\n  loop assigns p, r;\n*/\nwhile (p>=4) {\n      r = r-r;\n      r = r+6;\n      p = p-4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p){\n  int m, u, j, b;\n\n  m=35;\n  u=0;\n  j=p;\n  b=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<=m-3) {\n      j = j+1;\n      b = b-1;\n      u = u+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<=m-3) {\n      j = j+1;\n      b = b-1;\n      u = u+3;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'j', 'm', 'p', 'u']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p){\n  int m, u, j, b;\n\n  m=35;\n  u=0;\n  j=p;\n  b=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant j + b == 2 * \\at(p, Pre);\n  loop invariant u == 3 * (j - \\at(p, Pre));\n  loop invariant u >= 0;\n  loop invariant u <= m;\n  loop invariant p == \\at(p, Pre);\n  loop invariant m == 35;\n  loop invariant u == 3*(j - p);\n  loop invariant u == 3*(p - b);\n  loop invariant j + b == 2*p;\n  loop invariant 3*(j - p) == u;\n\n  loop invariant b + j == 2 * p;\n  loop invariant j >= p;\n  loop invariant b <= p;\n  loop assigns j, b, u;\n*/\nwhile (u<=m-3) {\n      j = j+1;\n      b = b-1;\n      u = u+3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k){\n  int d, p, e, v;\n\n  d=k;\n  p=0;\n  e=8;\n  v=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (p<=d-1) {\n      e = e+1;\n      p = p+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -5) && (e == 8) && (p == 0) && (d == \\at(k, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (p<=d-1) {\n      e = e+1;\n      p = p+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (p at loop-step start <= d at loop-step start - 1). Changed: e: e at loop-step start -> e at loop-step start + 1; p: p at loop-step start -> p at loop-step start + 1. Unchanged: d keeps d at loop-step start; k keeps k at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'e', 'k', 'p']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k){\n  int d, p, e, v;\n\n  d=k;\n  p=0;\n  e=8;\n  v=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant e == p + 8;\n  loop invariant d == k;\n\n  loop invariant k == \\at(k, Pre);\n  loop invariant e - p == 8;\n  loop invariant 0 <= p;\n  loop invariant p >= 0;\n  loop invariant 0 <= p && (d >= 0 ==> p <= d);\n  loop invariant d == \\at(k, Pre);\n  loop invariant e == 8 + p;\n  loop assigns e, p;\n*/\nwhile (p<=d-1) {\n      e = e+1;\n      p = p+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a){\n  int y, h, v;\n\n  y=(a%7)+18;\n  h=0;\n  v=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (h<y) {\n      v = v+v;\n      h = h+5;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -5) && (h == 0) && (y == \\at(a, Pre) % 7 + 18) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (h<y) {\n      v = v+v;\n      h = h+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (h at loop-step start < y at loop-step start). Changed: h: h at loop-step start -> h at loop-step start + 5; v: v at loop-step start -> v at loop-step start + v at loop-step start. Unchanged: a keeps a at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'h', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a){\n  int y, h, v;\n\n  y=(a%7)+18;\n  h=0;\n  v=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant a == \\at(a, Pre);\n  loop invariant y == (a % 7) + 18;\n  loop invariant h % 5 == 0;\n  loop invariant h >= 0;\n  loop invariant v <= -5;\n  loop invariant y == ((\\at(a, Pre)) % 7) + 18;\n  loop invariant h <= y + 4;\n  loop invariant v % 5 == 0;\n  loop invariant y == (\\at(a, Pre) % 7) + 18;\n  loop invariant 0 <= h;\n\n  loop invariant v < 0;\n  loop invariant y == \\at(a, Pre) % 7 + 18;\n  loop assigns h, v;\n*/\nwhile (h<y) {\n      v = v+v;\n      h = h+5;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p){\n  int l, k, e, j;\n\n  l=p-8;\n  k=0;\n  e=l;\n  j=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k<=l-1) {\n      e = e+1;\n      j = j+e;\n      k = k+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (j == \\at(p, Pre)) && (e == \\at(p, Pre) - 8) && (k == 0) && (l == \\at(p, Pre) - 8) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (k<=l-1) {\n      e = e+1;\n      j = j+e;\n      k = k+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'j', 'k', 'l', 'p']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p){\n  int l, k, e, j;\n\n  l=p-8;\n  k=0;\n  e=l;\n  j=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == \\at(p, Pre) - 8;\n  loop invariant e == (\\at(p, Pre) - 8) + k;\n  loop invariant j == \\at(p, Pre) + k*( (\\at(p, Pre) - 8) ) + k*(k+1)/2;\n  loop invariant 0 <= k;\n  loop invariant k >= 0;\n\n  loop invariant e == l + k;\n  loop invariant j == p + k*l + k*(k+1)/2;\n  loop invariant l == p - 8;\n  loop invariant p == \\at(p, Pre);\n  loop invariant j == \\at(p, Pre) + k*l + (k*(k+1))/2;\n\n  loop invariant k >= 0 && (l < 0 || k <= l + 1);\n  loop assigns e, j, k;\n*/\nwhile (k<=l-1) {\n      e = e+1;\n      j = j+e;\n      k = k+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int u, x, v, s;\n\n  u=36;\n  x=0;\n  v=u;\n  s=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<u) {\n      if (v<u) {\n          v = v+1;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == \\at(m, Pre)) && (v == 36) && (x == 0) && (u == 36) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (v<u) {\n      if (v<u) {\n          v = v+1;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start < u at loop-step start; v at loop-step start < u at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 1. Unchanged: m keeps m at loop-step start; s keeps s at loop-step start; u keeps u at loop-step start; x keeps x at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['m', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int u, x, v, s;\n\n  u=36;\n  x=0;\n  v=u;\n  s=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == \\at(m, Pre);\n  loop invariant u == 36;\n  loop invariant v <= u;\n  loop invariant v >= 36;\n  loop assigns v;\n*/\nwhile (v<u) {\n      if (v<u) {\n          v = v+1;\n      }\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int q){\n  int n, k, p, v;\n\n  n=24;\n  k=0;\n  p=k;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (p<n) {\n      if (p<n) {\n          p = p+1;\n      }\n      p = p+v+v;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 24) && (p == 0) && (k == 0) && (n == 24) && (q == \\at(q, Pre))\n\n2. Loop Code:\n```c\nwhile (p<n) {\n      if (p<n) {\n          p = p+1;\n      }\n      p = p+v+v;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (p at loop-step start < n at loop-step start; p at loop-step start < n at loop-step start). Changed: p: p at loop-step start -> p at loop-step start + 1 + v at loop-step start + v at loop-step start. Unchanged: k keeps k at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int q){\n  int n, k, p, v;\n\n  n=24;\n  k=0;\n  p=k;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant p % 49 == 0;\n  loop invariant p >= 0;\n  loop invariant n == 24;\n  loop invariant v == 24;\n  loop invariant q == \\at(q, Pre);\n  loop invariant p <= 49;\n  loop invariant p % (1 + 2*v) == 0;\n  loop invariant v == n;\n  loop assigns p;\n*/\nwhile (p<n) {\n      if (p<n) {\n          p = p+1;\n      }\n      p = p+v+v;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int b, i, k;\n\n  b=m;\n  i=b;\n  k=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      k = k+i;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (k == \\at(m, Pre)) && (i == \\at(m, Pre)) && (b == \\at(m, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      k = k+i;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start > 0). Changed: i: i at loop-step start -> i at loop-step start - 1; k: k at loop-step start -> k at loop-step start + i at loop-step start. Unchanged: b keeps b at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'm']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int b, i, k;\n\n  b=m;\n  i=b;\n  k=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant b == m;\n  loop invariant k + i*(i+1)/2 == \\at(m, Pre) + \\at(m, Pre)*(\\at(m, Pre)+1)/2;\n  loop invariant b == \\at(m,Pre);\n  loop invariant 2*k == (\\at(m,Pre) * \\at(m,Pre) + 3 * \\at(m,Pre) - i * i - i);\n\n  loop invariant m == \\at(m, Pre);\n  loop invariant k >= i;\n  loop invariant 2*k + i*(i+1) == 2*b + b*(b+1);\n\n  loop invariant i <= b;\n  loop invariant k + i*(i+1)/2 == \\at(m, Pre) + (\\at(m, Pre)*(\\at(m, Pre)+1))/2;\n  loop invariant i <= \\at(m, Pre);\n  loop invariant \\at(m, Pre) >= 0 ==> i >= 0;\n  loop assigns k, i;\n*/\nwhile (i>0) {\n      k = k+i;\n      i = i-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int q){\n  int x, p, s, g;\n\n  x=q+17;\n  p=0;\n  s=x;\n  g=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (p+2<=x) {\n      if (s+3<=x) {\n          s = s+3;\n      }\n      else {\n          s = x;\n      }\n      s = s+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (g == 0) && (s == \\at(q, Pre) + 17) && (p == 0) && (x == \\at(q, Pre) + 17) && (q == \\at(q, Pre))\n\n2. Loop Code:\n```c\nwhile (p+2<=x) {\n      if (s+3<=x) {\n          s = s+3;\n      }\n      else {\n          s = x;\n      }\n      s = s+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start + 3 > x at loop-step start; p at loop-step start + 2 <= x at loop-step start; p at loop-step start + 2 <= x at loop-step start). Changed: s: s at loop-step start -> s at loop-step start + 3 + 1. Unchanged: g keeps g at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start; x keeps x at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['p', 'q', 's', 'x']\n\n**Function Parameters:**\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int q){\n  int x, p, s, g;\n\n  x=q+17;\n  p=0;\n  s=x;\n  g=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant p == 0;\n  loop invariant x == q + 17;\n  loop invariant (s == x) || (s == x+1);\n  loop invariant x == \\at(q, Pre) + 17;\n  loop invariant q == \\at(q, Pre);\n  loop invariant s == x || s == x + 1;\n  loop invariant x <= s;\n  loop invariant s <= x + 1;\n  loop invariant s >= x;\n  loop assigns s;\n*/\nwhile (p+2<=x) {\n      if (s+3<=x) {\n          s = s+3;\n      }\n      else {\n          s = x;\n      }\n      s = s+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b){\n  int p, z, v;\n\n  p=b;\n  z=p;\n  v=z;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (z>1) {\n      v = v-v;\n      z = z-2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == \\at(b, Pre)) && (z == \\at(b, Pre)) && (p == \\at(b, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (z>1) {\n      v = v-v;\n      z = z-2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (z at loop-step start > 1). Changed: v: v at loop-step start -> v at loop-step start - v at loop-step start; z: z at loop-step start -> z at loop-step start - 2. Unchanged: b keeps b at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'p', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b){\n  int p, z, v;\n\n  p=b;\n  z=p;\n  v=z;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant b == \\at(b, Pre);\n  loop invariant p == b;\n  loop invariant z <= p;\n  loop invariant (p - z) % 2 == 0;\n  loop invariant p == \\at(b, Pre);\n  loop invariant v == 0 || v == \\at(b, Pre);\n  loop invariant (v == \\at(b, Pre)) <==> (z == \\at(b, Pre));\n  loop invariant z <= \\at(b, Pre);\n  loop invariant z % 2 == \\at(b, Pre) % 2;\n  loop invariant z >= v;\n  loop invariant v <= p;\n\n  loop invariant v <= z;\n  loop invariant ((\\at(b, Pre) - z) % 2 == 0);\n  loop assigns v, z;\n*/\nwhile (z>1) {\n      v = v-v;\n      z = z-2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p){\n  int j, y, t, v;\n\n  j=8;\n  y=j;\n  t=y;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (y-1>=0) {\n      if (t+3<=j) {\n          t = t+3;\n      }\n      else {\n          t = j;\n      }\n      t = t+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 4) && (t == 8) && (y == 8) && (j == 8) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (y-1>=0) {\n      if (t+3<=j) {\n          t = t+3;\n      }\n      else {\n          t = j;\n      }\n      t = t+2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start + 3 > j at loop-step start; y at loop-step start - 1 >= 0; y at loop-step start - 1 >= 0). Changed: t: t at loop-step start -> t at loop-step start + 3 + 2. Unchanged: j keeps j at loop-step start; p keeps p at loop-step start; v keeps v at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['j', 'p', 't', 'y']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p){\n  int j, y, t, v;\n\n  j=8;\n  y=j;\n  t=y;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant p == \\at(p, Pre);\n  loop invariant j == 8;\n  loop invariant t == j || t == j + 2;\n  loop invariant y == 8;\n  loop invariant t <= j + 2;\n  loop invariant t == 8 || t == 10;\n  loop invariant j <= t;\n  loop invariant y >= 0;\n  loop invariant (t == j) || (t == j + 2);\n  loop invariant t >= j;\n  loop assigns t;\n*/\nwhile (y-1>=0) {\n      if (t+3<=j) {\n          t = t+3;\n      }\n      else {\n          t = j;\n      }\n      t = t+2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int q){\n  int w, z, r;\n\n  w=40;\n  z=1;\n  r=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (z<=w-4) {\n      r = r-6;\n      r = r+1;\n      z = z+4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (r == 2) && (z == 1) && (w == 40) && (q == \\at(q, Pre))\n\n2. Loop Code:\n```c\nwhile (z<=w-4) {\n      r = r-6;\n      r = r+1;\n      z = z+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (z at loop-step start <= w at loop-step start - 4). Changed: r: r at loop-step start -> r at loop-step start - 6 + 1; z: z at loop-step start -> z at loop-step start + 4. Unchanged: q keeps q at loop-step start; w keeps w at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['q', 'r', 'w', 'z']\n\n**Function Parameters:**\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int q){\n  int w, z, r;\n\n  w=40;\n  z=1;\n  r=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 4*r + 5*z == 13;\n  loop invariant q == \\at(q, Pre);\n  loop invariant w == 40;\n  loop invariant z >= 1;\n  loop invariant r <= 2;\n  loop invariant (z - 1) % 4 == 0;\n  loop invariant r == 2 - 5 * ((z - 1) / 4);\n  loop invariant 1 <= z;\n  loop invariant z <= w;\n  loop invariant z % 4 == 1;\n  loop invariant 5*(z-1) + 4*(r-2) == 0;\n  loop assigns r, z;\n*/\nwhile (z<=w-4) {\n      r = r-6;\n      r = r+1;\n      z = z+4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p){\n  int q, n, v, l;\n\n  q=p+5;\n  n=0;\n  v=q;\n  l=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (n<=q-1) {\n      if (n<q/2) {\n          v = v+l;\n      }\n      else {\n          v = v+1;\n      }\n      l = l+l;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (l == \\at(p, Pre)) && (v == \\at(p, Pre) + 5) && (n == 0) && (q == \\at(p, Pre) + 5) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (n<=q-1) {\n      if (n<q/2) {\n          v = v+l;\n      }\n      else {\n          v = v+1;\n      }\n      l = l+l;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (n at loop-step start >= q at loop-step start / 2; n at loop-step start <= q at loop-step start - 1; n at loop-step start <= q at loop-step start - 1). Changed: l: l at loop-step start -> l at loop-step start + l at loop-step start; v: v at loop-step start -> v at loop-step start + l at loop-step start. Unchanged: n keeps n at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p){\n  int q, n, v, l;\n\n  q=p+5;\n  n=0;\n  v=q;\n  l=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant q == p + 5;\n  loop invariant n == 0;\n  loop invariant 0 <= n;\n\n\n  loop invariant p == \\at(p, Pre);\n  loop invariant (n < q/2) ==> v - l == 5;\n\n  loop invariant q == \\at(p, Pre) + 5;\n\n\n\n  loop assigns v, l;\n*/\nwhile (n<=q-1) {\n      if (n<q/2) {\n          v = v+l;\n      }\n      else {\n          v = v+1;\n      }\n      l = l+l;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p){\n  int m, c, v;\n\n  m=33;\n  c=1;\n  v=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (c<m) {\n      if (c+3<=m+m) {\n          v = v+v;\n      }\n      c = c+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 1) && (c == 1) && (m == 33) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (c<m) {\n      if (c+3<=m+m) {\n          v = v+v;\n      }\n      c = c+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (c at loop-step start + 3 > m at loop-step start + m at loop-step start; c at loop-step start < m at loop-step start; c at loop-step start < m at loop-step start). Changed: c: c at loop-step start -> c at loop-step start + 1; v: v at loop-step start -> v at loop-step start + v at loop-step start. Unchanged: m keeps m at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p){\n  int m, c, v;\n\n  m=33;\n  c=1;\n  v=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == 33;\n  loop invariant c >= 1;\n  loop invariant c <= m;\n  loop invariant v >= 1;\n  loop invariant p == \\at(p, Pre);\n  loop invariant (c > 1) ==> (v % 2 == 0);\n  loop invariant 1 <= c;\n  loop invariant v >= c;\n\n  loop assigns c, v;\n*/\nwhile (c<m) {\n      if (c+3<=m+m) {\n          v = v+v;\n      }\n      c = c+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a){\n  int z, v, k, o;\n\n  z=60;\n  v=0;\n  k=a;\n  o=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k<z) {\n      if (k<z) {\n          k = k+1;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (o == -3) && (k == \\at(a, Pre)) && (v == 0) && (z == 60) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (k<z) {\n      if (k<z) {\n          k = k+1;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start < z at loop-step start; k at loop-step start < z at loop-step start). Changed: k: k at loop-step start -> k at loop-step start + 1. Unchanged: a keeps a at loop-step start; o keeps o at loop-step start; v keeps v at loop-step start; z keeps z at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'k', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a){\n  int z, v, k, o;\n\n  z=60;\n  v=0;\n  k=a;\n  o=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant z == 60;\n  loop invariant a == \\at(a, Pre);\n  loop invariant k >= a;\n  loop invariant (a < z) ==> (k <= z);\n  loop invariant k >= \\at(a, Pre);\n\n  loop invariant (a <= z) ==> (k <= z);\n\n  loop assigns k;\n*/\nwhile (k<z) {\n      if (k<z) {\n          k = k+1;\n      }\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k){\n  int l, i, r, v;\n\n  l=44;\n  i=2;\n  r=i;\n  v=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<=l-2) {\n      r = r+1;\n      v = v-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -8) && (r == 2) && (i == 2) && (l == 44) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<=l-2) {\n      r = r+1;\n      v = v-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k){\n  int l, i, r, v;\n\n  l=44;\n  i=2;\n  r=i;\n  v=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant r + v == -6;\n  loop invariant i == 2;\n  loop invariant l == 44;\n  loop invariant r >= 2;\n  loop invariant v <= -8;\n  loop invariant k == \\at(k, Pre);\n  loop invariant r - i >= 0;\n  loop invariant i <= l - 1;\n  loop assigns r, v;\n*/\nwhile (i<=l-2) {\n      r = r+1;\n      v = v-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b){\n  int t, j, n;\n\n  t=b;\n  j=0;\n  n=j;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j<t) {\n      n = n+j;\n      j = j+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (n == 0) && (j == 0) && (t == \\at(b, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (j<t) {\n      n = n+j;\n      j = j+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start < t at loop-step start). Changed: j: j at loop-step start -> j at loop-step start + 1; n: n at loop-step start -> n at loop-step start + j at loop-step start. Unchanged: b keeps b at loop-step start; t keeps t at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'j', 'n', 't']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b){\n  int t, j, n;\n\n  t=b;\n  j=0;\n  n=j;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant t == \\at(b, Pre);\n  loop invariant b == \\at(b, Pre);\n  loop invariant n >= 0;\n  loop invariant n == j*(j-1)/2;\n  loop invariant 0 <= j;\n  loop invariant j <= t || t < 0;\n\n\n  loop invariant 2*n == j*(j-1);\n  loop invariant t == b;\n  loop assigns n, j;\n*/\nwhile (j<t) {\n      n = n+j;\n      j = j+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k){\n  int h, o, v, r;\n\n  h=k-9;\n  o=h;\n  v=h;\n  r=o;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<h) {\n      if (v<h) {\n          v = v+1;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (r == \\at(k, Pre) - 9) && (v == \\at(k, Pre) - 9) && (o == \\at(k, Pre) - 9) && (h == \\at(k, Pre) - 9) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (v<h) {\n      if (v<h) {\n          v = v+1;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start < h at loop-step start; v at loop-step start < h at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 1. Unchanged: h keeps h at loop-step start; k keeps k at loop-step start; o keeps o at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['h', 'k', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k){\n  int h, o, v, r;\n\n  h=k-9;\n  o=h;\n  v=h;\n  r=o;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant h == k - 9;\n  loop invariant v <= h;\n  loop invariant k == \\at(k, Pre);\n  loop invariant h == \\at(k, Pre) - 9;\n  loop invariant \\at(k, Pre) - 9 <= v;\n  loop assigns v;\n*/\nwhile (v<h) {\n      if (v<h) {\n          v = v+1;\n      }\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a){\n  int b, u, i;\n\n  b=59;\n  u=0;\n  i=u;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<b) {\n      i = i-i;\n      u = u+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<b) {\n      i = i-i;\n      u = u+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'u']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a){\n  int b, u, i;\n\n  b=59;\n  u=0;\n  i=u;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i == 0;\n  loop invariant 0 <= u;\n  loop invariant u <= b;\n  loop invariant a == \\at(a, Pre);\n  loop invariant 0 <= u <= b;\n  loop invariant b == 59;\n  loop assigns i, u;\n*/\nwhile (u<b) {\n      i = i-i;\n      u = u+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p){\n  int l, k, m;\n\n  l=p+12;\n  k=0;\n  m=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k+1<=l) {\n      m = m+m;\n      k = k+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (m == 1) && (k == 0) && (l == \\at(p, Pre) + 12) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (k+1<=l) {\n      m = m+m;\n      k = k+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start + 1 <= l at loop-step start). Changed: k: k at loop-step start -> k at loop-step start + 1; m: m at loop-step start -> m at loop-step start + m at loop-step start. Unchanged: l keeps l at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'l', 'm', 'p']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p){\n  int l, k, m;\n\n  l=p+12;\n  k=0;\n  m=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant k >= 0;\n  loop invariant l == \\at(p, Pre) + 12;\n  loop invariant p == \\at(p, Pre);\n  loop invariant l == p + 12;\n  loop invariant m >= 1;\n  loop invariant k == 0 || (m % 2 == 0);\n  loop invariant (k > 0) ==> (m % 2 == 0);\n\n\n  loop invariant k == 0 ==> m == 1;\n  loop assigns k, m;\n*/\nwhile (k+1<=l) {\n      m = m+m;\n      k = k+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p){\n  int z, k, s, o;\n\n  z=p;\n  k=z;\n  s=z;\n  o=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<z) {\n      if (s<z) {\n          s = s+1;\n      }\n      s = s+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (o == 8) && (s == \\at(p, Pre)) && (k == \\at(p, Pre)) && (z == \\at(p, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (s<z) {\n      if (s<z) {\n          s = s+1;\n      }\n      s = s+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start < z at loop-step start; s at loop-step start < z at loop-step start). Changed: s: s at loop-step start -> s at loop-step start + 1 + 1. Unchanged: k keeps k at loop-step start; o keeps o at loop-step start; p keeps p at loop-step start; z keeps z at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['p', 's', 'z']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p){\n  int z, k, s, o;\n\n  z=p;\n  k=z;\n  s=z;\n  o=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant z == p;\n  loop invariant p == \\at(p, Pre);\n  loop invariant s <= z;\n  loop invariant ((z - s) % 2) == 0;\n  loop invariant 0 <= z - s;\n  loop invariant s <= z + 1;\n  loop invariant s >= p;\n  loop invariant z == \\at(p, Pre);\n  loop invariant s >= \\at(p, Pre);\n  loop invariant (s - \\at(p, Pre)) % 2 == 0;\n  loop invariant ((s - z) % 2) == 0;\n  loop assigns s;\n*/\nwhile (s<z) {\n      if (s<z) {\n          s = s+1;\n      }\n      s = s+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k){\n  int d, x, l;\n\n  d=68;\n  x=2;\n  l=d;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (x<d) {\n      l = l+x;\n      x = x+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (l == 68) && (x == 2) && (d == 68) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (x<d) {\n      l = l+x;\n      x = x+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (x at loop-step start < d at loop-step start). Changed: l: l at loop-step start -> l at loop-step start + x at loop-step start; x: x at loop-step start -> x at loop-step start + 1. Unchanged: d keeps d at loop-step start; k keeps k at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'k', 'l', 'x']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k){\n  int d, x, l;\n\n  d=68;\n  x=2;\n  l=d;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant d == 68;\n  loop invariant l == 67 + (x*(x - 1))/2;\n  loop invariant k == \\at(k, Pre);\n  loop invariant x >= 2;\n  loop invariant x <= d;\n  loop invariant l == 67 + x*(x-1)/2;\n  loop invariant l == d + ((x-1)*x)/2 - 1;\n  loop invariant 2 <= x;\n  loop invariant l == d + (x - 2) * (x + 1) / 2;\n  loop assigns l, x;\n*/\nwhile (x<d) {\n      l = l+x;\n      x = x+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int q){\n  int w, k, d, r;\n\n  w=q-7;\n  k=w;\n  d=w;\n  r=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (d<w) {\n      if (d<w) {\n          d = d+1;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (r == \\at(q, Pre)) && (d == \\at(q, Pre) - 7) && (k == \\at(q, Pre) - 7) && (w == \\at(q, Pre) - 7) && (q == \\at(q, Pre))\n\n2. Loop Code:\n```c\nwhile (d<w) {\n      if (d<w) {\n          d = d+1;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (d at loop-step start < w at loop-step start; d at loop-step start < w at loop-step start). Changed: d: d at loop-step start -> d at loop-step start + 1. Unchanged: k keeps k at loop-step start; q keeps q at loop-step start; r keeps r at loop-step start; w keeps w at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'q', 'w']\n\n**Function Parameters:**\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int q){\n  int w, k, d, r;\n\n  w=q-7;\n  k=w;\n  d=w;\n  r=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant \\at(q, Pre) - 7 <= d;\n  loop invariant d <= w;\n  loop invariant q == \\at(q, Pre);\n  loop invariant w == \\at(q, Pre) - 7;\n  loop invariant d >= \\at(q, Pre) - 7;\n  loop invariant w == q - 7;\n  loop invariant w - d >= 0;\n  loop invariant q - 7 <= d;\n  loop assigns d;\n*/\nwhile (d<w) {\n      if (d<w) {\n          d = d+1;\n      }\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p){\n  int l, k, r, b;\n\n  l=p+7;\n  k=l;\n  r=l;\n  b=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (r<l) {\n      if (r<l) {\n          r = r+1;\n      }\n      r = r+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (b == \\at(p, Pre) + 7) && (r == \\at(p, Pre) + 7) && (k == \\at(p, Pre) + 7) && (l == \\at(p, Pre) + 7) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (r<l) {\n      if (r<l) {\n          r = r+1;\n      }\n      r = r+2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (r at loop-step start < l at loop-step start; r at loop-step start < l at loop-step start). Changed: r: r at loop-step start -> r at loop-step start + 1 + 2. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; l keeps l at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['l', 'p', 'r']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p){\n  int l, k, r, b;\n\n  l=p+7;\n  k=l;\n  r=l;\n  b=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == p + 7;\n  loop invariant p == \\at(p, Pre);\n  loop invariant r >= p + 7;\n  loop invariant (r - l) % 3 == 0;\n  loop invariant r >= l;\n  loop invariant l == \\at(p,Pre) + 7;\n  loop invariant r >= \\at(p,Pre) + 7;\n  loop invariant (r - (\\at(p,Pre) + 7)) % 3 == 0;\n  loop invariant r <= l + 2;\n  loop assigns r;\n*/\nwhile (r<l) {\n      if (r<l) {\n          r = r+1;\n      }\n      r = r+2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k){\n  int b, y, v, j;\n\n  b=63;\n  y=3;\n  v=y;\n  j=y;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (y+3<=b) {\n      if (v+4<=b) {\n          v = v+4;\n      }\n      else {\n          v = b;\n      }\n      v = v+j+j;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (j == 3) && (v == 3) && (y == 3) && (b == 63) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (y+3<=b) {\n      if (v+4<=b) {\n          v = v+4;\n      }\n      else {\n          v = b;\n      }\n      v = v+j+j;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 4 > b at loop-step start; y at loop-step start + 3 <= b at loop-step start; y at loop-step start + 3 <= b at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 4 + j at loop-step start + j at loop-step start. Unchanged: b keeps b at loop-step start; j keeps j at loop-step start; k keeps k at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'j', 'k', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k){\n  int b, y, v, j;\n\n  b=63;\n  y=3;\n  v=y;\n  j=y;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant j == 3;\n  loop invariant y == 3;\n  loop invariant b == 63;\n  loop invariant k == \\at(k, Pre);\n  loop invariant ((v % 10 == 3 && v <= b) || v == b + 6);\n  loop invariant v <= b + j + j;\n  loop invariant v >= y;\n  loop invariant j == y;\n  loop invariant v <= 69;\n  loop invariant (v - y) % 2 == 0;\n  loop invariant v >= 3 && v <= b + 2*j && (v == b + 2*j || v % 10 == 3);\n  loop assigns v;\n*/\nwhile (y+3<=b) {\n      if (v+4<=b) {\n          v = v+4;\n      }\n      else {\n          v = b;\n      }\n      v = v+j+j;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int p, i, v;\n\n  p=66;\n  i=p;\n  v=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>2) {\n      v = v-v;\n      if (v<m+2) {\n          v = v+1;\n      }\n      i = i-3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -3) && (i == 66) && (p == 66) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i>2) {\n      v = v-v;\n      if (v<m+2) {\n          v = v+1;\n      }\n      i = i-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start - v at loop-step start >= m at loop-step start + 2; i at loop-step start > 2; i at loop-step start > 2). Changed: i: i at loop-step start -> i at loop-step start - 3; v: v at loop-step start -> v at loop-step start - v at loop-step start + 1. Unchanged: m keeps m at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int p, i, v;\n\n  p=66;\n  i=p;\n  v=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i <= 66;\n  loop invariant i >= 0;\n  loop invariant i % 3 == 0;\n  loop invariant v == -3 || v == 0 || v == 1;\n  loop invariant m == \\at(m, Pre);\n  loop invariant p == 66;\n\n  loop invariant 0 <= i;\n  loop invariant i <= p;\n  loop invariant (v == -3) || (v == 0) || (v == 1);\n  loop invariant i % 3 == p % 3;\n  loop invariant (i == 66 && v == -3) || ((m > -2 && v == 1) || (m <= -2 && v == 0));\n  loop assigns v, i;\n*/\nwhile (i>2) {\n      v = v-v;\n      if (v<m+2) {\n          v = v+1;\n      }\n      i = i-3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int q){\n  int h, u, v;\n\n  h=58;\n  u=0;\n  v=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<=h-1) {\n      v = v+u;\n      u = u+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<=h-1) {\n      v = v+u;\n      u = u+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['h', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int q){\n  int h, u, v;\n\n  h=58;\n  u=0;\n  v=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= u;\n  loop invariant u <= h;\n  loop invariant v == -5 + u*(u-1)/2;\n  loop invariant h == 58;\n  loop invariant q == \\at(q, Pre);\n  loop assigns u, v;\n*/\nwhile (u<=h-1) {\n      v = v+u;\n      u = u+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int q){\n  int p, e, t, v;\n\n  p=q;\n  e=0;\n  t=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (1) {\n      if (t+5<=p) {\n          t = t+5;\n      }\n      else {\n          t = p;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == \\at(q, Pre)) && (t == 0) && (e == 0) && (p == \\at(q, Pre)) && (q == \\at(q, Pre))\n\n2. Loop Code:\n```c\nwhile (1) {\n      if (t+5<=p) {\n          t = t+5;\n      }\n      else {\n          t = p;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start + 5 <= p at loop-step start). Changed: t: t at loop-step start -> p at loop-step start. Unchanged: e keeps e at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['p', 'q', 't']\n\n**Function Parameters:**\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int q){\n  int p, e, t, v;\n\n  p=q;\n  e=0;\n  t=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant p == q;\n  loop invariant ((p >= 0) ==> (t <= p)) && ((p < 0) ==> (t <= 0));\n  loop invariant t == p || t % 5 == 0;\n\n  loop invariant q == \\at(q, Pre);\n\n  loop invariant ((t == p) || (t % 5 == 0)) && (q == \\at(q, Pre));\n  loop invariant p == \\at(q, Pre);\n  loop invariant (t == p) || (t == 0) || (0 <= t && t % 5 == 0 && t <= p);\n  loop assigns t;\n*/\nwhile (1) {\n      if (t+5<=p) {\n          t = t+5;\n      }\n      else {\n          t = p;\n      }\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int w, q, x;\n\n  w=38;\n  q=0;\n  x=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (q<w) {\n      x = x+q;\n      x = x-x;\n      q = q+5;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (x == 0) && (q == 0) && (w == 38) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (q<w) {\n      x = x+q;\n      x = x-x;\n      q = q+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (q at loop-step start < w at loop-step start). Changed: q: q at loop-step start -> q at loop-step start + 5; x: x at loop-step start -> x at loop-step start + q at loop-step start - (x at loop-step start + q at loop-step start. Unchanged: m keeps m at loop-step start; w keeps w at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['m', 'q', 'w', 'x']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int w, q, x;\n\n  w=38;\n  q=0;\n  x=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant x == 0;\n  loop invariant q % 5 == 0;\n  loop invariant q >= 0;\n  loop invariant q <= w + 4;\n  loop invariant m == \\at(m, Pre);\n  loop invariant 0 <= q;\n  loop invariant w == 38;\n  loop assigns x, q;\n*/\nwhile (q<w) {\n      x = x+q;\n      x = x-x;\n      q = q+5;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k){\n  int n, g, i;\n\n  n=10;\n  g=n;\n  i=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (g>0) {\n      i = i+1;\n      g = g-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (i == \\at(k, Pre)) && (g == 10) && (n == 10) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (g>0) {\n      i = i+1;\n      g = g-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (g at loop-step start > 0). Changed: g: g at loop-step start -> g at loop-step start - 1; i: i at loop-step start -> i at loop-step start + 1. Unchanged: k keeps k at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['g', 'i', 'k', 'n']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k){\n  int n, g, i;\n\n  n=10;\n  g=n;\n  i=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i == \\at(k, Pre) + (n - g);\n  loop invariant g >= 0;\n  loop invariant g <= n;\n  loop invariant k == \\at(k, Pre);\n  loop invariant i + g == k + 10;\n  loop invariant i >= k;\n  loop invariant i + g == \\at(k, Pre) + 10;\n  loop invariant i <= \\at(k, Pre) + 10;\n  loop invariant i + g == \\at(k, Pre) + n;\n  loop invariant 0 <= g;\n  loop invariant \\at(k, Pre) <= i;\n  loop invariant i <= \\at(k, Pre) + n;\n  loop invariant n == 10;\n  loop invariant g <= 10;\n  loop invariant i - k >= 0;\n  loop invariant i - k <= 10;\n  loop assigns i, g;\n*/\nwhile (g>0) {\n      i = i+1;\n      g = g-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n){\n  int j, t, q, v;\n\n  j=n+3;\n  t=0;\n  q=t;\n  v=t;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t<=j-3) {\n      v = v+v;\n      v = v+q;\n      t = t+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 0) && (q == 0) && (t == 0) && (j == \\at(n, Pre) + 3) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (t<=j-3) {\n      v = v+v;\n      v = v+q;\n      t = t+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start <= j at loop-step start - 3). Changed: t: t at loop-step start -> t at loop-step start + 3; v: v at loop-step start -> v at loop-step start + v at loop-step start + q at loop-step start. Unchanged: j keeps j at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['j', 'n', 'q', 't', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n){\n  int j, t, q, v;\n\n  j=n+3;\n  t=0;\n  q=t;\n  v=t;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant j == \\at(n, Pre) + 3;\n  loop invariant q == 0;\n  loop invariant v == 0;\n  loop invariant t % 3 == 0;\n  loop invariant t >= 0;\n  loop invariant (t % 3 == 0);\n  loop invariant t >= 0 && (t <= j || t == 0) && j == \\at(n, Pre) + 3 && n == \\at(n, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant j == n + 3;\n\n  loop assigns t, v;\n*/\nwhile (t<=j-3) {\n      v = v+v;\n      v = v+q;\n      t = t+3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int i, g, o, x;\n\n  i=20;\n  g=i;\n  o=g;\n  x=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (g>2) {\n      o = o+4;\n      x = x+o;\n      g = g-3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (x == 1) && (o == 20) && (g == 20) && (i == 20) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (g>2) {\n      o = o+4;\n      x = x+o;\n      g = g-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (g at loop-step start > 2). Changed: g: g at loop-step start -> g at loop-step start - 3; o: o at loop-step start -> o at loop-step start + 4; x: x at loop-step start -> x at loop-step start + (o at loop-step start + 4. Unchanged: i keeps i at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['g', 'i', 'm', 'o', 'x']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int i, g, o, x;\n\n  i=20;\n  g=i;\n  o=g;\n  x=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 3*o + 4*g == 140;\n  loop invariant 9*(x - 1) == 2*g*g - 146*g + 2120;\n  loop invariant g >= 2;\n  loop invariant g <= 20;\n  loop invariant m == \\at(m, Pre);\n  loop invariant o % 4 == 0;\n  loop invariant g % 3 == 2;\n  loop invariant i == 20;\n  loop invariant o >= 20;\n  loop invariant 8*(x-1) == (o-20)*(o+24);\n  loop invariant 3*(o - 20) == 4*(20 - g);\n  loop invariant 9*x == 9 + 66*(20 - g) + 2*(20 - g)*(20 - g);\n  loop invariant (g - 2) % 3 == 0;\n  loop assigns o, x, g;\n*/\nwhile (g>2) {\n      o = o+4;\n      x = x+o;\n      g = g-3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n){\n  int r, o, a;\n\n  r=35;\n  o=0;\n  a=o;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (o<r) {\n      a = a+a;\n      a = a+5;\n      o = o+4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (a == 0) && (o == 0) && (r == 35) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (o<r) {\n      a = a+a;\n      a = a+5;\n      o = o+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (o at loop-step start < r at loop-step start). Changed: a: a at loop-step start -> a at loop-step start + a at loop-step start + 5; o: o at loop-step start -> o at loop-step start + 4. Unchanged: n keeps n at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'n', 'o', 'r']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n){\n  int r, o, a;\n\n  r=35;\n  o=0;\n  a=o;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant o % 4 == 0;\n\n  loop invariant r == 35;\n  loop invariant a >= 0;\n  loop invariant n == \\at(n, Pre);\n  loop invariant a % 5 == 0;\n  loop invariant 0 <= o;\n  loop invariant o <= r + 3;\n  loop invariant 0 <= a;\n  loop invariant o >= 0;\n  loop invariant a >= (5*o)/4;\n\n  loop assigns a, o;\n*/\nwhile (o<r) {\n      a = a+a;\n      a = a+5;\n      o = o+4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b){\n  int a, u, g;\n\n  a=10;\n  u=a;\n  g=u;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u>2) {\n      g = g+g;\n      u = u-3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (g == 10) && (u == 10) && (a == 10) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (u>2) {\n      g = g+g;\n      u = u-3;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'g', 'u']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b){\n  int a, u, g;\n\n  a=10;\n  u=a;\n  g=u;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant a == 10;\n  loop invariant b == \\at(b, Pre);\n  loop invariant u <= 10;\n  loop invariant (10 - u) % 3 == 0;\n  loop invariant u % 3 == 1;\n  loop invariant 1 <= u;\n  loop invariant u <= a;\n  loop invariant g >= a;\n  loop invariant g >= u;\n  loop invariant u >= 1;\n  loop invariant g >= 10;\n  loop invariant g % 10 == 0;\n  loop assigns g, u;\n*/\nwhile (u>2) {\n      g = g+g;\n      u = u-3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k){\n  int t, m, z;\n\n  t=78;\n  m=0;\n  z=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (m<=t-5) {\n      z = z+m;\n      m = m+5;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (z == 6) && (m == 0) && (t == 78) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (m<=t-5) {\n      z = z+m;\n      m = m+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (m at loop-step start <= t at loop-step start - 5). Changed: m: m at loop-step start -> m at loop-step start + 5; z: z at loop-step start -> z at loop-step start + m at loop-step start. Unchanged: k keeps k at loop-step start; t keeps t at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'm', 't', 'z']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k){\n  int t, m, z;\n\n  t=78;\n  m=0;\n  z=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant t == 78;\n  loop invariant k == \\at(k, Pre);\n  loop invariant m % 5 == 0;\n\n  loop invariant 10*z == m*m - 5*m + 60;\n  loop invariant z >= 6;\n  loop invariant z == 6 + m*(m-5)/10;\n  loop invariant m <= t;\n  loop invariant m >= 0;\n\n  loop invariant z == 6 + (m*m - 5*m)/10;\n  loop invariant z == 6 + (m*(m - 5))/10;\n  loop invariant 10*(z - 6) == m*(m - 5);\n  loop assigns z, m;\n*/\nwhile (m<=t-5) {\n      z = z+m;\n      m = m+5;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n){\n  int r, j, v;\n\n  r=n;\n  j=4;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j<r) {\n      if ((j%9)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+1;\n      }\n      j = j+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == \\at(n, Pre)) && (j == 4) && (r == \\at(n, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (j<r) {\n      if ((j%9)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+1;\n      }\n      j = j+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start % 9 != 0; j at loop-step start < r at loop-step start; j at loop-step start < r at loop-step start). Changed: j: j at loop-step start -> j at loop-step start + 1; v: v at loop-step start -> v at loop-step start - v at loop-step start. Unchanged: n keeps n at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['j', 'n', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n){\n  int r, j, v;\n\n  r=n;\n  j=4;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant j >= 4;\n  loop invariant r == \\at(n, Pre);\n  loop invariant j <= r || r < 4;\n  loop invariant v <= \\at(n, Pre) + (j - 4);\n  loop invariant n == \\at(n, Pre);\n  loop invariant j <= r || j == 4;\n  loop invariant ( \\at(n, Pre) >= 0 ==> v <= \\at(n, Pre) + (j - 4) )\n                   && ( \\at(n, Pre) < 0  ==> v <= j - 4 );\n\n  loop invariant 0 <= j % 9;\n  loop invariant j % 9 < 9;\n  loop assigns v, j;\n*/\nwhile (j<r) {\n      if ((j%9)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+1;\n      }\n      j = j+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int k, y, v, r;\n\n  k=74;\n  y=k;\n  v=-8;\n  r=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<k) {\n      if (v<k) {\n          v = v+1;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (r == \\at(m, Pre)) && (v == -8) && (y == 74) && (k == 74) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (v<k) {\n      if (v<k) {\n          v = v+1;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start < k at loop-step start; v at loop-step start < k at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 1. Unchanged: k keeps k at loop-step start; m keeps m at loop-step start; r keeps r at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int k, y, v, r;\n\n  k=74;\n  y=k;\n  v=-8;\n  r=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v <= k;\n  loop invariant v >= -8;\n  loop invariant k == 74;\n  loop invariant m == \\at(m, Pre);\n  loop invariant v <= k && (v < k ==> v + 1 <= k) && v >= -8;\n  loop invariant -8 <= v;\n  loop assigns v;\n*/\nwhile (v<k) {\n      if (v<k) {\n          v = v+1;\n      }\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n){\n  int l, d, x;\n\n  l=68;\n  d=0;\n  x=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (d<l) {\n      x = n+(-4);\n      d = d+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (x == 68) && (d == 0) && (l == 68) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (d<l) {\n      x = n+(-4);\n      d = d+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (d at loop-step start < l at loop-step start). Changed: d: d at loop-step start -> d at loop-step start + 1; x: x at loop-step start -> n at loop-step start + -4. Unchanged: l keeps l at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'l', 'n', 'x']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n){\n  int l, d, x;\n\n  l=68;\n  d=0;\n  x=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= d;\n  loop invariant d <= l;\n  loop invariant n == \\at(n, Pre);\n  loop invariant (d==0 ==> x==68) && (d>0 ==> x == n - 4);\n  loop invariant l == 68;\n  loop invariant (d == 0) ==> (x == l);\n  loop invariant (d > 0) ==> (x == n - 4);\n  loop invariant 0 <= d <= l;\n  loop invariant (d == 0 && x == 68) || (d > 0 && x == n - 4);\n  loop invariant l == 68 && d >= 0 && d <= l && (d > 0 ==> x == n - 4) && (d == 0 ==> x == 68);\n  loop invariant (d == 0) ==> (x == 68);\n  loop assigns x, d;\n*/\nwhile (d<l) {\n      x = n+(-4);\n      d = d+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int q){\n  int e, r, k, s;\n\n  e=q+11;\n  r=3;\n  k=q;\n  s=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (r+1<=e) {\n      if (k+2<=e) {\n          k = k+2;\n      }\n      else {\n          k = e;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == 5) && (k == \\at(q, Pre)) && (r == 3) && (e == \\at(q, Pre) + 11) && (q == \\at(q, Pre))\n\n2. Loop Code:\n```c\nwhile (r+1<=e) {\n      if (k+2<=e) {\n          k = k+2;\n      }\n      else {\n          k = e;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start + 2 <= e at loop-step start; r at loop-step start + 1 <= e at loop-step start; r at loop-step start + 1 <= e at loop-step start). Changed: k: k at loop-step start -> e at loop-step start. Unchanged: e keeps e at loop-step start; q keeps q at loop-step start; r keeps r at loop-step start; s keeps s at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'k', 'q', 'r']\n\n**Function Parameters:**\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int q){\n  int e, r, k, s;\n\n  e=q+11;\n  r=3;\n  k=q;\n  s=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant e == \\at(q, Pre) + 11;\n  loop invariant k <= e;\n  loop invariant k >= \\at(q, Pre);\n  loop invariant r == 3;\n  loop invariant q == \\at(q, Pre);\n  loop invariant e == q + 11;\n  loop invariant q <= k;\n  loop invariant ((k - q) % 2 == 0) || (k == e);\n  loop invariant \\at(q, Pre) <= k;\n  loop invariant k >= q;\n  loop assigns k;\n*/\nwhile (r+1<=e) {\n      if (k+2<=e) {\n          k = k+2;\n      }\n      else {\n          k = e;\n      }\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a){\n  int b, d, s;\n\n  b=61;\n  d=b;\n  s=d;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (d>2) {\n      s = s-s;\n      d = d-3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == 61) && (d == 61) && (b == 61) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (d>2) {\n      s = s-s;\n      d = d-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (d at loop-step start > 2). Changed: d: d at loop-step start -> d at loop-step start - 3; s: s at loop-step start -> s at loop-step start - s at loop-step start. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'd', 's']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a){\n  int b, d, s;\n\n  b=61;\n  d=b;\n  s=d;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant d % 3 == 1;\n  loop invariant 1 <= d;\n  loop invariant d <= 61;\n  loop invariant s == 0 || s == 61;\n  loop invariant b == 61;\n  loop invariant a == \\at(a, Pre);\n  loop invariant d >= 1;\n  loop invariant a == \\at(a, Pre) &&\n                 d <= 61 &&\n                 d >= 1 &&\n                 d % 3 == 1;\n  loop invariant 0 <= d;\n  loop assigns s, d;\n*/\nwhile (d>2) {\n      s = s-s;\n      d = d-3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int b, k, j, v;\n\n  b=m;\n  k=0;\n  j=m;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j<b) {\n      if (j<b) {\n          j = j+1;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == \\at(m, Pre)) && (j == \\at(m, Pre)) && (k == 0) && (b == \\at(m, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (j<b) {\n      if (j<b) {\n          j = j+1;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start < b at loop-step start; j at loop-step start < b at loop-step start). Changed: j: j at loop-step start -> j at loop-step start + 1. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; m keeps m at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'j', 'm']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int b, k, j, v;\n\n  b=m;\n  k=0;\n  j=m;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == \\at(m,Pre);\n  loop invariant b == \\at(m,Pre);\n  loop invariant j <= b;\n  loop invariant b == m;\n  loop invariant j >= m;\n  loop invariant j >= \\at(m, Pre);\n  loop assigns j;\n*/\nwhile (j<b) {\n      if (j<b) {\n          j = j+1;\n      }\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b){\n  int r, m, v, z;\n\n  r=b-1;\n  m=r;\n  v=r;\n  z=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<r) {\n      if (v<r) {\n          v = v+1;\n      }\n      v = v+z+z;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (z == \\at(b, Pre) - 1) && (v == \\at(b, Pre) - 1) && (m == \\at(b, Pre) - 1) && (r == \\at(b, Pre) - 1) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (v<r) {\n      if (v<r) {\n          v = v+1;\n      }\n      v = v+z+z;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start < r at loop-step start; v at loop-step start < r at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 1 + z at loop-step start + z at loop-step start. Unchanged: b keeps b at loop-step start; m keeps m at loop-step start; r keeps r at loop-step start; z keeps z at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'r', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b){\n  int r, m, v, z;\n\n  r=b-1;\n  m=r;\n  v=r;\n  z=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant r == \\at(b, Pre) - 1;\n  loop invariant z == r;\n  loop invariant (1 + 2*r) != 0 ==> (v - r) % (1 + 2*r) == 0;\n  loop invariant r == b - 1;\n  loop invariant v <= r;\n  loop invariant z == b - 1;\n  loop invariant v >= r;\n  loop invariant (v - r) % (1 + 2 * z) == 0;\n  loop invariant (v - r) % (1 + 2*r) == 0;\n  loop assigns v;\n*/\nwhile (v<r) {\n      if (v<r) {\n          v = v+1;\n      }\n      v = v+z+z;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b){\n  int o, r, v;\n\n  o=b+20;\n  r=o;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (r-1>=0) {\n      v = v-v;\n      r = r-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 4) && (r == \\at(b, Pre) + 20) && (o == \\at(b, Pre) + 20) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (r-1>=0) {\n      v = v-v;\n      r = r-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (r at loop-step start - 1 >= 0). Changed: r: r at loop-step start -> r at loop-step start - 1; v: v at loop-step start -> v at loop-step start - v at loop-step start. Unchanged: b keeps b at loop-step start; o keeps o at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'o', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b){\n  int o, r, v;\n\n  o=b+20;\n  r=o;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant o == b + 20;\n\n  loop invariant r <= o;\n  loop invariant v >= 0;\n  loop invariant v <= 4;\n  loop invariant b == \\at(b, Pre);\n  loop invariant o == \\at(b, Pre) + 20;\n  loop invariant (v == 0) || (v == 4);\n  loop invariant v == 0 || v == 4;\n  loop invariant (r < o) ==> (v == 0);\n  loop assigns r, v;\n*/\nwhile (r-1>=0) {\n      v = v-v;\n      r = r-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m){\n  int e, v, r;\n\n  e=30;\n  v=e;\n  r=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v>3) {\n      r = r+1;\n      v = v-4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (r == 1) && (v == 30) && (e == 30) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (v>3) {\n      r = r+1;\n      v = v-4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start > 3). Changed: r: r at loop-step start -> r at loop-step start + 1; v: v at loop-step start -> v at loop-step start - 4. Unchanged: e keeps e at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'm', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m){\n  int e, v, r;\n\n  e=30;\n  v=e;\n  r=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v + 4*r == 34;\n  loop invariant e == 30;\n  loop invariant m == \\at(m, Pre);\n  loop invariant r <= 8;\n  loop invariant v >= 2;\n  loop invariant v == 34 - 4*r;\n  loop invariant r >= 1;\n  loop invariant v >= 0;\n  loop invariant v <= e;\n  loop invariant v + 4*(r - 1) == e;\n  loop assigns r, v;\n*/\nwhile (v>3) {\n      r = r+1;\n      v = v-4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int q){\n  int h, c, v;\n\n  h=35;\n  c=2;\n  v=h;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (c<=h-1) {\n      if (c+7<=h+h) {\n          v = v+1;\n      }\n      c = c+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 35) && (c == 2) && (h == 35) && (q == \\at(q, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (c<=h-1) {\n      if (c+7<=h+h) {\n          v = v+1;\n      }\n      c = c+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (c at loop-step start + 7 > h at loop-step start + h at loop-step start; c at loop-step start <= h at loop-step start - 1; c at loop-step start <= h at loop-step start - 1). Changed: c: c at loop-step start -> c at loop-step start + 1; v: v at loop-step start -> v at loop-step start + 1. Unchanged: a keeps a at loop-step start; h keeps h at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'h', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int q){\n  int h, c, v;\n\n  h=35;\n  c=2;\n  v=h;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == h + c - 2;\n  loop invariant a == \\at(a, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant c <= h;\n  loop invariant v - h == c - 2;\n  loop invariant c >= 2;\n  loop invariant v == c + 33;\n  loop invariant 2 <= c;\n  loop invariant h >= 6;\n  loop invariant v <= h + c - 2;\n  loop invariant v >= h;\n  loop invariant h == 35;\n  loop assigns v, c;\n*/\nwhile (c<=h-1) {\n      if (c+7<=h+h) {\n          v = v+1;\n      }\n      c = c+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k){\n  int i, u, f;\n\n  i=b;\n  u=0;\n  f=u;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<=i-2) {\n      if (u+2<=u+i) {\n          f = f+f;\n      }\n      f = f+2;\n      f = f+5;\n      u = u+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<=i-2) {\n      if (u+2<=u+i) {\n          f = f+f;\n      }\n      f = f+2;\n      f = f+5;\n      u = u+2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'f', 'i', 'k', 'u']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k){\n  int i, u, f;\n\n  i=b;\n  u=0;\n  f=u;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant 2*f >= 7*u;\n  loop invariant f >= 0;\n  loop invariant i == b;\n  loop invariant u % 2 == 0;\n  loop invariant u >= 0;\n  loop invariant f >= u;\n  loop invariant i == \\at(b, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant f >= 7*(u/2);\n  loop invariant \\at(b, Pre) < 2 ==> f == 7*(u/2);\n  loop invariant 0 <= u;\n  loop invariant b == \\at(b, Pre);\n  loop invariant (i < 2) ==> (2*f == 7*u);\n  loop assigns f, u;\n*/\nwhile (u<=i-2) {\n      if (u+2<=u+i) {\n          f = f+f;\n      }\n      f = f+2;\n      f = f+5;\n      u = u+2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k){\n  int y, j, n, q, v;\n\n  y=40;\n  j=0;\n  n=j;\n  q=4;\n  v=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j<=y-5) {\n      n = n+1;\n      q = q-1;\n      n = v-n;\n      j = j+5;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -4) && (q == 4) && (n == 0) && (j == 0) && (y == 40) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (j<=y-5) {\n      n = n+1;\n      q = q-1;\n      n = v-n;\n      j = j+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start <= y at loop-step start - 5). Changed: j: j at loop-step start -> j at loop-step start + 5; n: n at loop-step start -> v at loop-step start - (n at loop-step start + 1; q: q at loop-step start -> q at loop-step start - 1. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; v keeps v at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'j', 'k', 'n', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k){\n  int y, j, n, q, v;\n\n  y=40;\n  j=0;\n  n=j;\n  q=4;\n  v=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant j % 5 == 0;\n  loop invariant 0 <= j;\n  loop invariant j <= y;\n  loop invariant q == 4 - j/5 && ((q % 2 == 0) ==> n == 0) && ((q % 2 != 0) ==> n == -5) && b == \\at(b,Pre) && k == \\at(k,Pre);\n  loop invariant 5*q + j == 20;\n  loop invariant n == 0 || n == -5;\n  loop invariant b == \\at(b, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant v == -4;\n  loop invariant 0 <= j <= y;\n  loop invariant n == 0 || n == v - 1;\n  loop invariant q >= -4;\n  loop invariant q <= 4;\n  loop invariant q == 4 - (j/5);\n  loop invariant ((j/5) % 2 == 0) ==> (n == 0);\n  loop invariant y == 40;\n  loop assigns n, q, j;\n*/\nwhile (j<=y-5) {\n      n = n+1;\n      q = q-1;\n      n = v-n;\n      j = j+5;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k){\n  int n, j, s, w;\n\n  n=(k%25)+11;\n  j=n;\n  s=n;\n  w=j;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<n) {\n      if (s<n) {\n          s = s+1;\n      }\n      w = w+w;\n      w = w+s;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (w == \\at(k, Pre) % 25 + 11) && (s == \\at(k, Pre) % 25 + 11) && (j == \\at(k, Pre) % 25 + 11) && (n == \\at(k, Pre) % 25 + 11) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s<n) {\n      if (s<n) {\n          s = s+1;\n      }\n      w = w+w;\n      w = w+s;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start < n at loop-step start; s at loop-step start < n at loop-step start). Changed: s: s at loop-step start -> s at loop-step start + 1; w: w at loop-step start -> w at loop-step start + w at loop-step start + (s at loop-step start + 1. Unchanged: b keeps b at loop-step start; j keeps j at loop-step start; k keeps k at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'n', 's', 'w']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k){\n  int n, j, s, w;\n\n  n=(k%25)+11;\n  j=n;\n  s=n;\n  w=j;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant n == (\\at(k, Pre) % 25) + 11;\n  loop invariant s <= n;\n  loop invariant (s == n) ==> (w == n);\n\n  loop invariant n == (k%25) + 11;\n  loop invariant w >= s;\n  loop invariant b == \\at(b, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant w >= n;\n  loop invariant s >= \\at(k, Pre) % 25 + 11;\n  loop invariant w >= \\at(k, Pre) % 25 + 11;\n  loop assigns s, w;\n*/\nwhile (s<n) {\n      if (s<n) {\n          s = s+1;\n      }\n      w = w+w;\n      w = w+s;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int q){\n  int c, x, b, v, g;\n\n  c=60;\n  x=0;\n  b=q;\n  v=-6;\n  g=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (x<c) {\n      b = b+2;\n      v = v+b;\n      x = x+5;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (g == 60) && (v == -6) && (b == \\at(q, Pre)) && (x == 0) && (c == 60) && (q == \\at(q, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (x<c) {\n      b = b+2;\n      v = v+b;\n      x = x+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (x at loop-step start < c at loop-step start). Changed: b: b at loop-step start -> b at loop-step start + 2; v: v at loop-step start -> v at loop-step start + (b at loop-step start + 2; x: x at loop-step start -> x at loop-step start + 5. Unchanged: c keeps c at loop-step start; g keeps g at loop-step start; m keeps m at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'm', 'q', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int q){\n  int c, x, b, v, g;\n\n  c=60;\n  x=0;\n  b=q;\n  v=-6;\n  g=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == \\at(m, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant b == q + 2*(x/5);\n  loop invariant x <= c;\n  loop invariant x % 5 == 0;\n  loop invariant c == 60;\n  loop invariant 2*x == 5*(b - q);\n  loop invariant x >= 0;\n  loop invariant b >= q;\n  loop invariant 5*b - 2*x == 5*q;\n  loop invariant v == -6 + ((b - q)/2)*q + ((b - q)/2)*(((b - q)/2) + 1);\n  loop invariant 0 <= x;\n  loop invariant 5*(b - q) == 2*x;\n  loop invariant x*x + 5*x + 5*q*x - 25*v - 150 == 0;\n  loop invariant v == (x/5)*q + (x/5)*((x/5)+1) - 6;\n  loop assigns b, v, x;\n*/\nwhile (x<c) {\n      b = b+2;\n      v = v+b;\n      x = x+5;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int m, c, w;\n\n  m=33;\n  c=1;\n  w=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (c<m) {\n      w = w+w;\n      w = w-w;\n      c = c+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (w == 1) && (c == 1) && (m == 33) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (c<m) {\n      w = w+w;\n      w = w-w;\n      c = c+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (c at loop-step start < m at loop-step start). Changed: c: c at loop-step start -> c at loop-step start + 1; w: w at loop-step start -> w at loop-step start + w at loop-step start - (w at loop-step start + w at loop-step start. Unchanged: m keeps m at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'm', 'p', 'q', 'w']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int m, c, w;\n\n  m=33;\n  c=1;\n  w=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == 33;\n  loop invariant (1 <= c);\n  loop invariant (c <= m);\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant (c == 1) ==> (w == 1) && (c != 1) ==> (w == 0);\n  loop invariant (c == 1) ==> (w == 1);\n  loop invariant c <= m;\n  loop invariant 1 <= c;\n  loop invariant (m == 33);\n  loop invariant (1 <= c && c <= m);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant ((c == 1) ==> (w == 1));\n  loop assigns w, c;\n*/\nwhile (c<m) {\n      w = w+w;\n      w = w-w;\n      c = c+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int l, i, u, v;\n\n  l=51;\n  i=l;\n  u=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>3) {\n      u = u+4;\n      i = i-4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (i>3) {\n      u = u+4;\n      i = i-4;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'n', 'q', 'u']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int l, i, u, v;\n\n  l=51;\n  i=l;\n  u=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant u + i == l;\n  loop invariant i % 4 == l % 4;\n  loop invariant i >= 0;\n  loop invariant u >= 0;\n  loop invariant i + u == l;\n  loop invariant i >= 3;\n  loop invariant 0 <= u;\n  loop invariant u <= l;\n  loop invariant q == \\at(q, Pre);\n  loop invariant i % 4 == 3;\n  loop invariant n == \\at(n, Pre);\n  loop invariant (i + u == l);\n  loop invariant (u >= 0);\n  loop invariant (i % 4 == 3);\n  loop invariant (l == 51);\n  loop invariant (i <= l);\n  loop invariant (i + u) == 51;\n  loop invariant (0 <= u);\n  loop invariant (u <= 48);\n  loop invariant ((i % 4) == 3);\n  loop assigns i, u;\n*/\nwhile (i>3) {\n      u = u+4;\n      i = i-4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int m, k, x, v;\n\n  m=(q%6)+4;\n  k=0;\n  x=k;\n  v=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k+3<=m) {\n      if (k<m/2) {\n          x = x+v;\n      }\n      else {\n          x = x+1;\n      }\n      v = v+v;\n      v = v+x;\n      x = x+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 8) && (x == 0) && (k == 0) && (m == \\at(q, Pre) % 6 + 4) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (k+3<=m) {\n      if (k<m/2) {\n          x = x+v;\n      }\n      else {\n          x = x+1;\n      }\n      v = v+v;\n      v = v+x;\n      x = x+2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start >= m at loop-step start / 2; k at loop-step start + 3 <= m at loop-step start; k at loop-step start + 3 <= m at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + v at loop-step start + (x at loop-step start + v at loop-step start; x: x at loop-step start -> x at loop-step start + v at loop-step start + 2. Unchanged: k keeps k at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'm', 'n', 'q', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int m, k, x, v;\n\n  m=(q%6)+4;\n  k=0;\n  x=k;\n  v=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant k == 0;\n  loop invariant m == ((\\at(q, Pre) % 6) + 4);\n  loop invariant x >= 0;\n  loop invariant v >= 8;\n  loop invariant v >= x;\n\n  loop invariant m == (\\at(q, Pre) % 6) + 4;\n  loop invariant q == \\at(q, Pre);\n  loop invariant n == \\at(n, Pre);\n\n  loop invariant m == (q % 6) + 4;\n  loop invariant v >= x + 2;\n\n  loop invariant m == \\at(q, Pre) % 6 + 4;\n  loop invariant (x + v) % 2 == 0;\n  loop assigns x, v;\n*/\nwhile (k+3<=m) {\n      if (k<m/2) {\n          x = x+v;\n      }\n      else {\n          x = x+1;\n      }\n      v = v+v;\n      v = v+x;\n      x = x+2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (k == -6) && (s == 0) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start < l at loop-step start). Changed: k: k at loop-step start -> k at loop-step start - k at loop-step start + -3; s: s at loop-step start -> s at loop-step start + 1. Unchanged: b keeps b at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant k == -3 || (s == 0 && k == -6);\n  loop invariant 0 <= s;\n  loop invariant s <= l;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant l == 35;\n  loop invariant (s > 0) ==> (k == -3);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre));\n  loop assigns k, s;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n){\n  int c, q, l;\n\n  c=65;\n  q=c;\n  l=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (q>=2) {\n      l = l+q;\n      l = l-l;\n      q = q-2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (l == 65) && (q == 65) && (c == 65) && (n == \\at(n, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (q>=2) {\n      l = l+q;\n      l = l-l;\n      q = q-2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (q at loop-step start >= 2). Changed: l: l at loop-step start -> l at loop-step start + q at loop-step start - (l at loop-step start + q at loop-step start; q: q at loop-step start -> q at loop-step start - 2. Unchanged: c keeps c at loop-step start; k keeps k at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'k', 'l', 'n', 'q']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n){\n  int c, q, l;\n\n  c=65;\n  q=c;\n  l=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 65 || l == 0;\n  loop invariant q % 2 == 1;\n  loop invariant k == \\at(k, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant c == 65;\n  loop invariant 0 <= q;\n  loop invariant q <= c;\n  loop invariant 0 <= q <= c;\n  loop invariant q % 2 == c % 2;\n  loop assigns l, q;\n*/\nwhile (q>=2) {\n      l = l+q;\n      l = l-l;\n      q = q-2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p){\n  int x, u, w;\n\n  x=65;\n  u=x;\n  w=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u>0) {\n      if ((u%4)==0) {\n          w = w+1;\n      }\n      u = u-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (w == \\at(p, Pre)) && (u == 65) && (x == 65) && (p == \\at(p, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (u>0) {\n      if ((u%4)==0) {\n          w = w+1;\n      }\n      u = u-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['n', 'p', 'u', 'w', 'x']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p){\n  int x, u, w;\n\n  x=65;\n  u=x;\n  w=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant w == p + 16 - u/4;\n  loop invariant p == \\at(p, Pre);\n  loop invariant x == 65;\n  loop invariant 0 <= u;\n  loop invariant u <= 65;\n  loop invariant w == \\at(p, Pre) + 65/4 - u/4;\n  loop invariant u <= x;\n  loop invariant w >= p;\n  loop invariant w <= p + x/4;\n  loop invariant w == \\at(p, Pre) + 16 - u/4;\n  loop assigns w, u;\n*/\nwhile (u>0) {\n      if ((u%4)==0) {\n          w = w+1;\n      }\n      u = u-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int r, f, v;\n\n  r=q+19;\n  f=0;\n  v=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (f+3<=r) {\n      v = v-v;\n      v = v+f;\n      if (f+4<=v+r) {\n          v = v+1;\n      }\n      f = f+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 5) && (f == 0) && (r == \\at(q, Pre) + 19) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (f+3<=r) {\n      v = v-v;\n      v = v+f;\n      if (f+4<=v+r) {\n          v = v+1;\n      }\n      f = f+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (f at loop-step start + 4 > v at loop-step start - v at loop-step start + f at loop-step start + r at loop-step start; f at loop-step start + 3 <= r at loop-step start; f at loop-step start + 3 <= r at loop-step start). Changed: f: f at loop-step start -> f at loop-step start + 3; v: v at loop-step start -> v at loop-step start - v at loop-step start + f at loop-step start + 1. Unchanged: n keeps n at loop-step start; q keeps q at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['f', 'n', 'q', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int r, f, v;\n\n  r=q+19;\n  f=0;\n  v=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant r == \\at(q, Pre) + 19;\n  loop invariant q == \\at(q, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant f >= 0;\n  loop invariant v >= 0;\n\n\n  loop invariant r == q + 19;\n  loop invariant (f % 3 == 0) && (0 <= f) && (v >= 0) && ((v - f) == 5 || (v - f) == -2 || (v - f) == -3);\n\n  loop invariant (f == 0 ==> v == 5) && (f != 0 ==> (f - v == 2 || f - v == 3));\n  loop invariant f % 3 == 0;\n  loop invariant (f == 0 && v == 5) || (f >= 3 && (r >= 4 ==> v == f - 2) && (r < 4 ==> v == f - 3));\n  loop assigns f, v;\n*/\nwhile (f+3<=r) {\n      v = v-v;\n      v = v+f;\n      if (f+4<=v+r) {\n          v = v+1;\n      }\n      f = f+3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n){\n  int r, w, b, y;\n\n  r=(k%21)+13;\n  w=1;\n  b=-2;\n  y=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (b<r) {\n      if (b<r) {\n          b = b+1;\n      }\n      b = b+5;\n      y = y+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (y == 4) && (b == -2) && (w == 1) && (r == \\at(k, Pre) % 21 + 13) && (n == \\at(n, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (b<r) {\n      if (b<r) {\n          b = b+1;\n      }\n      b = b+5;\n      y = y+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (b at loop-step start < r at loop-step start; b at loop-step start < r at loop-step start). Changed: b: b at loop-step start -> b at loop-step start + 1 + 5; y: y at loop-step start -> y at loop-step start + 3. Unchanged: k keeps k at loop-step start; n keeps n at loop-step start; r keeps r at loop-step start; w keeps w at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'n', 'r', 'y']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n){\n  int r, w, b, y;\n\n  r=(k%21)+13;\n  w=1;\n  b=-2;\n  y=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 2*(y - 4) == b + 2;\n  loop invariant b >= -2;\n  loop invariant b <= r + 5;\n  loop invariant y >= 4;\n  loop invariant r == (\\at(k, Pre) % 21) + 13;\n  loop invariant b + 2 == 2*(y - 4);\n  loop invariant (y - 4) % 3 == 0;\n  loop invariant k == \\at(k,Pre);\n  loop invariant n == \\at(n,Pre);\n  loop invariant (b + 2) % 6 == 0;\n  loop invariant r == (k % 21) + 13;\n  loop invariant b - 2*y == -10;\n  loop invariant b == 2*y - 10;\n\n  loop assigns b, y;\n*/\nwhile (b<r) {\n      if (b<r) {\n          b = b+1;\n      }\n      b = b+5;\n      y = y+3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int z, v, j, i;\n\n  z=44;\n  v=0;\n  j=5;\n  i=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j<z) {\n      if (j<z) {\n          j = j+1;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (i == -6) && (j == 5) && (v == 0) && (z == 44) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (j<z) {\n      if (j<z) {\n          j = j+1;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start < z at loop-step start; j at loop-step start < z at loop-step start). Changed: j: j at loop-step start -> j at loop-step start + 1. Unchanged: i keeps i at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start; v keeps v at loop-step start; z keeps z at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['j', 'n', 'q', 'z']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int z, v, j, i;\n\n  z=44;\n  v=0;\n  j=5;\n  i=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant z == 44;\n  loop invariant n == \\at(n, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant j <= z;\n  loop invariant j >= 5;\n  loop invariant 5 <= j;\n  loop invariant z - j >= 0;\n  loop assigns j;\n*/\nwhile (j<z) {\n      if (j<z) {\n          j = j+1;\n      }\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int k, j, p, d, w;\n\n  k=14;\n  j=k;\n  p=-8;\n  d=b;\n  w=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (p<k) {\n      if (p<k) {\n          p = p+1;\n      }\n      p = p+1;\n      d = d+p;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (w == -2) && (d == \\at(b, Pre)) && (p == -8) && (j == 14) && (k == 14) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (p<k) {\n      if (p<k) {\n          p = p+1;\n      }\n      p = p+1;\n      d = d+p;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (p at loop-step start < k at loop-step start; p at loop-step start < k at loop-step start). Changed: d: d at loop-step start -> d at loop-step start + (p at loop-step start + 1 + 1; p: p at loop-step start -> p at loop-step start + 1 + 1. Unchanged: b keeps b at loop-step start; j keeps j at loop-step start; k keeps k at loop-step start; m keeps m at loop-step start; w keeps w at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'k', 'm', 'p']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m){\n  int k, j, p, d, w;\n\n  k=14;\n  j=k;\n  p=-8;\n  d=b;\n  w=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 4*d == 4*b + (p + 8) * (p - 6);\n  loop invariant p <= k;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant d == \\at(b, Pre) + ((p + 8)/2) * (((p + 8)/2) - 7) &&\n                     p >= -8 &&\n                     ((p + 8) % 2) == 0 &&\n                     p <= k;\n  loop invariant k == 14;\n  loop invariant p >= -8;\n  loop invariant 4*d - p*p - 2*p == 4*\\at(b, Pre) - 48;\n  loop invariant p <= k + 1;\n  loop invariant 4*d == p*p + 2*p + 4*\\at(b, Pre) - 48;\n  loop invariant (p % 2) == 0;\n  loop assigns p, d;\n*/\nwhile (p<k) {\n      if (p<k) {\n          p = p+1;\n      }\n      p = p+1;\n      d = d+p;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int q){\n  int b, i, v, y;\n\n  b=k;\n  i=0;\n  v=4;\n  y=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<=b-1) {\n      v = v+y+y;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (y == \\at(k, Pre)) && (v == 4) && (i == 0) && (b == \\at(k, Pre)) && (q == \\at(q, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<=b-1) {\n      v = v+y+y;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start <= b at loop-step start - 1). Changed: i: i at loop-step start -> i at loop-step start + 1; v: v at loop-step start -> v at loop-step start + y at loop-step start + y at loop-step start + 1. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; q keeps q at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int q){\n  int b, i, v, y;\n\n  b=k;\n  i=0;\n  v=4;\n  y=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant k == \\at(k, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant b == \\at(k, Pre);\n  loop invariant y == \\at(k, Pre);\n  loop invariant 0 <= i && (i <= b || b < 0);\n  loop invariant v == 4 + i*(2*y + 1);\n\n  loop invariant i >= 0;\n\n  loop invariant b == k;\n  loop invariant y == k;\n  loop invariant 0 <= i;\n  loop assigns i, v;\n*/\nwhile (i<=b-1) {\n      v = v+y+y;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int a, i, v;\n\n  a=m;\n  i=a;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>=2) {\n      if (i+4<=v+a) {\n          v = v+v;\n      }\n      else {\n          v = v+i;\n      }\n      v = i;\n      i = i-2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == \\at(m, Pre)) && (i == \\at(m, Pre)) && (a == \\at(m, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>=2) {\n      if (i+4<=v+a) {\n          v = v+v;\n      }\n      else {\n          v = v+i;\n      }\n      v = i;\n      i = i-2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start + 4 <= v at loop-step start + a at loop-step start; i at loop-step start >= 2; i at loop-step start >= 2). Changed: i: i at loop-step start -> i at loop-step start - 2; v: v at loop-step start -> i at loop-step start. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m){\n  int a, i, v;\n\n  a=m;\n  i=a;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == \\at(m, Pre);\n  loop invariant b == \\at(b, Pre);\n  loop invariant i <= a;\n  loop invariant (v == i) || (v == i + 2);\n  loop invariant v <= a;\n  loop invariant a == \\at(m, Pre);\n  loop invariant i % 2 == a % 2;\n  loop invariant v == i || v == i + 2;\n\n  loop invariant a == m;\n  loop invariant v >= i;\n  loop invariant i % 2 == v % 2;\n  loop invariant v <= i + 2;\n  loop assigns v, i;\n*/\nwhile (i>=2) {\n      if (i+4<=v+a) {\n          v = v+v;\n      }\n      else {\n          v = v+i;\n      }\n      v = i;\n      i = i-2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p){\n  int m, j, q;\n\n  m=34;\n  j=m;\n  q=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j>2) {\n      q = q+q;\n      j = j-3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (q == 34) && (j == 34) && (m == 34) && (p == \\at(p, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (j>2) {\n      q = q+q;\n      j = j-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start > 2). Changed: j: j at loop-step start -> j at loop-step start - 3; q: q at loop-step start -> q at loop-step start + q at loop-step start. Unchanged: m keeps m at loop-step start; n keeps n at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['j', 'm', 'n', 'p', 'q']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p){\n  int m, j, q;\n\n  m=34;\n  j=m;\n  q=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == 34;\n  loop invariant n == \\at(n, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant j <= 34;\n  loop invariant j >= 1;\n  loop invariant (j % 3) == 1;\n\n  loop invariant j <= m;\n  loop invariant (m - j) % 3 == 0;\n  loop invariant j % 3 == 1;\n  loop invariant q % 34 == 0;\n  loop invariant q >= 34;\n\n  loop assigns j, q;\n*/\nwhile (j>2) {\n      q = q+q;\n      j = j-3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int o, g, i;\n\n  o=10;\n  g=o;\n  i=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (g>0) {\n      i = i+1;\n      g = g-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (i == \\at(m, Pre)) && (g == 10) && (o == 10) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (g>0) {\n      i = i+1;\n      g = g-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (g at loop-step start > 0). Changed: g: g at loop-step start -> g at loop-step start - 1; i: i at loop-step start -> i at loop-step start + 1. Unchanged: k keeps k at loop-step start; m keeps m at loop-step start; o keeps o at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['g', 'i', 'k', 'm', 'o']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int o, g, i;\n\n  o=10;\n  g=o;\n  i=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i + g == \\at(m, Pre) + 10;\n  loop invariant 0 <= g;\n  loop invariant g <= 10;\n  loop invariant m == \\at(m, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant g + i == m + 10;\n  loop invariant i >= m;\n  loop invariant o == 10;\n  loop invariant g >= 0;\n  loop invariant \\at(m, Pre) <= i;\n  loop invariant i <= \\at(m, Pre) + 10;\n  loop invariant i >= \\at(m, Pre);\n  loop invariant (g + i - m) == 10;\n  loop invariant i <= m + 10;\n  loop assigns i, g;\n*/\nwhile (g>0) {\n      i = i+1;\n      g = g-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int q){\n  int w, v, o, l, r;\n\n  w=m+8;\n  v=w;\n  o=0;\n  l=6;\n  r=w;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v-2>=0) {\n      if (v<w/2) {\n          o = o+l;\n      }\n      else {\n          o = o+1;\n      }\n      l = l+r;\n      r = r+o;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (v-2>=0) {\n      if (v<w/2) {\n          o = o+l;\n      }\n      else {\n          o = o+1;\n      }\n      l = l+r;\n      r = r+o;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['l', 'm', 'o', 'q', 'r', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int q){\n  int w, v, o, l, r;\n\n  w=m+8;\n  v=w;\n  o=0;\n  l=6;\n  r=w;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == \\at(m, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant w == \\at(m, Pre) + 8;\n  loop invariant v == w;\n  loop invariant w == m + 8;\n  loop invariant (w >= 0) ==> o >= 0;\n  loop invariant (w >= 0) ==> l >= 6;\n  loop invariant (w >= 0) ==> r >= w;\n  loop assigns o, l, r;\n*/\nwhile (v-2>=0) {\n      if (v<w/2) {\n          o = o+l;\n      }\n      else {\n          o = o+1;\n      }\n      l = l+r;\n      r = r+o;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int y, t, v;\n\n  y=m+7;\n  t=3;\n  v=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t<=y-3) {\n      v = v+t;\n      v = v-v;\n      t = t+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 3) && (t == 3) && (y == \\at(m, Pre) + 7) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (t<=y-3) {\n      v = v+t;\n      v = v-v;\n      t = t+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start <= y at loop-step start - 3). Changed: t: t at loop-step start -> t at loop-step start + 3; v: v at loop-step start -> v at loop-step start + t at loop-step start - (v at loop-step start + t at loop-step start. Unchanged: b keeps b at loop-step start; m keeps m at loop-step start; y keeps y at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'm', 't', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m){\n  int y, t, v;\n\n  y=m+7;\n  t=3;\n  v=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == 0 || v == 3;\n  loop invariant t >= 3;\n  loop invariant (t - 3) % 3 == 0;\n  loop invariant y == \\at(m, Pre) + 7;\n  loop invariant m == \\at(m, Pre);\n  loop invariant b == \\at(b, Pre);\n  loop invariant t % 3 == 0;\n  loop invariant (v == 0 || v == 3) && (v >= 0) && (v <= 3);\n  loop invariant t % 3 == 0 && t >= 3 && (v == 0 || (t == 3 && v == 3));\n  loop invariant y == \\at(m, Pre) + 7 &&\n                   m == \\at(m, Pre) &&\n                   b == \\at(b, Pre) &&\n                   t >= 3 &&\n                   (t - 3) % 3 == 0 &&\n                   (v == 0 || v == 3);\n  loop invariant t == 3 || t <= y;\n  loop invariant y == m + 7;\n  loop invariant (t != 3) ==> (v == 0);\n  loop assigns t, v;\n*/\nwhile (t<=y-3) {\n      v = v+t;\n      v = v-v;\n      t = t+3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n){\n  int r, u, g, v;\n\n  r=(k%34)+7;\n  u=0;\n  g=6;\n  v=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u+1<=r) {\n      g = g+3;\n      v = v+g;\n      v = v+v;\n      u = u+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u+1<=r) {\n      g = g+3;\n      v = v+g;\n      v = v+v;\n      u = u+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['g', 'k', 'n', 'r', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n){\n  int r, u, g, v;\n\n  r=(k%34)+7;\n  u=0;\n  g=6;\n  v=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant g == 3*u + 6;\n  loop invariant v >= 3;\n\n  loop invariant (u == 0 ==> v == 3) && (u >= 1 ==> (v % 2) == 0);\n  loop invariant k == \\at(k, Pre);\n  loop invariant n == \\at(n, Pre);\n\n  loop invariant u >= 0;\n  loop invariant r == (k % 34) + 7;\n  loop assigns g, v, u;\n*/\nwhile (u+1<=r) {\n      g = g+3;\n      v = v+g;\n      v = v+v;\n      u = u+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p){\n  int l, t, w, v;\n\n  l=39;\n  t=0;\n  w=l;\n  v=t;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t<=l-1) {\n      w = w+1;\n      v = v+w;\n      v = v+1;\n      t = t+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 0) && (w == 39) && (t == 0) && (l == 39) && (p == \\at(p, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (t<=l-1) {\n      w = w+1;\n      v = v+w;\n      v = v+1;\n      t = t+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'l', 'p', 't', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p){\n  int l, t, w, v;\n\n  l=39;\n  t=0;\n  w=l;\n  v=t;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= t;\n  loop invariant t <= l;\n  loop invariant w == 39 + t;\n  loop invariant v == t*41 + (t*(t-1))/2;\n  loop invariant a == \\at(a, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant v == 40*t + (t*(t+1))/2;\n  loop invariant w == l + t;\n  loop invariant v == (l+1)*t + t*(t+1)/2;\n  loop invariant t >= 0;\n  loop invariant l == 39;\n  loop invariant 2*v == t*t + 81*t;\n  loop invariant 0 <= t <= l;\n  loop invariant v == t*(l+2) + t*(t-1)/2;\n  loop assigns w, v, t;\n*/\nwhile (t<=l-1) {\n      w = w+1;\n      v = v+w;\n      v = v+1;\n      t = t+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int p){\n  int n, t, u;\n\n  n=(b%8)+9;\n  t=0;\n  u=t;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (n>=n) {\n      t = t;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (u == 0) && (t == 0) && (n == \\at(b, Pre) % 8 + 9) && (p == \\at(p, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (n>=n) {\n      t = t;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (n at loop-step start >= n at loop-step start). Unchanged: b keeps b at loop-step start; n keeps n at loop-step start; p keeps p at loop-step start; t keeps t at loop-step start; u keeps u at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'n', 'p', 't']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int p){\n  int n, t, u;\n\n  n=(b%8)+9;\n  t=0;\n  u=t;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant t == 0;\n  loop invariant n == \\at(b, Pre) % 8 + 9;\n  loop invariant b == \\at(b, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant n == (\\at(b,Pre) % 8) + 9;\n  loop invariant n == (b % 8) + 9;\n  loop invariant 2 <= n;\n  loop invariant n <= 16;\n  loop assigns t;\n*/\nwhile (n>=n) {\n      t = t;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int r, w, v, u;\n\n  r=(n%8)+8;\n  w=0;\n  v=-5;\n  u=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (w<=r-1) {\n      v = v+u+u;\n      v = v+1;\n      w = w+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (w<=r-1) {\n      v = v+u+u;\n      v = v+1;\n      w = w+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['m', 'n', 'r', 'u', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int r, w, v, u;\n\n  r=(n%8)+8;\n  w=0;\n  v=-5;\n  u=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == -5 + (2*u + 1) * w;\n  loop invariant 0 <= w;\n  loop invariant w <= r;\n  loop invariant r == (n % 8) + 8;\n  loop invariant u == 4;\n  loop invariant m == \\at(m, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant v == -5 + w * (2 * u + 1);\n  loop invariant v == -5 + 9*w;\n  loop invariant w >= 0;\n  loop assigns v, w;\n*/\nwhile (w<=r-1) {\n      v = v+u+u;\n      v = v+1;\n      w = w+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int e, w, u, k, f;\n\n  e=17;\n  w=e;\n  u=e;\n  k=p;\n  f=e;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (w>3) {\n      u = u+1;\n      f = f+4;\n      w = w-4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (f == 17) && (k == \\at(p, Pre)) && (u == 17) && (w == 17) && (e == 17) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (w>3) {\n      u = u+1;\n      f = f+4;\n      w = w-4;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'f', 'p', 'q', 'u', 'w']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int e, w, u, k, f;\n\n  e=17;\n  w=e;\n  u=e;\n  k=p;\n  f=e;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant w + 4*u == 85;\n  loop invariant u >= 17;\n\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant p == \\at(p, Pre) &&\n                   q == \\at(q, Pre) &&\n                   u >= 17 &&\n                   f >= 17 &&\n                   w <= 17 &&\n                   w + f == 34 &&\n                   w == 17 - 4*(u - 17) &&\n                   ((17 - w) % 4) == 0;\n  loop invariant w >= 1;\n  loop invariant w <= 17;\n  loop invariant f >= 17;\n  loop assigns u, f, w;\n*/\nwhile (w>3) {\n      u = u+1;\n      f = f+4;\n      w = w-4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k){\n  int l, u, g;\n\n  l=50;\n  u=l;\n  g=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u>0) {\n      g = g+u;\n      u = u-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (g == \\at(a, Pre)) && (u == 50) && (l == 50) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (u>0) {\n      g = g+u;\n      u = u-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'g', 'k', 'l', 'u']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k){\n  int l, u, g;\n\n  l=50;\n  u=l;\n  g=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant g == \\at(a, Pre) + (50 - u) * (51 + u) / 2;\n  loop invariant l == 50;\n  loop invariant 0 <= u <= l;\n  loop invariant g == a + (l - u) * (l + u + 1) / 2;\n  loop invariant a == \\at(a, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant g == (\\at(a, Pre) + (50*51)/2 - u*(u+1)/2);\n  loop invariant 0 <= u;\n  loop invariant u <= 50;\n  loop invariant g == a + 1275 - u*(u+1)/2;\n  loop invariant (l == 50);\n  loop invariant (0 <= u);\n  loop invariant (u <= 50);\n  loop invariant (k == \\at(k, Pre));\n  loop invariant g == \\at(a, Pre) + 1275 - (u*(u+1))/2;\n  loop invariant u >= 0;\n  loop assigns g, u;\n*/\nwhile (u>0) {\n      g = g+u;\n      u = u-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b){\n  int t, w, x;\n\n  t=24;\n  w=0;\n  x=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (w<t) {\n      if (t<b+4) {\n          x = x+x;\n      }\n      w = w+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (x == 1) && (w == 0) && (t == 24) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (w<t) {\n      if (t<b+4) {\n          x = x+x;\n      }\n      w = w+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start >= b at loop-step start + 4; w at loop-step start < t at loop-step start; w at loop-step start < t at loop-step start). Changed: w: w at loop-step start -> w at loop-step start + 3; x: x at loop-step start -> x at loop-step start + x at loop-step start. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; t keeps t at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 't', 'w', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b){\n  int t, w, x;\n\n  t=24;\n  w=0;\n  x=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant t == 24;\n  loop invariant a == \\at(a, Pre);\n  loop invariant b == \\at(b, Pre);\n  loop invariant w <= t;\n  loop invariant w % 3 == 0;\n  loop invariant x >= 1;\n  loop invariant 0 <= w;\n  loop invariant w <= t + 2;\n  loop invariant x >= 1 && (t >= b+4 ==> x == 1);\n  loop invariant (t >= b+4) ==> (x == 1);\n  loop invariant w >= 0;\n  loop assigns w, x;\n*/\nwhile (w<t) {\n      if (t<b+4) {\n          x = x+x;\n      }\n      w = w+3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p){\n  int h, o, v, l, g;\n\n  h=44;\n  o=0;\n  v=3;\n  l=h;\n  g=o;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (o+3<=h) {\n      v = v+1;\n      l = l+v;\n      if (h<a+5) {\n          l = l+6;\n      }\n      o = o+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (g == 0) && (l == 44) && (v == 3) && (o == 0) && (h == 44) && (p == \\at(p, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (o+3<=h) {\n      v = v+1;\n      l = l+v;\n      if (h<a+5) {\n          l = l+6;\n      }\n      o = o+3;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'h', 'l', 'o', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p){\n  int h, o, v, l, g;\n\n  h=44;\n  o=0;\n  v=3;\n  l=h;\n  g=o;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 3*v == 9 + o;\n  loop invariant 0 <= o;\n  loop invariant o <= h;\n  loop invariant (h < a+5) ==> l == 44 + 3*(v-3) + (v-3)*(v-2)/2 + 6*(v-3);\n  loop invariant (h >= a+5) ==> l == 44 + 3*(v-3) + (v-3)*(v-2)/2;\n  loop invariant a == \\at(a, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant o % 3 == 0;\n  loop invariant o >= 0;\n  loop invariant o == 3*(v - 3);\n  loop invariant 3 * v == o + 9;\n  loop invariant l >= 44;\n  loop invariant o == 3*v - 9;\n  loop invariant v >= 3;\n  loop invariant h == 44;\n  loop assigns v, l, o;\n*/\nwhile (o+3<=h) {\n      v = v+1;\n      l = l+v;\n      if (h<a+5) {\n          l = l+6;\n      }\n      o = o+3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int l, t, v, b;\n\n  l=52;\n  t=0;\n  v=2;\n  b=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t<=l-1) {\n      v = v+4;\n      b = b+3;\n      t = t+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (b == -2) && (v == 2) && (t == 0) && (l == 52) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (t<=l-1) {\n      v = v+4;\n      b = b+3;\n      t = t+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 't', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int l, t, v, b;\n\n  l=52;\n  t=0;\n  v=2;\n  b=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant t <= l;\n  loop invariant v == 2 + 4*t;\n  loop invariant b == -2 + 3*t;\n  loop invariant l == 52;\n  loop invariant k == \\at(k, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant t >= 0;\n  loop assigns v, b, t;\n*/\nwhile (t<=l-1) {\n      v = v+4;\n      b = b+3;\n      t = t+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int r, c, w;\n\n  r=32;\n  c=0;\n  w=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (c<=r-1) {\n      w = w-w;\n      w = w+4;\n      c = c+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (w == 0) && (c == 0) && (r == 32) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (c<=r-1) {\n      w = w-w;\n      w = w+4;\n      c = c+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (c at loop-step start <= r at loop-step start - 1). Changed: c: c at loop-step start -> c at loop-step start + 1; w: w at loop-step start -> w at loop-step start - w at loop-step start + 4. Unchanged: n keeps n at loop-step start; q keeps q at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'n', 'q', 'r', 'w']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int r, c, w;\n\n  r=32;\n  c=0;\n  w=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant n == \\at(n, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant r == 32;\n  loop invariant 0 <= c;\n  loop invariant c <= r;\n  loop invariant c == 0 ==> w == 0;\n  loop invariant c >= 0;\n  loop assigns c, w;\n*/\nwhile (c<=r-1) {\n      w = w-w;\n      w = w+4;\n      c = c+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -1) && (b == 0) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (b at loop-step start + 4 > v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start) || b at loop-step start + 4 <= v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start; 2). Changed: b: b at loop-step start -> b at loop-step start + 1; v: v at loop-step start -> (v at loop-step start. Unchanged: i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v+1<=i) {\n      v = v+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 1 <= i at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   (-1 && -1 + -1) && 2 + 1 <= 53 && 0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2 + 1) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v-1>=0) {\n      v = v-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start - 1 >= 0). Changed: v: v at loop-step start -> v at loop-step start - 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (b <= i) && (0 <= b) && (v == -1 || v == 0);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant b <= i;\n  loop invariant v >= -1;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant 0 <= b;\n  loop invariant i == 53;\n  loop invariant -1 <= v;\n  loop assigns b, v;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant v <= i;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= -1;\n  loop invariant i == 53;\n\n  loop assigns v;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (0 <= v);\n  loop invariant (v <= i);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= 0;\n  loop invariant v <= i;\n  loop invariant i == 53;\n  loop invariant 0 <= v;\n  loop assigns v;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (k == -6) && (s == 0) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start < l at loop-step start). Changed: k: k at loop-step start -> k at loop-step start - k at loop-step start + -3; s: s at loop-step start -> s at loop-step start + 1. Unchanged: b keeps b at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 < 35 && (k == -6 - -6 + -3) && (s == 0 + 1) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s>=3) {\n      s = s-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start >= 3). Changed: s: s at loop-step start -> s at loop-step start - 3. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   emp\n\n2. Loop Code:\n```c\nwhile (s<=k-1) {\n      s = s+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant k <= -3;\n  loop invariant 0 <= s;\n  loop invariant k == -6 || k == -3;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l && ((s == 0) ==> (k == -6)) && ((s > 0) ==> (k == -3)));\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant s >= 0;\n  loop invariant s <= l && (k == -6 || k == -3) && l == 35 && b == \\at(b, Pre) && m == \\at(m, Pre);\n  loop assigns k, s;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant (s % 3) == (l % 3);\n  loop invariant 0 <= s;\n  loop invariant s <= l;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n\n  loop assigns s;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant k == -3;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant 0 <= s;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35);\n  loop invariant s >= 0;\n\n  loop assigns s;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int x, z, s;\n\n  x=40;\n  z=1;\n  s=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (z<=x/3) {\n      z = z*3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == 4) && (z == 1) && (x == 40) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (z<=x/3) {\n      z = z*3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (z at loop-step start <= x at loop-step start / 3; 3). Unchanged: p keeps p at loop-step start; q keeps q at loop-step start; s keeps s at loop-step start; x keeps x at loop-step start; z keeps z at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['p', 'q', 'x', 'z']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int x, z, s;\n\n  x=40;\n  z=1;\n  s=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant z >= 1;\n  loop invariant z <= x;\n  loop invariant z == 1 || z % 3 == 0;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant x == 40;\n  loop invariant (z == 1) || (z % 3 == 0);\n  loop invariant z > 0;\n  loop invariant z >= 1 && (z == 1 || z % 3 == 0) && z <= 3*(x/3);\n  loop assigns z;\n*/\nwhile (z<=x/3) {\n      z = z*3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k){\n  int n, j, s, w;\n\n  n=(k%25)+11;\n  j=n;\n  s=n;\n  w=j;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<n) {\n      if (s<n) {\n          s = s+1;\n      }\n      s = s*s+s;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (w == \\at(k, Pre) % 25 + 11) && (s == \\at(k, Pre) % 25 + 11) && (j == \\at(k, Pre) % 25 + 11) && (n == \\at(k, Pre) % 25 + 11) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s<n) {\n      if (s<n) {\n          s = s+1;\n      }\n      s = s*s+s;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start < n at loop-step start; s at loop-step start < n at loop-step start; s at loop-step start + 1) + (s at loop-step start + 1). Changed: s: s at loop-step start -> (s at loop-step start + 1. Unchanged: b keeps b at loop-step start; j keeps j at loop-step start; k keeps k at loop-step start; n keeps n at loop-step start; w keeps w at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'n', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k){\n  int n, j, s, w;\n\n  n=(k%25)+11;\n  j=n;\n  s=n;\n  w=j;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant n == (\\at(k, Pre) % 25) + 11;\n  loop invariant k == \\at(k, Pre);\n  loop invariant b == \\at(b, Pre);\n\n  loop invariant s == n || s >= n*(n+1);\n  loop invariant n == \\at(k, Pre) % 25 + 11;\n  loop invariant s <= n;\n  loop invariant s >= \\at(k, Pre) % 25 + 11;\n  loop invariant b == \\at(b, Pre) &&\n                   k == \\at(k, Pre) &&\n                   n == (\\at(k, Pre) % 25) + 11 &&\n                   s <= n;\n  loop invariant n == (k % 25) + 11;\n\n  loop assigns s;\n*/\nwhile (s<n) {\n      if (s<n) {\n          s = s+1;\n      }\n      s = s*s+s;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int q){\n  int t, v, i, w;\n\n  t=42;\n  v=t;\n  i=-5;\n  w=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v-1>=0) {\n      if (i+1<=t) {\n          i = i+1;\n      }\n      else {\n          i = t;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (w == \\at(q, Pre)) && (i == -5) && (v == 42) && (t == 42) && (q == \\at(q, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (v-1>=0) {\n      if (i+1<=t) {\n          i = i+1;\n      }\n      else {\n          i = t;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start + 1 > t at loop-step start; v at loop-step start - 1 >= 0; v at loop-step start - 1 >= 0). Changed: i: i at loop-step start -> i at loop-step start + 1 + 1. Unchanged: a keeps a at loop-step start; q keeps q at loop-step start; t keeps t at loop-step start; v keeps v at loop-step start; w keeps w at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'q', 't', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int q){\n  int t, v, i, w;\n\n  t=42;\n  v=t;\n  i=-5;\n  w=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant t == 42;\n  loop invariant v == 42;\n  loop invariant q == \\at(q, Pre);\n  loop invariant a == \\at(a, Pre);\n  loop invariant i >= -5;\n  loop invariant i <= t + 1;\n  loop invariant v == t;\n  loop invariant (i + 5) % 2 == 0;\n  loop invariant v >= 1;\n  loop assigns i;\n*/\nwhile (v-1>=0) {\n      if (i+1<=t) {\n          i = i+1;\n      }\n      else {\n          i = t;\n      }\n      i = i+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      b = b+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -1) && (b == 0) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (b<=i-1) {\n      v = v*v+v;\n      b = b+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start). Changed: b: b at loop-step start -> b at loop-step start + 1. Unchanged: i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == -1 || v == 0;\n  loop invariant 0 <= b;\n  loop invariant b <= i;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant i == 53;\n  loop invariant (b == 0 && v == -1) || (b >= 1 && v == 0);\n  loop invariant (b == 0 ==> v == -1) && (b >= 1 ==> v == 0);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant ((b == 0 && v == -1) || (b >= 1 && v == 0));\n  loop assigns b, v;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      b = b+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int m, k, x, v;\n\n  m=(q%6)+4;\n  k=0;\n  x=k;\n  v=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k+3<=m) {\n      if (k<m/2) {\n          x = x+v;\n      }\n      else {\n          x = x+1;\n      }\n      v = v+v;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 8) && (x == 0) && (k == 0) && (m == \\at(q, Pre) % 6 + 4) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (k+3<=m) {\n      if (k<m/2) {\n          x = x+v;\n      }\n      else {\n          x = x+1;\n      }\n      v = v+v;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start >= m at loop-step start / 2; k at loop-step start + 3 <= m at loop-step start; k at loop-step start + 3 <= m at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + v at loop-step start; x: x at loop-step start -> x at loop-step start + v at loop-step start. Unchanged: k keeps k at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'm', 'n', 'q', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int m, k, x, v;\n\n  m=(q%6)+4;\n  k=0;\n  x=k;\n  v=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant k == 0;\n  loop invariant m == (\\at(q,Pre) % 6) + 4;\n  loop invariant x == v - 8;\n  loop invariant v >= 8;\n  loop invariant n == \\at(n,Pre);\n  loop invariant q == \\at(q,Pre);\n  loop invariant (k < m/2 ==> x == v - 8) && v >= 8 && v % 8 == 0;\n\n\n  loop invariant m == (q % 6) + 4;\n  loop invariant v > 0;\n  loop invariant x >= 0;\n\n  loop assigns x, v;\n*/\nwhile (k+3<=m) {\n      if (k<m/2) {\n          x = x+v;\n      }\n      else {\n          x = x+1;\n      }\n      v = v+v;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k){\n  int d, m, p, s;\n\n  d=k;\n  m=2;\n  p=k;\n  s=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (p<d) {\n      if (p<d) {\n          p = p+1;\n      }\n      p = p+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == \\at(b, Pre)) && (p == \\at(k, Pre)) && (m == 2) && (d == \\at(k, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (p<d) {\n      if (p<d) {\n          p = p+1;\n      }\n      p = p+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (p at loop-step start < d at loop-step start; p at loop-step start < d at loop-step start). Changed: p: p at loop-step start -> p at loop-step start + 1 + 1. Unchanged: b keeps b at loop-step start; d keeps d at loop-step start; k keeps k at loop-step start; m keeps m at loop-step start; s keeps s at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'k', 'p']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k){\n  int d, m, p, s;\n\n  d=k;\n  m=2;\n  p=k;\n  s=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant d == k;\n  loop invariant b == \\at(b, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant p >= k;\n  loop invariant p <= d;\n  loop invariant p >= d;\n  loop invariant (p - d) % 2 == 0;\n  loop invariant p % 2 == k % 2;\n  loop invariant p <= d + 1;\n  loop assigns p;\n*/\nwhile (p<d) {\n      if (p<d) {\n          p = p+1;\n      }\n      p = p+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n){\n  int s, p, c;\n\n  s=39;\n  p=s+2;\n  c=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (p>=1) {\n      c = c*c+c;\n      c = c%9;\n      p = p/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (c == 5) && (p == 39 + 2) && (s == 39) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (p>=1) {\n      c = c*c+c;\n      c = c%9;\n      p = p/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (p at loop-step start >= 1; c at loop-step start + c at loop-step start) % 9). Changed: c: c at loop-step start -> (c at loop-step start; p: p at loop-step start -> p at loop-step start / 2. Unchanged: b keeps b at loop-step start; n keeps n at loop-step start; s keeps s at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'n', 'p', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n){\n  int s, p, c;\n\n  s=39;\n  p=s+2;\n  c=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant s == 39;\n  loop invariant 0 <= p <= 41;\n  loop invariant 0 <= c < 9;\n  loop invariant b == \\at(b, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant p >= 0;\n  loop invariant 0 <= p;\n  loop invariant p <= 41;\n  loop invariant 0 <= c && c <= 8 && (c % 3 == 0 || c % 3 == 2);\n  loop invariant p <= s + 2;\n  loop invariant 0 <= c;\n  loop invariant c <= 8;\n  loop invariant c == 3 || c == 5;\n  loop assigns c, p;\n*/\nwhile (p>=1) {\n      c = c*c+c;\n      c = c%9;\n      p = p/2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int p){\n  int g, l, m, v;\n\n  g=54;\n  l=g;\n  m=l;\n  v=g;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (m<g) {\n      if (m<g) {\n          m = m+1;\n      }\n      m = m+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 54) && (m == 54) && (l == 54) && (g == 54) && (p == \\at(p, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (m<g) {\n      if (m<g) {\n          m = m+1;\n      }\n      m = m+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (m at loop-step start < g at loop-step start; m at loop-step start < g at loop-step start). Changed: m: m at loop-step start -> m at loop-step start + 1 + 1. Unchanged: g keeps g at loop-step start; k keeps k at loop-step start; l keeps l at loop-step start; p keeps p at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['g', 'k', 'm', 'p']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int p){\n  int g, l, m, v;\n\n  g=54;\n  l=g;\n  m=l;\n  v=g;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m <= g + 1;\n  loop invariant ((m - g) % 2 == 0);\n  loop invariant k == \\at(k, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant m >= 54;\n  loop invariant g == 54;\n  loop invariant (m - g) % 2 == 0;\n  loop invariant (g - m) % 2 == 0;\n  loop invariant m <= g;\n  loop invariant m % 2 == 0;\n  loop assigns m;\n*/\nwhile (m<g) {\n      if (m<g) {\n          m = m+1;\n      }\n      m = m+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int q){\n  int h, t, n;\n\n  h=27;\n  t=h;\n  n=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t>=1) {\n      n = n*n;\n      t = t-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (n == \\at(q, Pre)) && (t == 27) && (h == 27) && (q == \\at(q, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (t>=1) {\n      n = n*n;\n      t = t-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start >= 1; n at loop-step start). Changed: t: t at loop-step start -> t at loop-step start - 1. Unchanged: a keeps a at loop-step start; h keeps h at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'h', 'n', 'q', 't']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int q){\n  int h, t, n;\n\n  h=27;\n  t=h;\n  n=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant a == \\at(a, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant t >= 0;\n  loop invariant t <= 27;\n  loop invariant h == 27;\n  loop invariant 0 <= t <= 27;\n  loop invariant 0 <= t;\n  loop invariant t <= h;\n  loop invariant (\\at(q, Pre) == 0 || \\at(q, Pre) == 1) ==> n == \\at(q, Pre);\n  loop assigns n, t;\n*/\nwhile (t>=1) {\n      n = n*n;\n      t = t-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int o, x, v, w;\n\n  o=m-9;\n  x=0;\n  v=k;\n  w=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (x<=o-1) {\n      if (v+5<=o) {\n          v = v+5;\n      }\n      else {\n          v = o;\n      }\n      v = v+x;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (w == -8) && (v == \\at(k, Pre)) && (x == 0) && (o == \\at(m, Pre) - 9) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (x<=o-1) {\n      if (v+5<=o) {\n          v = v+5;\n      }\n      else {\n          v = o;\n      }\n      v = v+x;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 5 > o at loop-step start; x at loop-step start <= o at loop-step start - 1; x at loop-step start <= o at loop-step start - 1). Changed: v: v at loop-step start -> v at loop-step start + 5 + x at loop-step start. Unchanged: k keeps k at loop-step start; m keeps m at loop-step start; o keeps o at loop-step start; w keeps w at loop-step start; x keeps x at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'm', 'o', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int o, x, v, w;\n\n  o=m-9;\n  x=0;\n  v=k;\n  w=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == \\at(k, Pre) || v <= o + x;\n  loop invariant x == 0;\n  loop invariant o == \\at(m, Pre) - 9;\n  loop invariant k == \\at(k, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant (x == 0 && v == \\at(k, Pre)) || v <= o + x;\n  loop invariant x >= 0;\n  loop invariant o < 0 || x <= o;\n  loop invariant o == m - 9;\n  loop invariant x == 0 && ((v <= o) || (v <= k));\n  loop invariant ((v <= k) || (v <= o));\n  loop assigns v;\n*/\nwhile (x<=o-1) {\n      if (v+5<=o) {\n          v = v+5;\n      }\n      else {\n          v = o;\n      }\n      v = v+x;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int q){\n  int g, z, v, x;\n\n  g=64;\n  z=g;\n  v=z;\n  x=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (z>1) {\n      z = z/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (x == -2) && (v == 64) && (z == 64) && (g == 64) && (q == \\at(q, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (z>1) {\n      z = z/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (z at loop-step start > 1). Changed: z: z at loop-step start -> z at loop-step start / 2. Unchanged: a keeps a at loop-step start; g keeps g at loop-step start; q keeps q at loop-step start; v keeps v at loop-step start; x keeps x at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'g', 'q', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int q){\n  int g, z, v, x;\n\n  g=64;\n  z=g;\n  v=z;\n  x=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant z >= 1;\n  loop invariant z <= 64;\n\n  loop invariant g == 64;\n  loop invariant a == \\at(a, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant 64 % z == 0;\n  loop invariant 1 <= z;\n  loop invariant z <= g;\n  loop invariant g % z == 0;\n  loop invariant z > 0;\n  loop assigns z;\n*/\nwhile (z>1) {\n      z = z/2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int r, w, p;\n\n  r=n-7;\n  w=r+4;\n  p=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (w>0) {\n      w = w/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (p == \\at(n, Pre)) && (w == \\at(n, Pre) - 7 + 4) && (r == \\at(n, Pre) - 7) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (w>0) {\n      w = w/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (w at loop-step start > 0). Changed: w: w at loop-step start -> w at loop-step start / 2. Unchanged: n keeps n at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['n', 'q', 'r', 'w']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int r, w, p;\n\n  r=n-7;\n  w=r+4;\n  p=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant n == \\at(n, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant r == \\at(n, Pre) - 7;\n  loop invariant w > 0 ==> w <= \\at(n, Pre) - 3;\n  loop invariant w <= \\at(n, Pre) - 3;\n\n  loop invariant w <= r + 4;\n  loop assigns w;\n*/\nwhile (w>0) {\n      w = w/2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p){\n  int h, o, l;\n\n  h=p;\n  o=0;\n  l=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (o<h) {\n      l = l%5;\n      o = o+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (l == -5) && (o == 0) && (h == \\at(p, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (o<h) {\n      l = l%5;\n      o = o+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['h', 'l', 'm', 'o', 'p']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p){\n  int h, o, l;\n\n  h=p;\n  o=0;\n  l=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant (l == -5 || l == 0) && p == \\at(p, Pre);\n  loop invariant h == \\at(p, Pre);\n\n  loop invariant (l == -5) || (-4 <= l && l <= 4);\n  loop invariant h == p;\n  loop invariant 0 <= o;\n  loop invariant l <= 0;\n  loop invariant (l == -5) || (l == 0);\n  loop invariant l % 5 == 0;\n  loop invariant o >= 0;\n  loop invariant o <= h || h < 0;\n\n  loop invariant (o == 0) ==> (l == -5);\n  loop assigns o, l;\n*/\nwhile (o<h) {\n      l = l%5;\n      o = o+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int b, f, v;\n\n  b=m+16;\n  f=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (f+1<=b) {\n      if (v+2<b) {\n          v = v-v;\n      }\n      f = f+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -1) && (f == 0) && (b == \\at(m, Pre) + 16) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (f+1<=b) {\n      if (v+2<b) {\n          v = v-v;\n      }\n      f = f+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 2 >= b at loop-step start; f at loop-step start + 1 <= b at loop-step start; f at loop-step start + 1 <= b at loop-step start). Changed: f: f at loop-step start -> f at loop-step start + 1; v: v at loop-step start -> v at loop-step start - v at loop-step start. Unchanged: b keeps b at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'f', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int b, f, v;\n\n  b=m+16;\n  f=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant b == \\at(m, Pre) + 16;\n  loop invariant m == \\at(m, Pre);\n  loop invariant n == \\at(n, Pre);\n\n  loop invariant v == -1 || v == 0;\n  loop invariant -1 <= v <= 0;\n  loop invariant 0 <= f;\n  loop invariant b == m + 16;\n  loop invariant f >= 0 && (v == -1 || v == 0);\n  loop invariant f <= b || b < 0;\n  loop invariant (v == -1) || (v == 0);\n  loop invariant f >= 0;\n\n  loop assigns f, v;\n*/\nwhile (f+1<=b) {\n      if (v+2<b) {\n          v = v-v;\n      }\n      f = f+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int h, n, w;\n\n  h=79;\n  n=0;\n  w=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (n<=h-1) {\n      w = w+w;\n      if ((n%3)==0) {\n          w = w+1;\n      }\n      n = n+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (w == -2) && (n == 0) && (h == 79) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (n<=h-1) {\n      w = w+w;\n      if ((n%3)==0) {\n          w = w+1;\n      }\n      n = n+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (n at loop-step start % 3 != 0; n at loop-step start <= h at loop-step start - 1; n at loop-step start <= h at loop-step start - 1). Changed: n: n at loop-step start -> n at loop-step start + 1; w: w at loop-step start -> w at loop-step start + w at loop-step start + 1. Unchanged: b keeps b at loop-step start; h keeps h at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'h', 'm', 'n', 'w']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m){\n  int h, n, w;\n\n  h=79;\n  n=0;\n  w=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= n;\n  loop invariant n <= h;\n  loop invariant w <= -1;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant h == 79;\n  loop invariant 0 <= n <= h;\n  loop invariant w <= -2;\n  loop invariant (w % 2 != 0) <==> (n % 3 == 1);\n  loop assigns w, n;\n*/\nwhile (n<=h-1) {\n      w = w+w;\n      if ((n%3)==0) {\n          w = w+1;\n      }\n      n = n+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int t, u, v;\n\n  t=(m%14)+15;\n  u=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<t) {\n      v = v*v;\n      u = u+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<t) {\n      v = v*v;\n      u = u+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'm', 't', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int t, u, v;\n\n  t=(m%14)+15;\n  u=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= u && u <= t && (u == 0 ==> v == k) && t == (m % 14) + 15;\n  loop invariant k == \\at(k,Pre);\n  loop invariant m == \\at(m,Pre);\n  loop invariant u >= 0;\n  loop invariant u <= t;\n  loop invariant t == (\\at(m,Pre) % 14) + 15;\n  loop invariant (u == 0) ==> v == \\at(k,Pre);\n  loop invariant u > 0 ==> v >= 0;\n  loop invariant t == (m % 14) + 15;\n  loop invariant 0 <= u;\n  loop invariant u == 0 ==> v == \\at(k, Pre);\n  loop assigns v, u;\n*/\nwhile (u<t) {\n      v = v*v;\n      u = u+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n){\n  int c, j, v;\n\n  c=b+23;\n  j=c;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j>0) {\n      j = j/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == \\at(n, Pre)) && (j == \\at(b, Pre) + 23) && (c == \\at(b, Pre) + 23) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (j>0) {\n      j = j/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start > 0). Changed: j: j at loop-step start -> j at loop-step start / 2. Unchanged: b keeps b at loop-step start; c keeps c at loop-step start; n keeps n at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'j', 'n']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n){\n  int c, j, v;\n\n  c=b+23;\n  j=c;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant c == \\at(b, Pre) + 23;\n  loop invariant j <= c;\n  loop invariant b == \\at(b, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant c == b + 23;\n\n  loop invariant j <= \\at(b, Pre) + 23;\n  loop invariant (c >= 0 ==> 0 <= j && j <= c) &&\n                   (c < 0  ==> c <= j && j <= 0);\n\n  loop assigns j;\n*/\nwhile (j>0) {\n      j = j/2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p){\n  int m, j, q;\n\n  m=34;\n  j=m+6;\n  q=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j>1) {\n      j = j/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (q == \\at(p, Pre)) && (j == 34 + 6) && (m == 34) && (p == \\at(p, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (j>1) {\n      j = j/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start > 1). Changed: j: j at loop-step start -> j at loop-step start / 2. Unchanged: m keeps m at loop-step start; n keeps n at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['j', 'm', 'n', 'p']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p){\n  int m, j, q;\n\n  m=34;\n  j=m+6;\n  q=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant j <= 40;\n  loop invariant j >= 1;\n  loop invariant m == 34;\n  loop invariant n == \\at(n, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant j <= m + 6;\n  loop assigns j;\n*/\nwhile (j>1) {\n      j = j/2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n){\n  int m, z, j, v;\n\n  m=18;\n  z=m;\n  j=m;\n  v=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (z>=2) {\n      j = j+v+v;\n      j = j+1;\n      z = z-2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -3) && (j == 18) && (z == 18) && (m == 18) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (z>=2) {\n      j = j+v+v;\n      j = j+1;\n      z = z-2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (z at loop-step start >= 2). Changed: j: j at loop-step start -> j at loop-step start + v at loop-step start + v at loop-step start + 1; z: z at loop-step start -> z at loop-step start - 2. Unchanged: a keeps a at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'j', 'm', 'n', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n){\n  int m, z, j, v;\n\n  m=18;\n  z=m;\n  j=m;\n  v=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant a == \\at(a, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant z >= 0;\n  loop invariant z <= 18;\n  loop invariant j <= 18;\n  loop invariant (j - z) % 3 == 0;\n  loop invariant 2*j == (5*z - 54);\n  loop invariant 0 <= z;\n  loop invariant z <= m;\n  loop invariant 2*j - 5*z == -54;\n  loop invariant v == -3;\n  loop invariant m == 18;\n\n  loop invariant 2*j == 5*z - 54;\n  loop assigns j, z;\n*/\nwhile (z>=2) {\n      j = j+v+v;\n      j = j+1;\n      z = z-2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int i, g, p, y;\n\n  i=20;\n  g=i;\n  p=g;\n  y=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (g>2) {\n      p = p+4;\n      y = y+p;\n      g = g-3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (y == 1) && (p == 20) && (g == 20) && (i == 20) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (g>2) {\n      p = p+4;\n      y = y+p;\n      g = g-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (g at loop-step start > 2). Changed: g: g at loop-step start -> g at loop-step start - 3; p: p at loop-step start -> p at loop-step start + 4; y: y at loop-step start -> y at loop-step start + (p at loop-step start + 4. Unchanged: i keeps i at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['g', 'i', 'm', 'n', 'p', 'y']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int i, g, p, y;\n\n  i=20;\n  g=i;\n  p=g;\n  y=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 3*p + 4*g == 140;\n  loop invariant i == 20;\n  loop invariant (p - 20) % 4 == 0;\n  loop invariant (g - 20) % 3 == 0;\n  loop invariant g <= 20;\n  loop invariant p >= 20;\n  loop invariant 3*(p - 20) == 4*(20 - g);\n  loop invariant g >= 2;\n  loop invariant m == \\at(m, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant 4*g + 3*p == 140;\n  loop invariant 20 <= p <= 44;\n  loop invariant 8*(y - 1) == (p - 20)*(p - 20) + 44*(p - 20);\n  loop assigns p, y, g;\n*/\nwhile (g>2) {\n      p = p+4;\n      y = y+p;\n      g = g-3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p){\n  int l, d, y;\n\n  l=68;\n  d=l;\n  y=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (d>0) {\n      y = n-(-4);\n      d = d-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (y == -6) && (d == 68) && (l == 68) && (p == \\at(p, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (d>0) {\n      y = n-(-4);\n      d = d-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (d at loop-step start > 0). Changed: d: d at loop-step start -> d at loop-step start - 1; y: y at loop-step start -> n at loop-step start - -4. Unchanged: l keeps l at loop-step start; n keeps n at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'l', 'n', 'p', 'y']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p){\n  int l, d, y;\n\n  l=68;\n  d=l;\n  y=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 68;\n  loop invariant d >= 0;\n  loop invariant d <= 68;\n  loop invariant n == \\at(n, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant y == -6 || y == n - (-4);\n  loop invariant 0 <= d;\n  loop invariant d <= l;\n  loop invariant (y == n + 4) || (d == l);\n  loop invariant (y == -6) || (y == n + 4);\n  loop invariant y == -6 || y == n + 4;\n  loop invariant y == n + 4 || y == -6;\n  loop assigns d, y;\n*/\nwhile (d>0) {\n      y = n-(-4);\n      d = d-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int w, i, s, p;\n\n  w=19;\n  i=0;\n  s=i;\n  p=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i+3<=w) {\n      if (s+1<=w) {\n          s = s+1;\n      }\n      else {\n          s = w;\n      }\n      p = p+p;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (p == 0) && (s == 0) && (i == 0) && (w == 19) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i+3<=w) {\n      if (s+1<=w) {\n          s = s+1;\n      }\n      else {\n          s = w;\n      }\n      p = p+p;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start + 1 > w at loop-step start; i at loop-step start + 3 <= w at loop-step start; i at loop-step start + 3 <= w at loop-step start). Changed: p: p at loop-step start -> p at loop-step start + p at loop-step start; s: s at loop-step start -> s at loop-step start + 1. Unchanged: i keeps i at loop-step start; k keeps k at loop-step start; m keeps m at loop-step start; w keeps w at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'm', 'p', 's', 'w']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int w, i, s, p;\n\n  w=19;\n  i=0;\n  s=i;\n  p=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant p == 0;\n  loop invariant i == 0;\n  loop invariant i <= w;\n  loop invariant 0 <= s;\n  loop invariant s <= w;\n  loop invariant s >= i;\n  loop invariant k == \\at(k, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant w == 19;\n  loop invariant s >= 0;\n  loop assigns s, p;\n*/\nwhile (i+3<=w) {\n      if (s+1<=w) {\n          s = s+1;\n      }\n      else {\n          s = w;\n      }\n      p = p+p;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int s, i, g, v;\n\n  s=14;\n  i=0;\n  g=n;\n  v=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i+1<=s) {\n      if (g+5<=s) {\n          g = g+5;\n      }\n      else {\n          g = s;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -2) && (g == \\at(n, Pre)) && (i == 0) && (s == 14) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (i+1<=s) {\n      if (g+5<=s) {\n          g = g+5;\n      }\n      else {\n          g = s;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (g at loop-step start + 5 <= s at loop-step start; i at loop-step start + 1 <= s at loop-step start; i at loop-step start + 1 <= s at loop-step start). Changed: g: g at loop-step start -> s at loop-step start. Unchanged: i keeps i at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start; s keeps s at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['g', 'i', 'n', 'q', 's']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int s, i, g, v;\n\n  s=14;\n  i=0;\n  g=n;\n  v=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant s == 14;\n  loop invariant n == \\at(n, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant i <= s - 1;\n\n  loop invariant i == 0;\n  loop invariant s == 14 && i >= 0 && i <= s - 1 && ((g <= s) || (g <= n));\n  loop invariant (g == s) || ((g - n) % 5 == 0);\n  loop invariant i <= s;\n  loop invariant g == \\at(n, Pre) || g <= s;\n  loop invariant (n <= s) ==> (g >= n);\n  loop invariant (n > s) ==> (g >= s);\n  loop assigns g;\n*/\nwhile (i+1<=s) {\n      if (g+5<=s) {\n          g = g+5;\n      }\n      else {\n          g = s;\n      }\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int k, i, x;\n\n  k=q+14;\n  i=0;\n  x=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<k) {\n      x = x%6;\n      x = x*x;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (x == \\at(q, Pre) + 14) && (i == 0) && (k == \\at(q, Pre) + 14) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (i<k) {\n      x = x%6;\n      x = x*x;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start < k at loop-step start; x at loop-step start % 6). Changed: i: i at loop-step start -> i at loop-step start + 1; x: x at loop-step start -> x at loop-step start % 6. Unchanged: k keeps k at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'p', 'q', 'x']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int k, i, x;\n\n  k=q+14;\n  i=0;\n  x=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant k == \\at(q, Pre) + 14;\n  loop invariant q == \\at(q, Pre);\n  loop invariant p == \\at(p, Pre);\n\n  loop invariant i > 0 ==> 0 <= x && x <= 25;\n  loop invariant k == q + 14;\n\n  loop invariant i >= 0;\n  loop invariant (i == 0) ==> (x == k);\n  loop invariant i == 0 || i <= k;\n  loop invariant (i == 0 && x == k) || (i > 0 && (x == 0 || x == 1 || x == 4 || x == 9 || x == 16 || x == 25));\n  loop invariant i == 0 ==> x == k;\n  loop invariant i <= k || k < 0;\n\n  loop invariant (i == 0) ==> (x == k) && (i > 0) ==> (0 <= x <= 25);\n  loop assigns i, x;\n*/\nwhile (i<k) {\n      x = x%6;\n      x = x*x;\n      i = i+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int w, t, d;\n\n  w=79;\n  t=0;\n  d=w;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t<=w-2) {\n      d = d-d;\n      if ((t%2)==0) {\n          d = d+1;\n      }\n      t = t+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (d == 79) && (t == 0) && (w == 79) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (t<=w-2) {\n      d = d-d;\n      if ((t%2)==0) {\n          d = d+1;\n      }\n      t = t+2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start % 2 != 0; t at loop-step start <= w at loop-step start - 2; t at loop-step start <= w at loop-step start - 2). Changed: d: d at loop-step start -> d at loop-step start - d at loop-step start + 1; t: t at loop-step start -> t at loop-step start + 2. Unchanged: m keeps m at loop-step start; n keeps n at loop-step start; w keeps w at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'm', 'n', 't', 'w']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int w, t, d;\n\n  w=79;\n  t=0;\n  d=w;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == \\at(m, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant w == 79;\n  loop invariant t % 2 == 0;\n  loop invariant t <= w - 1;\n  loop invariant (t == 0) ==> (d == 79);\n  loop invariant t <= w;\n  loop invariant 0 <= t;\n  loop invariant 0 <= t <= w;\n  loop invariant (t == 0) ==> (d == w);\n  loop assigns d, t;\n*/\nwhile (t<=w-2) {\n      d = d-d;\n      if ((t%2)==0) {\n          d = d+1;\n      }\n      t = t+2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n){\n  int k, v, z, s;\n\n  k=21;\n  v=0;\n  z=k;\n  s=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<k) {\n      if (v<k/2) {\n          z = z+s;\n      }\n      else {\n          z = z*s;\n      }\n      z = z*2+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (s == 21) && (z == 21) && (v == 0) && (k == 21) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (v<k) {\n      if (v<k/2) {\n          z = z+s;\n      }\n      else {\n          z = z*s;\n      }\n      z = z*2+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start >= k at loop-step start / 2; v at loop-step start < k at loop-step start; s at loop-step start; 2 + 1; v at loop-step start < k at loop-step start; 2 + 1). Changed: z: z at loop-step start -> (z at loop-step start + s at loop-step start. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; n keeps n at loop-step start; s keeps s at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'n', 's', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n){\n  int k, v, z, s;\n\n  k=21;\n  v=0;\n  z=k;\n  s=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant k == 21;\n  loop invariant v == 0;\n  loop invariant s == 21;\n  loop invariant b == \\at(b, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant v <= k;\n  loop invariant s == k;\n  loop invariant v >= 0;\n  loop invariant z >= s;\n  loop invariant z % 2 == 1;\n  loop invariant z >= 21;\n  loop assigns z;\n*/\nwhile (v<k) {\n      if (v<k/2) {\n          z = z+s;\n      }\n      else {\n          z = z*s;\n      }\n      z = z*2+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int q){\n  int i, e, o;\n\n  i=(q%17)+16;\n  e=0;\n  o=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (e+2<=i) {\n      if (o+1<i) {\n          o = o%9;\n      }\n      e = e+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (o == -8) && (e == 0) && (i == \\at(q, Pre) % 17 + 16) && (q == \\at(q, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (e+2<=i) {\n      if (o+1<i) {\n          o = o%9;\n      }\n      e = e+2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (o at loop-step start + 1 >= i at loop-step start; e at loop-step start + 2 <= i at loop-step start; e at loop-step start + 2 <= i at loop-step start). Changed: e: e at loop-step start -> e at loop-step start + 2; o: o at loop-step start -> o at loop-step start % 9. Unchanged: i keeps i at loop-step start; m keeps m at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'i', 'm', 'o', 'q']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int q){\n  int i, e, o;\n\n  i=(q%17)+16;\n  e=0;\n  o=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i == (q % 17) + 16;\n  loop invariant o == -8;\n  loop invariant e % 2 == 0;\n\n  loop invariant m == \\at(m, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant i == ((\\at(q, Pre) % 17) + 16);\n  loop invariant e >= 0;\n  loop invariant e <= i;\n  loop invariant i == (\\at(q,Pre)%17) + 16;\n  loop invariant -8 <= o;\n  loop invariant o <= 8;\n  loop invariant i == (q % 17) + 16 &&\n                   e % 2 == 0 &&\n                   0 <= e &&\n                   e <= i &&\n                   o == -8 &&\n                   q == \\at(q, Pre) &&\n                   m == \\at(m, Pre);\n  loop invariant 0 <= i;\n  loop invariant i <= 32;\n  loop assigns e, o;\n*/\nwhile (e+2<=i) {\n      if (o+1<i) {\n          o = o%9;\n      }\n      e = e+2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int r, c, w;\n\n  r=32;\n  c=0;\n  w=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (c<=r-1) {\n      w = w-w;\n      c = c+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (w == 0) && (c == 0) && (r == 32) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (c<=r-1) {\n      w = w-w;\n      c = c+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (c at loop-step start <= r at loop-step start - 1). Changed: c: c at loop-step start -> c at loop-step start + 1; w: w at loop-step start -> w at loop-step start - w at loop-step start. Unchanged: n keeps n at loop-step start; q keeps q at loop-step start; r keeps r at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'n', 'q', 'r', 'w']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int r, c, w;\n\n  r=32;\n  c=0;\n  w=c;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant n == \\at(n, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant r == 32;\n  loop invariant w == 0;\n  loop invariant c <= r;\n  loop invariant c >= 0;\n  loop invariant 0 <= c;\n  loop invariant 0 <= c <= r;\n  loop assigns c, w;\n*/\nwhile (c<=r-1) {\n      w = w-w;\n      c = c+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int l, t, v, b;\n\n  l=52;\n  t=0;\n  v=2;\n  b=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t<=l-1) {\n      v = v*3;\n      t = t+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (b == -2) && (v == 2) && (t == 0) && (l == 52) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (t<=l-1) {\n      v = v*3;\n      t = t+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'l', 'm', 't', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int l, t, v, b;\n\n  l=52;\n  t=0;\n  v=2;\n  b=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant 0 <= t <= l;\n  loop invariant v >= 2;\n  loop invariant v % 2 == 0;\n  loop invariant k == \\at(k, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant t >= 0;\n  loop invariant t <= l;\n  loop invariant l == 52;\n  loop invariant v >= 0;\n  loop invariant 0 <= t;\n  loop invariant ((t == 0) ==> (v == 2)) && ((t > 0) ==> (v % 3 == 0));\n  loop assigns v, t;\n*/\nwhile (t<=l-1) {\n      v = v*3;\n      t = t+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m){\n  int k, i, h, v;\n\n  k=24;\n  i=0;\n  h=a;\n  v=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<k) {\n      h = h+1;\n      v = v+1;\n      h = h+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 5) && (h == \\at(a, Pre)) && (i == 0) && (k == 24) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<k) {\n      h = h+1;\n      v = v+1;\n      h = h+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start < k at loop-step start). Changed: h: h at loop-step start -> h at loop-step start + 1 + 1; v: v at loop-step start -> v at loop-step start + 1. Unchanged: a keeps a at loop-step start; i keeps i at loop-step start; k keeps k at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'h', 'i', 'k', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m){\n  int k, i, h, v;\n\n  k=24;\n  i=0;\n  h=a;\n  v=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i == 0;\n  loop invariant k == 24;\n  loop invariant m == \\at(m, Pre);\n  loop invariant h - a == 2*(v - 5);\n  loop invariant i <= k;\n  loop invariant v >= 5;\n  loop invariant h - 2*v == a - 10;\n  loop invariant h >= a;\n  loop invariant a == \\at(a, Pre);\n  loop invariant 0 <= i;\n  loop assigns h, v;\n*/\nwhile (i<k) {\n      h = h+1;\n      v = v+1;\n      h = h+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n){\n  int m, s, k, v;\n\n  m=(b%7)+6;\n  s=0;\n  k=n;\n  v=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<=m-1) {\n      k = k*2;\n      s = s+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -4) && (k == \\at(n, Pre)) && (s == 0) && (m == \\at(b, Pre) % 7 + 6) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s<=m-1) {\n      k = k*2;\n      s = s+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start <= m at loop-step start - 1; 2). Changed: s: s at loop-step start -> s at loop-step start + 1. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'm', 'n', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n){\n  int m, s, k, v;\n\n  m=(b%7)+6;\n  s=0;\n  k=n;\n  v=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant s >= 0;\n  loop invariant s <= m;\n  loop invariant b == \\at(b, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant m == b % 7 + 6;\n  loop invariant m == (b%7) + 6;\n  loop invariant 0 <= s;\n  loop invariant (n >= 0) ==> (k >= n);\n  loop invariant m == (\\at(b, Pre) % 7) + 6;\n  loop assigns k, s;\n*/\nwhile (s<=m-1) {\n      k = k*2;\n      s = s+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m){\n  int n, j, c;\n\n  n=56;\n  j=n;\n  c=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j>=2) {\n      c = a-n;\n      j = j-2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (c == -8) && (j == 56) && (n == 56) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (j>=2) {\n      c = a-n;\n      j = j-2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start >= 2). Changed: c: c at loop-step start -> a at loop-step start - n at loop-step start; j: j at loop-step start -> j at loop-step start - 2. Unchanged: a keeps a at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'j', 'm', 'n']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m){\n  int n, j, c;\n\n  n=56;\n  j=n;\n  c=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant a == \\at(a, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant n == 56;\n  loop invariant 0 <= j;\n  loop invariant j <= 56;\n  loop invariant j % 2 == 0 && ((c == a - n) || (c == -8 && j == 56));\n  loop invariant j >= 0;\n  loop invariant (j % 2) == 0 && (c == -8 || c == a - n);\n  loop invariant j % 2 == 0;\n  loop invariant (j < 56) ==> c == a - n;\n  loop invariant (j % 2) == 0;\n  loop invariant (c == -8) || (c == a - n);\n  loop assigns c, j;\n*/\nwhile (j>=2) {\n      c = a-n;\n      j = j-2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n){\n  int v, k, p;\n\n  v=b+13;\n  k=v+6;\n  p=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k>v) {\n      p = p*2;\n      k = k-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (p == 5) && (k == \\at(b, Pre) + 13 + 6) && (v == \\at(b, Pre) + 13) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (k>v) {\n      p = p*2;\n      k = k-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start > v at loop-step start; 2). Changed: k: k at loop-step start -> k at loop-step start - 1. Unchanged: b keeps b at loop-step start; n keeps n at loop-step start; p keeps p at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n){\n  int v, k, p;\n\n  v=b+13;\n  k=v+6;\n  p=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == \\at(b, Pre) + 13;\n  loop invariant k >= v;\n  loop invariant k <= \\at(b, Pre) + 19;\n  loop invariant b == \\at(b, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant v == b + 13;\n  loop invariant k <= v + 6;\n  loop invariant p >= 5;\n\n  loop invariant p % 5 == 0;\n  loop invariant k - v <= 6;\n  loop invariant 0 <= k - v <= 6;\n  loop assigns p, k;\n*/\nwhile (k>v) {\n      p = p*2;\n      k = k-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k){\n  int j, h, y;\n\n  j=a-3;\n  h=0;\n  y=h;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (h<=j-1) {\n      y = y+1;\n      y = y+h;\n      h = h+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (y == 0) && (h == 0) && (j == \\at(a, Pre) - 3) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (h<=j-1) {\n      y = y+1;\n      y = y+h;\n      h = h+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (h at loop-step start <= j at loop-step start - 1). Changed: h: h at loop-step start -> h at loop-step start + 1; y: y at loop-step start -> y at loop-step start + 1 + h at loop-step start. Unchanged: a keeps a at loop-step start; j keeps j at loop-step start; k keeps k at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'h', 'j', 'k', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k){\n  int j, h, y;\n\n  j=a-3;\n  h=0;\n  y=h;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant y == h*(h+1)/2;\n  loop invariant j == \\at(a, Pre) - 3;\n\n  loop invariant a == \\at(a, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant h >= 0;\n  loop invariant y == (h*(h+1))/2;\n  loop invariant 0 <= h;\n  loop invariant (h <= j) || (j < 0);\n  loop assigns y, h;\n*/\nwhile (h<=j-1) {\n      y = y+1;\n      y = y+h;\n      h = h+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p){\n  int n, v, c;\n\n  n=49;\n  v=0;\n  c=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<n) {\n      if (c+7<n) {\n          c = c-n;\n      }\n      else {\n          c = c+c;\n      }\n      v = v+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (c == \\at(p, Pre)) && (v == 0) && (n == 49) && (p == \\at(p, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (v<n) {\n      if (c+7<n) {\n          c = c-n;\n      }\n      else {\n          c = c+c;\n      }\n      v = v+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (c at loop-step start + 7 >= n at loop-step start; v at loop-step start < n at loop-step start; v at loop-step start < n at loop-step start). Changed: c: c at loop-step start -> c at loop-step start - n at loop-step start; v: v at loop-step start -> v at loop-step start + 1. Unchanged: m keeps m at loop-step start; n keeps n at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p){\n  int n, v, c;\n\n  n=49;\n  v=0;\n  c=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v <= n;\n  loop invariant n == 49;\n  loop invariant (\\at(p, Pre) >= 42) ==> (c >= \\at(p, Pre));\n  loop invariant p == \\at(p, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant 0 <= v;\n  loop invariant v >= 0;\n  loop assigns c, v;\n*/\nwhile (v<n) {\n      if (c+7<n) {\n          c = c-n;\n      }\n      else {\n          c = c+c;\n      }\n      v = v+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int q){\n  int h, j, t;\n\n  h=64;\n  j=0;\n  t=h;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j<=h-1) {\n      t = t*2;\n      t = t%8;\n      j = j+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (t == 64) && (j == 0) && (h == 64) && (q == \\at(q, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (j<=h-1) {\n      t = t*2;\n      t = t%8;\n      j = j+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start <= h at loop-step start - 1; 2 % 8). Changed: j: j at loop-step start -> j at loop-step start + 1. Unchanged: h keeps h at loop-step start; k keeps k at loop-step start; q keeps q at loop-step start; t keeps t at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['h', 'j', 'k', 'q', 't']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int q){\n  int h, j, t;\n\n  h=64;\n  j=0;\n  t=h;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant h == 64 && j <= h && (t == 0 || t == 64) && t % 8 == 0;\n  loop invariant k == \\at(k, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant j >= 0;\n  loop invariant 0 <= j;\n  loop invariant j <= h;\n  loop invariant t % 8 == 0;\n  loop invariant h == 64;\n  loop invariant (k == \\at(k, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant (j > 0) ==> t == 0;\n  loop invariant 0 <= j <= h;\n  loop invariant (j >= 1) ==> t == 0;\n  loop assigns t, j;\n*/\nwhile (j<=h-1) {\n      t = t*2;\n      t = t%8;\n      j = j+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int q){\n  int j, k, x;\n\n  j=(m%6)+19;\n  k=0;\n  x=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k<j) {\n      x = x+1;\n      x = x+x;\n      k = k+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (x == \\at(q, Pre)) && (k == 0) && (j == \\at(m, Pre) % 6 + 19) && (q == \\at(q, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (k<j) {\n      x = x+1;\n      x = x+x;\n      k = k+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start < j at loop-step start). Changed: k: k at loop-step start -> k at loop-step start + 1; x: x at loop-step start -> x at loop-step start + 1 + (x at loop-step start + 1. Unchanged: j keeps j at loop-step start; m keeps m at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['j', 'k', 'm', 'q', 'x']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int q){\n  int j, k, x;\n\n  j=(m%6)+19;\n  k=0;\n  x=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant j == \\at(m, Pre) % 6 + 19;\n  loop invariant 0 <= k;\n  loop invariant k <= j;\n  loop invariant m == \\at(m, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant j == ((\\at(m,Pre) % 6) + 19);\n\n  loop invariant (k == 0) ==> x == \\at(q, Pre);\n  loop invariant j == (\\at(m, Pre) % 6) + 19;\n  loop assigns x, k;\n*/\nwhile (k<j) {\n      x = x+1;\n      x = x+x;\n      k = k+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k){\n  int v, o, j, z;\n\n  v=b;\n  o=v;\n  j=o;\n  z=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j<v) {\n      if (j<v) {\n          j = j+1;\n      }\n      j = j+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (z == -5) && (j == \\at(b, Pre)) && (o == \\at(b, Pre)) && (v == \\at(b, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (j<v) {\n      if (j<v) {\n          j = j+1;\n      }\n      j = j+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (j at loop-step start < v at loop-step start; j at loop-step start < v at loop-step start). Changed: j: j at loop-step start -> j at loop-step start + 1 + 1. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; o keeps o at loop-step start; v keeps v at loop-step start; z keeps z at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'j', 'k', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k){\n  int v, o, j, z;\n\n  v=b;\n  o=v;\n  j=o;\n  z=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == b;\n  loop invariant j <= v;\n  loop invariant j >= b;\n  loop invariant (j - b) % 2 == 0;\n  loop invariant v == \\at(b, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant (v - j) % 2 == 0;\n  loop invariant j <= v + 1;\n  loop invariant b == \\at(b,Pre);\n  loop invariant (j - \\at(b, Pre)) % 2 == 0;\n  loop invariant j >= \\at(b, Pre);\n  loop assigns j;\n*/\nwhile (j<v) {\n      if (j<v) {\n          j = j+1;\n      }\n      j = j+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int q){\n  int n, k, y;\n\n  n=24;\n  k=n;\n  y=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (k>=3) {\n      y = y+y;\n      k = k-3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (y == 24) && (k == 24) && (n == 24) && (q == \\at(q, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (k>=3) {\n      y = y+y;\n      k = k-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k at loop-step start >= 3). Changed: k: k at loop-step start -> k at loop-step start - 3; y: y at loop-step start -> y at loop-step start + y at loop-step start. Unchanged: a keeps a at loop-step start; n keeps n at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'k', 'n', 'q', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int q){\n  int n, k, y;\n\n  n=24;\n  k=n;\n  y=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant k <= 24;\n  loop invariant k >= 0;\n  loop invariant k % 3 == 0;\n  loop invariant y % 24 == 0;\n  loop invariant a == \\at(a, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant y >= 24;\n  loop invariant n == 24;\n  loop invariant 0 <= k;\n  loop invariant k <= n;\n\n  loop assigns y, k;\n*/\nwhile (k>=3) {\n      y = y+y;\n      k = k-3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k){\n  int b, x, c;\n\n  b=70;\n  x=b+3;\n  c=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (x>=b+1) {\n      if (x+7<=c+b) {\n          c = c*c+c;\n      }\n      x = x-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (c == -3) && (x == 70 + 3) && (b == 70) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (x>=b+1) {\n      if (x+7<=c+b) {\n          c = c*c+c;\n      }\n      x = x-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (x at loop-step start + 7 > c at loop-step start + b at loop-step start; x at loop-step start >= b at loop-step start + 1; x at loop-step start >= b at loop-step start + 1; c at loop-step start + c at loop-step start). Changed: x: x at loop-step start -> x at loop-step start - 1. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; c keeps c at loop-step start; k keeps k at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'k', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k){\n  int b, x, c;\n\n  b=70;\n  x=b+3;\n  c=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant b == 70;\n  loop invariant x <= b + 3;\n  loop invariant x >= b;\n  loop invariant c >= -3;\n  loop invariant k == \\at(k, Pre);\n  loop invariant a == \\at(a, Pre);\n  loop invariant x <= 73;\n  loop invariant c == -3;\n\n  loop assigns x, c;\n*/\nwhile (x>=b+1) {\n      if (x+7<=c+b) {\n          c = c*c+c;\n      }\n      x = x-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k){\n  int o, t, v;\n\n  o=55;\n  t=o;\n  v=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (t>0) {\n      v = v-v;\n      t = t-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -4) && (t == 55) && (o == 55) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (t>0) {\n      v = v-v;\n      t = t-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (t at loop-step start > 0). Changed: t: t at loop-step start -> t at loop-step start - 1; v: v at loop-step start -> v at loop-step start - v at loop-step start. Unchanged: a keeps a at loop-step start; k keeps k at loop-step start; o keeps o at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'k', 'o', 't', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k){\n  int o, t, v;\n\n  o=55;\n  t=o;\n  v=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant o == 55;\n  loop invariant 0 <= t;\n  loop invariant t <= o;\n  loop invariant v == 0 || v == -4;\n  loop invariant a == \\at(a, Pre);\n  loop invariant k == \\at(k, Pre);\n  loop invariant t >= 0;\n  loop invariant t <= 55;\n  loop invariant (t < 55) ==> (v == 0);\n  loop invariant v == 0 || (v == -4 && t >= 1);\n  loop assigns t, v;\n*/\nwhile (t>0) {\n      v = v-v;\n      t = t-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int l, v, o;\n\n  l=n+9;\n  v=l;\n  o=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v>3) {\n      o = o*2;\n      if (v+6<=v+l) {\n          o = o*o;\n      }\n      v = v-4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (o == \\at(n, Pre) + 9) && (v == \\at(n, Pre) + 9) && (l == \\at(n, Pre) + 9) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (v>3) {\n      o = o*2;\n      if (v+6<=v+l) {\n          o = o*o;\n      }\n      v = v-4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 6 > v at loop-step start + l at loop-step start; v at loop-step start > 3; 2) || v at loop-step start + 6 <= v at loop-step start + l at loop-step start; v at loop-step start > 3; 2; o at loop-step start; 2). Changed: v: v at loop-step start -> v at loop-step start - 4. Unchanged: l keeps l at loop-step start; m keeps m at loop-step start; n keeps n at loop-step start; o keeps o at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['l', 'm', 'n', 'o', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int l, v, o;\n\n  l=n+9;\n  v=l;\n  o=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == n + 9;\n  loop invariant v <= l;\n\n  loop invariant v % 4 == l % 4;\n  loop invariant (l >= 6) ==> o >= 0;\n  loop invariant l == \\at(n, Pre) + 9 &&\n                   n == \\at(n, Pre) &&\n                   m == \\at(m, Pre) &&\n                   l - v >= 0 &&\n                   (l - v) % 4 == 0;\n\n  loop invariant l == \\at(n, Pre) + 9;\n  loop invariant m == \\at(m, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant (v - l) % 4 == 0;\n\n  loop invariant v <= \\at(n, Pre) + 9;\n  loop invariant (v - (\\at(n, Pre) + 9)) % 4 == 0;\n  loop invariant (\\at(n, Pre) + 9 == 0) <==> (o == 0);\n  loop assigns o, v;\n*/\nwhile (v>3) {\n      o = o*2;\n      if (v+6<=v+l) {\n          o = o*o;\n      }\n      v = v-4;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b){\n  int n, u, k, v;\n\n  n=67;\n  u=n+4;\n  k=1;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u>1) {\n      u = u/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == 67) && (k == 1) && (u == 67 + 4) && (n == 67) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (u>1) {\n      u = u/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'n', 'u']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b){\n  int n, u, k, v;\n\n  n=67;\n  u=n+4;\n  k=1;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant u <= n + 4;\n  loop invariant n == 67;\n  loop invariant a == \\at(a, Pre);\n  loop invariant b == \\at(b, Pre);\n\n  loop invariant u >= 1;\n  loop assigns u;\n*/\nwhile (u>1) {\n      u = u/2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b){\n  int p, i, e;\n\n  p=(a%14)+4;\n  i=p+4;\n  e=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>=p+1) {\n      e = e*2;\n      e = e*e+e;\n      i = i-3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (e == -5) && (i == \\at(a, Pre) % 14 + 4 + 4) && (p == \\at(a, Pre) % 14 + 4) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>=p+1) {\n      e = e*2;\n      e = e*e+e;\n      i = i-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start >= p at loop-step start + 1; 2; e at loop-step start; 2) + e at loop-step start; 2). Changed: i: i at loop-step start -> i at loop-step start - 3. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; e keeps e at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'e', 'i', 'p']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b){\n  int p, i, e;\n\n  p=(a%14)+4;\n  i=p+4;\n  e=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant a == \\at(a, Pre);\n  loop invariant b == \\at(b, Pre);\n  loop invariant p == (\\at(a, Pre) % 14) + 4;\n  loop invariant (i - p - 1) % 3 == 0;\n  loop invariant p - 2 <= i;\n  loop invariant i <= p + 4;\n  loop invariant i >= p - 2;\n\n  loop invariant e >= -5;\n  loop invariant p == (a % 14) + 4;\n  loop invariant a == \\at(a, Pre) &&\n                 b == \\at(b, Pre) &&\n                 p == (a % 14) + 4 &&\n                 i >= p - 2 &&\n                 i <= p + 4 &&\n                 (e == -5 || e == 90 || e == 32580);\n  loop invariant ((i - (p + 4)) % 3) == 0;\n  loop invariant e % 5 == 0;\n  loop assigns e, i;\n*/\nwhile (i>=p+1) {\n      e = e*2;\n      e = e*e+e;\n      i = i-3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int q){\n  int v, y, t;\n\n  v=q;\n  y=2;\n  t=y;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (y+1<=v) {\n      t = t-t;\n      t = t+1;\n      y = y+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (t == 2) && (y == 2) && (v == \\at(q, Pre)) && (q == \\at(q, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (y+1<=v) {\n      t = t-t;\n      t = t+1;\n      y = y+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (y at loop-step start + 1 <= v at loop-step start). Changed: t: t at loop-step start -> t at loop-step start - t at loop-step start + 1; y: y at loop-step start -> y at loop-step start + 1. Unchanged: k keeps k at loop-step start; q keeps q at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'q', 't', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int q){\n  int v, y, t;\n\n  v=q;\n  y=2;\n  t=y;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant v == q;\n  loop invariant q == \\at(q, Pre);\n  loop invariant k == \\at(k, Pre);\n\n  loop invariant y >= 2;\n  loop invariant t >= 0;\n  loop invariant v == \\at(q, Pre) && (t == 1 || t == 2) && y >= 2;\n\n  loop invariant t <= 2;\n  loop invariant (t >= 0);\n  loop invariant (y >= 2);\n  loop invariant 1 <= t <= 2;\n  loop assigns t, y;\n*/\nwhile (y+1<=v) {\n      t = t-t;\n      t = t+1;\n      y = y+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m){\n  int o, d, v, u;\n\n  o=m+25;\n  d=1;\n  v=a;\n  u=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (d<o) {\n      d = d*2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (d<o) {\n      d = d*2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'd', 'm', 'o']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m){\n  int o, d, v, u;\n\n  o=m+25;\n  d=1;\n  v=a;\n  u=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant o == m + 25;\n  loop invariant m == \\at(m, Pre);\n  loop invariant a == \\at(a, Pre);\n  loop invariant d >= 1;\n  loop invariant d < o ==> o - d > 0;\n  loop invariant o == \\at(m, Pre) + 25;\n  loop invariant d == 1 || d % 2 == 0;\n  loop invariant d > 0;\n\n  loop assigns d;\n*/\nwhile (d<o) {\n      d = d*2;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int b, l, v;\n\n  b=(n%21)+8;\n  l=0;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (b>=b) {\n      v = v+l;\n      l = l;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (b>=b) {\n      v = v+l;\n      l = l;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int b, l, v;\n\n  b=(n%21)+8;\n  l=0;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 0;\n\n  loop invariant v == b;\n  loop invariant b == (n % 21) + 8;\n  loop invariant n == \\at(n, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant -12 <= b;\n  loop invariant b <= 28;\n  loop assigns v, l;\n*/\nwhile (b>=b) {\n      v = v+l;\n      l = l;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p){\n  int k, f, h, o;\n\n  k=27;\n  f=k;\n  h=k;\n  o=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (f-3>=0) {\n      if (h+5<=k) {\n          h = h+5;\n      }\n      else {\n          h = k;\n      }\n      h = h+o;\n      o = o+o;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (o == 27) && (h == 27) && (f == 27) && (k == 27) && (p == \\at(p, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (f-3>=0) {\n      if (h+5<=k) {\n          h = h+5;\n      }\n      else {\n          h = k;\n      }\n      h = h+o;\n      o = o+o;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (h at loop-step start + 5 <= k at loop-step start; f at loop-step start - 3 >= 0; f at loop-step start - 3 >= 0). Changed: h: h at loop-step start -> k at loop-step start + o at loop-step start; o: o at loop-step start -> o at loop-step start + o at loop-step start. Unchanged: f keeps f at loop-step start; k keeps k at loop-step start; n keeps n at loop-step start; p keeps p at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['f', 'h', 'k', 'n', 'o', 'p']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p){\n  int k, f, h, o;\n\n  k=27;\n  f=k;\n  h=k;\n  o=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant f == 27;\n  loop invariant k == 27;\n  loop invariant n == \\at(n, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant o > 0;\n  loop invariant h >= k;\n  loop invariant h <= k + o;\n  loop invariant h - k <= o;\n  loop invariant o >= 27;\n  loop invariant o % 27 == 0;\n  loop invariant h <= o;\n  loop invariant f == k;\n\n  loop invariant f >= 3;\n  loop assigns h, o;\n*/\nwhile (f-3>=0) {\n      if (h+5<=k) {\n          h = h+5;\n      }\n      else {\n          h = k;\n      }\n      h = h+o;\n      o = o+o;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int k, i, v;\n\n  k=34;\n  i=k;\n  v=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      if (v+5<k) {\n          v = v+5;\n      }\n      v = v-v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -8) && (i == 34) && (k == 34) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      if (v+5<k) {\n          v = v+5;\n      }\n      v = v-v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 5 < k at loop-step start; i at loop-step start > 0; i at loop-step start > 0). Changed: i: i at loop-step start -> i at loop-step start - 1; v: v at loop-step start -> v at loop-step start - v at loop-step start. Unchanged: k keeps k at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int k, i, v;\n\n  k=34;\n  i=k;\n  v=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i >= 0;\n  loop invariant i <= k;\n  loop invariant v == 0 || (i == k && v == -8);\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant k == 34;\n  loop invariant i <= 34;\n  loop invariant v <= 0;\n  loop invariant 0 <= i;\n  loop assigns i, v;\n*/\nwhile (i>0) {\n      if (v+5<k) {\n          v = v+5;\n      }\n      v = v-v;\n      i = i-1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int p){\n  int i, l, v;\n\n  i=b;\n  l=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (l+1<=i) {\n      if (l+1<=b+i) {\n          v = v+1;\n      }\n      l = l+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (l+1<=i) {\n      if (l+1<=b+i) {\n          v = v+1;\n      }\n      l = l+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int p){\n  int i, l, v;\n\n  i=b;\n  l=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i == b;\n  loop invariant b == \\at(b, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant l >= 0;\n  loop invariant v >= -1;\n  loop invariant v <= l - 1;\n\n  loop invariant v == l - 1;\n  loop invariant (b >= 0) ==> (v == l - 1);\n\n  loop invariant (b + i) < 0 ==> (v == -1);\n  loop invariant ((b + i) >= 0 && l <= b + i) ==> (v == -1 + l);\n  loop invariant ((b + i) >= 0 && l >  b + i) ==> (v == -1 + (b + i));\n  loop invariant 0 <= l;\n  loop invariant -1 <= v;\n  loop assigns l, v;\n*/\nwhile (l+1<=i) {\n      if (l+1<=b+i) {\n          v = v+1;\n      }\n      l = l+1;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int q){\n  int h, u, p;\n\n  h=b;\n  u=1;\n  p=u;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (u<=h/3) {\n      p = p*2;\n      p = p*p;\n      u = u*3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (u<=h/3) {\n      p = p*2;\n      p = p*p;\n      u = u*3;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'h', 'p', 'q', 'u']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int q){\n  int h, u, p;\n\n  h=b;\n  u=1;\n  p=u;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant p >= u;\n  loop invariant p >= 1;\n  loop invariant u >= 1;\n  loop invariant h == b;\n  loop invariant (h >= 1) ==> u <= h;\n  loop invariant b == \\at(b, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant h == \\at(b, Pre);\n  loop invariant p >= 1 && (p == 1 || p % 4 == 0);\n  loop invariant u >= 1 && (u == 1 || u % 3 == 0);\n  loop invariant (p == 1) <==> (u == 1);\n  loop assigns p, u;\n*/\nwhile (u<=h/3) {\n      p = p*2;\n      p = p*p;\n      u = u*3;\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int p){\n  int u, v, e, n;\n\n  u=p-7;\n  v=0;\n  e=u;\n  n=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (e!=0&&n!=0) {\n      if (e>n) {\n          e = e-n;\n      }\n      else {\n          n = n-e;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (n == 3) && (e == \\at(p, Pre) - 7) && (v == 0) && (u == \\at(p, Pre) - 7) && (p == \\at(p, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (e!=0&&n!=0) {\n      if (e>n) {\n          e = e-n;\n      }\n      else {\n          n = n-e;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (e at loop-step start > n at loop-step start; n at loop-step start != 0; e at loop-step start != 0; n at loop-step start != 0; e at loop-step start != 0). Changed: n: n at loop-step start -> n at loop-step start - e at loop-step start. Unchanged: b keeps b at loop-step start; e keeps e at loop-step start; p keeps p at loop-step start; u keeps u at loop-step start; v keeps v at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'e', 'n', 'p', 'u']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int p){\n  int u, v, e, n;\n\n  u=p-7;\n  v=0;\n  e=u;\n  n=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant u == \\at(p, Pre) - 7;\n  loop invariant p == \\at(p, Pre);\n  loop invariant b == \\at(b, Pre);\n  loop invariant n >= 0;\n  loop invariant u == p - 7;\n  loop invariant e <= u;\n\n  loop invariant (e > n) ==> (e - n) >= 0;\n  loop invariant (e <= n) ==> (n - e) >= 0;\n  loop assigns e, n;\n*/\nwhile (e!=0&&n!=0) {\n      if (e>n) {\n          e = e-n;\n      }\n      else {\n          n = n-e;\n      }\n  }\n\n}\n"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m){\n  int x, j, i, b;\n\n  x=35;\n  j=x;\n  i=5;\n  b=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (j-4>=0) {\n      if (i+6<=x) {\n          i = i+6;\n      }\n      else {\n          i = x;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (b == 3) && (i == 5) && (j == 35) && (x == 35) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (j-4>=0) {\n      if (i+6<=x) {\n          i = i+6;\n      }\n      else {\n          i = x;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i at loop-step start + 6 <= x at loop-step start; j at loop-step start - 4 >= 0; j at loop-step start - 4 >= 0). Changed: i: i at loop-step start -> x at loop-step start. Unchanged: a keeps a at loop-step start; b keeps b at loop-step start; j keeps j at loop-step start; m keeps m at loop-step start; x keeps x at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'j', 'm', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m){\n  int x, j, i, b;\n\n  x=35;\n  j=x;\n  i=5;\n  b=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant m == \\at(m, Pre);\n  loop invariant a == \\at(a, Pre);\n  loop invariant (i == x) || (((i - 5) % 6) == 0 && 5 <= i && i <= x);\n  loop invariant 5 <= i;\n  loop invariant i <= x;\n  loop invariant j == 35;\n  loop invariant x == 35;\n  loop invariant i >= 5;\n  loop invariant j >= 4;\n  loop invariant (i == 5) || (i == 11) || (i == 17) || (i == 23) || (i == 29) || (i == 35);\n  loop invariant 5 <= i && i <= x && ((i - 5) % 6 == 0 || i == x);\n  loop invariant i % 6 == 5;\n  loop assigns i;\n*/\nwhile (j-4>=0) {\n      if (i+6<=x) {\n          i = i+6;\n      }\n      else {\n          i = x;\n      }\n  }\n\n}\n"}
