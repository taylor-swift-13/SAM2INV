{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -1) && (b == 0) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (b at loop-step start + 4 > v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start) || b at loop-step start + 4 <= v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start; 2). Changed: b: b at loop-step start -> b at loop-step start + 1; v: v at loop-step start -> (v at loop-step start. Unchanged: i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v+1<=i) {\n      v = v+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 1 <= i at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   (-1 && -1 + -1) && 2 + 1 <= 53 && 0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2 + 1) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v-1>=0) {\n      v = v-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start - 1 >= 0). Changed: v: v at loop-step start -> v at loop-step start - 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "chosen": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (b <= i) && (0 <= b) && (v == -1 || v == 0);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant b <= i;\n  loop invariant v >= -1;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant 0 <= b;\n  loop invariant i == 53;\n  loop invariant -1 <= v;\n  loop assigns b, v;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant v <= i;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= -1;\n  loop invariant i == 53;\n\n  loop assigns v;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (0 <= v);\n  loop invariant (v <= i);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= 0;\n  loop invariant v <= i;\n  loop invariant i == 53;\n  loop invariant 0 <= v;\n  loop assigns v;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}", "rejected": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (b <= i) && (0 <= b) && (v == -1 || v == 0);\n  loop invariant (p == \\at(p, Pre)) && (q == \\at(q, Pre));\n  loop invariant b <= i;\n  loop invariant v >= -1 && p == \\at(p, Pre) && q == \\at(q, Pre);\n  loop invariant 0 <= b && b <= i;\n  loop invariant v >= -1;\n  loop invariant i == 53;\n  loop invariant p == \\at(p, Pre) && q == \\at(q, Pre);\n  loop invariant 0 <= b;\n  loop invariant -1 <= v;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop assigns b, v;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant (p == \\at(p, Pre)) && (q == \\at(q, Pre));\n  loop invariant v <= i;\n  loop invariant p == \\at(p, Pre) && q == \\at(q, Pre) && v >= -1;\n  loop invariant v >= -1 && v <= i;\n  loop invariant i == 53;\n  loop invariant p == \\at(p, Pre) && q == \\at(q, Pre);\n\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop assigns v;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (0 <= v) && (v <= i);\n  loop invariant (p == \\at(p, Pre)) && (q == \\at(q, Pre));\n  loop invariant p == \\at(p, Pre) && q == \\at(q, Pre);\n  loop invariant v >= 0;\n  loop invariant v >= 0 && v <= i;\n  loop invariant i == 53;\n  loop invariant 0 <= v;\n  loop invariant v <= i;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop assigns v;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -1) && (b == 0) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (b at loop-step start + 4 > v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start) || b at loop-step start + 4 <= v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start; 2). Changed: b: b at loop-step start -> b at loop-step start + 1; v: v at loop-step start -> (v at loop-step start. Unchanged: i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v+1<=i) {\n      v = v+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 1 <= i at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   (-1 && -1 + -1) && 2 + 1 <= 53 && 0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2 + 1) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v-1>=0) {\n      v = v-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start - 1 >= 0). Changed: v: v at loop-step start -> v at loop-step start - 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "chosen": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (b <= i) && (0 <= b) && (v == -1 || v == 0);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant b <= i;\n  loop invariant v >= -1;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant 0 <= b;\n  loop invariant i == 53;\n  loop invariant -1 <= v;\n  loop assigns b, v;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant v <= i;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= -1;\n  loop invariant i == 53;\n\n  loop assigns v;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (0 <= v);\n  loop invariant (v <= i);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= 0;\n  loop invariant v <= i;\n  loop invariant i == 53;\n  loop invariant 0 <= v;\n  loop assigns v;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}", "rejected": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /*@\n    loop invariant (b <= i) && (0 <= b) && (v == -1 || v == 0);\n    loop invariant (p == \\at(p, Pre)) && (q == \\at(q, Pre));\n    loop assigns b, v;\n  */\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /*@\n    loop invariant (0 <= v) && (v <= i);\n    loop invariant (p == \\at(p, Pre)) && (q == \\at(q, Pre));\n    loop assigns v;\n  */\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /*@\n    loop invariant (0 <= v) && (v <= i);\n    loop invariant (p == \\at(p, Pre)) && (q == \\at(q, Pre));\n    loop assigns v;\n  */\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -1) && (b == 0) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (b at loop-step start + 4 > v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start) || b at loop-step start + 4 <= v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start; 2). Changed: b: b at loop-step start -> b at loop-step start + 1; v: v at loop-step start -> (v at loop-step start. Unchanged: i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v+1<=i) {\n      v = v+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 1 <= i at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   (-1 && -1 + -1) && 2 + 1 <= 53 && 0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2 + 1) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v-1>=0) {\n      v = v-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start - 1 >= 0). Changed: v: v at loop-step start -> v at loop-step start - 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "chosen": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (b <= i) && (0 <= b) && (v == -1 || v == 0);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant b <= i;\n  loop invariant v >= -1;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant 0 <= b;\n  loop invariant i == 53;\n  loop invariant -1 <= v;\n  loop assigns b, v;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant v <= i;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= -1;\n  loop invariant i == 53;\n\n  loop assigns v;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (0 <= v);\n  loop invariant (v <= i);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= 0;\n  loop invariant v <= i;\n  loop invariant i == 53;\n  loop invariant 0 <= v;\n  loop assigns v;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}", "rejected": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant b <= i;\n    loop invariant v >= -1 && p == \\at(p, Pre) && q == \\at(q, Pre);\n    loop assigns b, v;\n  */\n  while (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant v <= i;\n    loop invariant p == \\at(p, Pre) && q == \\at(q, Pre) && v >= -1;\n    loop assigns v;\n  */\n  while (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant p == \\at(p, Pre) && q == \\at(q, Pre);\n    loop invariant v >= 0;\n    loop assigns v;\n  */\n  while (v-1>=0) {\n      v = v-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -1) && (b == 0) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (b at loop-step start + 4 > v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start) || b at loop-step start + 4 <= v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start; 2). Changed: b: b at loop-step start -> b at loop-step start + 1; v: v at loop-step start -> (v at loop-step start. Unchanged: i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v+1<=i) {\n      v = v+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 1 <= i at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   (-1 && -1 + -1) && 2 + 1 <= 53 && 0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2 + 1) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v-1>=0) {\n      v = v-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start - 1 >= 0). Changed: v: v at loop-step start -> v at loop-step start - 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "chosen": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (b <= i) && (0 <= b) && (v == -1 || v == 0);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant b <= i;\n  loop invariant v >= -1;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant 0 <= b;\n  loop invariant i == 53;\n  loop invariant -1 <= v;\n  loop assigns b, v;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant v <= i;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= -1;\n  loop invariant i == 53;\n\n  loop assigns v;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (0 <= v);\n  loop invariant (v <= i);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= 0;\n  loop invariant v <= i;\n  loop invariant i == 53;\n  loop invariant 0 <= v;\n  loop assigns v;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}", "rejected": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /*@\n    loop invariant 0 <= b && b <= i;\n    loop invariant v >= -1;\n    loop invariant i == 53;\n    loop invariant p == \\at(p, Pre) && q == \\at(q, Pre);\n    loop assigns v, b;\n    loop variant i - b;\n  */\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /*@\n    loop invariant v >= -1 && v <= i;\n    loop invariant i == 53;\n    loop invariant b >= 0 && b <= i;\n    loop invariant p == \\at(p, Pre) && q == \\at(q, Pre);\n    loop assigns v;\n    loop variant i - v;\n  */\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /*@\n    loop invariant v >= 0 && v <= i;\n    loop invariant i == 53;\n    loop invariant b >= 0 && b <= i;\n    loop invariant p == \\at(p, Pre) && q == \\at(q, Pre);\n    loop assigns v;\n    loop variant v;\n  */\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -1) && (b == 0) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (b at loop-step start + 4 > v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start) || b at loop-step start + 4 <= v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start; 2). Changed: b: b at loop-step start -> b at loop-step start + 1; v: v at loop-step start -> (v at loop-step start. Unchanged: i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v+1<=i) {\n      v = v+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 1 <= i at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   (-1 && -1 + -1) && 2 + 1 <= 53 && 0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2 + 1) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v-1>=0) {\n      v = v-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start - 1 >= 0). Changed: v: v at loop-step start -> v at loop-step start - 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "chosen": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (b <= i) && (0 <= b) && (v == -1 || v == 0);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant b <= i;\n  loop invariant v >= -1;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant 0 <= b;\n  loop invariant i == 53;\n  loop invariant -1 <= v;\n  loop assigns b, v;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant v <= i;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= -1;\n  loop invariant i == 53;\n\n  loop assigns v;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (0 <= v);\n  loop invariant (v <= i);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= 0;\n  loop invariant v <= i;\n  loop invariant i == 53;\n  loop invariant 0 <= v;\n  loop assigns v;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}", "rejected": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant i == 53;\n    loop invariant 0 <= b;\n    loop invariant b <= i;\n    loop invariant -1 <= v;\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns b, v;\n  */\n  while (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant i == 53;\n    loop invariant 0 <= v;\n    loop invariant v <= i;\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns v;\n  */\n  while (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant i == 53;\n    loop invariant 0 <= v;\n    loop invariant v <= i;\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns v;\n  */\n  while (v-1>=0) {\n      v = v-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (v == -1) && (b == 0) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (b at loop-step start + 4 > v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start) || b at loop-step start + 4 <= v at loop-step start; v at loop-step start + v at loop-step start + i at loop-step start; b at loop-step start <= i at loop-step start - 1; v at loop-step start + v at loop-step start; 2). Changed: b: b at loop-step start -> b at loop-step start + 1; v: v at loop-step start -> (v at loop-step start. Unchanged: i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v+1<=i) {\n      v = v+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start + 1 <= i at loop-step start). Changed: v: v at loop-step start -> v at loop-step start + 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   (-1 && -1 + -1) && 2 + 1 <= 53 && 0 + 4 <= -1 && -1 + -1 + 53 && 0 <= 53 - 1 && (v == (-1 && -1 + -1) && 2 + 1) && (b == 0 + 1) && (i == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (v-1>=0) {\n      v = v-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v at loop-step start - 1 >= 0). Changed: v: v at loop-step start -> v at loop-step start - 1. Unchanged: b keeps b at loop-step start; i keeps i at loop-step start; p keeps p at loop-step start; q keeps q at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "chosen": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (b <= i) && (0 <= b) && (v == -1 || v == 0);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant b <= i;\n  loop invariant v >= -1;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant 0 <= b;\n  loop invariant i == 53;\n  loop invariant -1 <= v;\n  loop assigns b, v;\n*/\nwhile (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant v <= i;\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= -1;\n  loop invariant i == 53;\n\n  loop assigns v;\n*/\nwhile (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant (0 <= v);\n  loop invariant (v <= i);\n  loop invariant (p == \\at(p, Pre));\n  loop invariant (q == \\at(q, Pre));\n  loop invariant p == \\at(p, Pre);\n  loop invariant q == \\at(q, Pre);\n  loop invariant v >= 0;\n  loop invariant v <= i;\n  loop invariant i == 53;\n  loop invariant 0 <= v;\n  loop assigns v;\n*/\nwhile (v-1>=0) {\n      v = v-1;\n  }\n\n}", "rejected": "int main1(int p,int q){\n  int i, b, v;\n\n  i=53;\n  b=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant i == 53;\n    loop invariant b <= i;\n    loop assigns b, v;\n  */\n  while (b<=i-1) {\n      v = v*v+v;\n      if (b+4<=v+i) {\n          v = v*2;\n      }\n      b = b+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant i == 53;\n    loop invariant b == i;\n    loop assigns v;\n  */\n  while (v+1<=i) {\n      v = v+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant i == 53;\n    loop invariant b == i;\n    loop assigns v;\n  */\n  while (v-1>=0) {\n      v = v-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (k == -6) && (s == 0) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start < l at loop-step start). Changed: k: k at loop-step start -> k at loop-step start - k at loop-step start + -3; s: s at loop-step start -> s at loop-step start + 1. Unchanged: b keeps b at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 < 35 && (k == -6 - -6 + -3) && (s == 0 + 1) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s>=3) {\n      s = s-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start >= 3). Changed: s: s at loop-step start -> s at loop-step start - 3. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   emp\n\n2. Loop Code:\n```c\nwhile (s<=k-1) {\n      s = s+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "chosen": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant k <= -3;\n  loop invariant 0 <= s;\n  loop invariant k == -6 || k == -3;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l && ((s == 0) ==> (k == -6)) && ((s > 0) ==> (k == -3)));\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant s >= 0;\n  loop invariant s <= l && (k == -6 || k == -3) && l == 35 && b == \\at(b, Pre) && m == \\at(m, Pre);\n  loop assigns k, s;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant (s % 3) == (l % 3);\n  loop invariant 0 <= s;\n  loop invariant s <= l;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n\n  loop assigns s;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant k == -3;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant 0 <= s;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35);\n  loop invariant s >= 0;\n\n  loop assigns s;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}", "rejected": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant k <= -3;\n  loop invariant 0 <= s;\n  loop invariant 0 <= s && s <= l;\n  loop invariant k == -6 || k == -3;\n  loop invariant b == \\at(b,Pre);\n  loop invariant m == \\at(m,Pre);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l && ((s == 0) ==> (k == -6)) && ((s > 0) ==> (k == -3)));\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant s >= 0;\n  loop invariant s <= l && (k == -6 || k == -3) && l == 35 && b == \\at(b, Pre) && m == \\at(m, Pre);\n  loop assigns k, s;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant (s % 3) == (l % 3);\n  loop invariant 0 <= s && s <= l;\n  loop invariant b == \\at(b,Pre);\n  loop invariant m == \\at(m,Pre);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n\n  loop invariant s <= l;\n  loop invariant b == \\at(b, Pre) && m == \\at(m, Pre);\n  loop assigns s;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant k == -3;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant 0 <= s && s <= l;\n  loop invariant b == \\at(b,Pre);\n  loop invariant m == \\at(m,Pre);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35);\n  loop invariant s >= 0;\n\n  loop invariant b == \\at(b, Pre) && m == \\at(m, Pre);\n  loop assigns s;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (k == -6) && (s == 0) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start < l at loop-step start). Changed: k: k at loop-step start -> k at loop-step start - k at loop-step start + -3; s: s at loop-step start -> s at loop-step start + 1. Unchanged: b keeps b at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 < 35 && (k == -6 - -6 + -3) && (s == 0 + 1) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s>=3) {\n      s = s-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start >= 3). Changed: s: s at loop-step start -> s at loop-step start - 3. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   emp\n\n2. Loop Code:\n```c\nwhile (s<=k-1) {\n      s = s+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "chosen": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant k <= -3;\n  loop invariant 0 <= s;\n  loop invariant k == -6 || k == -3;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l && ((s == 0) ==> (k == -6)) && ((s > 0) ==> (k == -3)));\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant s >= 0;\n  loop invariant s <= l && (k == -6 || k == -3) && l == 35 && b == \\at(b, Pre) && m == \\at(m, Pre);\n  loop assigns k, s;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant (s % 3) == (l % 3);\n  loop invariant 0 <= s;\n  loop invariant s <= l;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n\n  loop assigns s;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant k == -3;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant 0 <= s;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35);\n  loop invariant s >= 0;\n\n  loop assigns s;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}", "rejected": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant l == 35;\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant s <= l;\n    loop invariant k <= -3;\n    loop invariant 0 <= s;\n    loop assigns k, s;\n    loop variant l - s;\n  */\n  while (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant l == 35;\n    loop invariant k == -3;\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant (s % 3) == (l % 3);\n    loop assigns s;\n  */\n  while (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant l == 35;\n    loop invariant k == -3;\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant s <= l;\n    loop assigns s;\n  */\n  while (s<=k-1) {\n      s = s+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (k == -6) && (s == 0) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start < l at loop-step start). Changed: k: k at loop-step start -> k at loop-step start - k at loop-step start + -3; s: s at loop-step start -> s at loop-step start + 1. Unchanged: b keeps b at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 < 35 && (k == -6 - -6 + -3) && (s == 0 + 1) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s>=3) {\n      s = s-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start >= 3). Changed: s: s at loop-step start -> s at loop-step start - 3. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   emp\n\n2. Loop Code:\n```c\nwhile (s<=k-1) {\n      s = s+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "chosen": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant k <= -3;\n  loop invariant 0 <= s;\n  loop invariant k == -6 || k == -3;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l && ((s == 0) ==> (k == -6)) && ((s > 0) ==> (k == -3)));\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant s >= 0;\n  loop invariant s <= l && (k == -6 || k == -3) && l == 35 && b == \\at(b, Pre) && m == \\at(m, Pre);\n  loop assigns k, s;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant (s % 3) == (l % 3);\n  loop invariant 0 <= s;\n  loop invariant s <= l;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n\n  loop assigns s;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant k == -3;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant 0 <= s;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35);\n  loop invariant s >= 0;\n\n  loop assigns s;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}", "rejected": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /*@\n    loop invariant 0 <= s && s <= l;\n    loop invariant k == -6 || k == -3;\n    loop invariant l == 35;\n    loop invariant b == \\at(b,Pre);\n    loop invariant m == \\at(m,Pre);\n    loop assigns k, s;\n    loop variant l - s;\n  */\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /*@\n    loop invariant 0 <= s && s <= l;\n    loop invariant l == 35;\n    loop invariant b == \\at(b,Pre);\n    loop invariant m == \\at(m,Pre);\n    loop assigns s;\n    loop variant s;\n  */\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /*@\n    loop invariant 0 <= s && s <= l;\n    loop invariant k == -6 || k == -3;\n    loop invariant l == 35;\n    loop invariant b == \\at(b,Pre);\n    loop invariant m == \\at(m,Pre);\n    loop assigns s;\n  */\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (k == -6) && (s == 0) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start < l at loop-step start). Changed: k: k at loop-step start -> k at loop-step start - k at loop-step start + -3; s: s at loop-step start -> s at loop-step start + 1. Unchanged: b keeps b at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 < 35 && (k == -6 - -6 + -3) && (s == 0 + 1) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s>=3) {\n      s = s-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start >= 3). Changed: s: s at loop-step start -> s at loop-step start - 3. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   emp\n\n2. Loop Code:\n```c\nwhile (s<=k-1) {\n      s = s+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "chosen": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant k <= -3;\n  loop invariant 0 <= s;\n  loop invariant k == -6 || k == -3;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l && ((s == 0) ==> (k == -6)) && ((s > 0) ==> (k == -3)));\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant s >= 0;\n  loop invariant s <= l && (k == -6 || k == -3) && l == 35 && b == \\at(b, Pre) && m == \\at(m, Pre);\n  loop assigns k, s;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant (s % 3) == (l % 3);\n  loop invariant 0 <= s;\n  loop invariant s <= l;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n\n  loop assigns s;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant k == -3;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant 0 <= s;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35);\n  loop invariant s >= 0;\n\n  loop assigns s;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}", "rejected": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l && ((s == 0) ==> (k == -6)) && ((s > 0) ==> (k == -3)));\n    loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n    loop assigns k, s;\n  */\n  while (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l);\n    loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n    loop assigns s;\n  */\n  while (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n    loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35);\n    loop assigns s;\n  */\n  while (s<=k-1) {\n      s = s+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (k == -6) && (s == 0) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start < l at loop-step start). Changed: k: k at loop-step start -> k at loop-step start - k at loop-step start + -3; s: s at loop-step start -> s at loop-step start + 1. Unchanged: b keeps b at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 < 35 && (k == -6 - -6 + -3) && (s == 0 + 1) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s>=3) {\n      s = s-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start >= 3). Changed: s: s at loop-step start -> s at loop-step start - 3. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   emp\n\n2. Loop Code:\n```c\nwhile (s<=k-1) {\n      s = s+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "chosen": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant k <= -3;\n  loop invariant 0 <= s;\n  loop invariant k == -6 || k == -3;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l && ((s == 0) ==> (k == -6)) && ((s > 0) ==> (k == -3)));\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant s >= 0;\n  loop invariant s <= l && (k == -6 || k == -3) && l == 35 && b == \\at(b, Pre) && m == \\at(m, Pre);\n  loop assigns k, s;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant (s % 3) == (l % 3);\n  loop invariant 0 <= s;\n  loop invariant s <= l;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n\n  loop assigns s;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant k == -3;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant 0 <= s;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35);\n  loop invariant s >= 0;\n\n  loop assigns s;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}", "rejected": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant k == -6 || k == -3;\n    loop invariant s <= l;\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop assigns k, s;\n    loop variant l - s;\n  */\n  while (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n     loop invariant s % 3 == 1;\n     loop invariant k == -3;\n     loop invariant l == 35;\n     loop invariant b == \\at(b, Pre);\n     loop invariant m == \\at(m, Pre);\n     loop assigns s;\n     loop variant s;\n  */\n  while (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n     loop invariant b == \\at(b, Pre);\n     loop invariant m == \\at(m, Pre);\n     loop invariant l == 35;\n     loop invariant k == -3;\n     loop invariant s >= 0;\n     loop assigns s;\n  */\n  while (s<=k-1) {\n      s = s+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n4. **`loop invariant` keyword nesting:**\n   The phrase `loop invariant` is the annotation-line prefix, not part of the ACSL expression language.\n   It must appear **exactly once per line, at the very start**. Never write it inside `==>`, `&&`, `||`, or any sub-expression.\n   When you see a template placeholder such as `PLACE_HOLDER_x` inside an already-written `loop invariant` line, replace only the placeholder with a pure ACSL expression — not with a new `loop invariant` statement.\n\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "Follow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER;\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop 0 Context ###\n\n1. State Before Loop Entry:\n   (k == -6) && (s == 0) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start < l at loop-step start). Changed: k: k at loop-step start -> k at loop-step start - k at loop-step start + -3; s: s at loop-step start -> s at loop-step start + 1. Unchanged: b keeps b at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 1 Context ###\n\n1. State Before Loop Entry:\n   0 < 35 && (k == -6 - -6 + -3) && (s == 0 + 1) && (l == 35) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (s>=3) {\n      s = s-3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (s at loop-step start >= 3). Changed: s: s at loop-step start -> s at loop-step start - 3. Unchanged: b keeps b at loop-step start; k keeps k at loop-step start; l keeps l at loop-step start; m keeps m at loop-step start.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\n### Loop 2 Context ###\n\n1. State Before Loop Entry:\n   emp\n\n2. Loop Code:\n```c\nwhile (s<=k-1) {\n      s = s+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'k', 'l', 'm', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "chosen": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant k <= -3;\n  loop invariant 0 <= s;\n  loop invariant k == -6 || k == -3;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l && ((s == 0) ==> (k == -6)) && ((s > 0) ==> (k == -3)));\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant s >= 0;\n  loop invariant s <= l && (k == -6 || k == -3) && l == 35 && b == \\at(b, Pre) && m == \\at(m, Pre);\n  loop assigns k, s;\n*/\nwhile (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant (s % 3) == (l % 3);\n  loop invariant 0 <= s;\n  loop invariant s <= l;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s <= l);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n\n  loop assigns s;\n*/\nwhile (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 35;\n  loop invariant k == -3;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant s <= l;\n  loop invariant 0 <= s;\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35 && s >= 0);\n  loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && l == 35);\n  loop invariant s >= 0;\n\n  loop assigns s;\n*/\nwhile (s<=k-1) {\n      s = s+1;\n  }\n\n}", "rejected": "int main1(int b,int m){\n  int l, s, k;\n\n  l=35;\n  s=0;\n  k=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n  loop invariant s >= 0;\n  loop invariant s <= l && (k == -6 || k == -3) && l == 35 && b == \\at(b, Pre) && m == \\at(m, Pre);\n  loop assigns k, s;\n  */\n  while (s<l) {\n      k = k-k;\n      k = k+(-3);\n      s = s+1;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n  loop invariant s <= l;\n  loop invariant b == \\at(b, Pre) && m == \\at(m, Pre);\n  loop assigns s;\n  */\n  while (s>=3) {\n      s = s-3;\n  }\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n  loop invariant s <= k;\n  loop invariant b == \\at(b, Pre) && m == \\at(m, Pre);\n  loop assigns s;\n  */\n  while (s<=k-1) {\n      s = s+1;\n  }\n\n}"}
