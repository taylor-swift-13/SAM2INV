{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v;\n\n  l=(k%12)+12;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      if (v+6<l) {\n          v = v+i;\n      }\n      i = i+5;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      if (v+6<l) {\n          v = v+i;\n      }\n      i = i+5;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v;\n\n  l=(k%12)+12;\n  i=0;\n  v=m;\n\n  \n  /*@\n\n    loop invariant i % 5 == 0;\n\n    loop invariant 0 <= i && i <= l + 4;\n\n    loop invariant (i == 0 ==> v == \\at(m, Pre)) && (i > 0 ==> (v == 0 || (v % 5 == 0 && v < l)));\n\n    loop assigns i, v;\n\n  */\nwhile (i<l) {\n      v = v-v;\n      if (v+6<l) {\n          v = v+i;\n      }\n      i = i+5;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m){\n  int l, i, v, j, r, h, z;\n\n  l=10;\n  i=0;\n  v=i;\n  j=3;\n  r=b;\n  h=8;\n  z=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      i = i+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      i = i+2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'h', 'i', 'j', 'l', 'm', 'r', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m){\n  int l, i, v, j, r, h, z;\n\n  l=10;\n  i=0;\n  v=i;\n  j=3;\n  r=b;\n  h=8;\n  z=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant i % 2 == 0;\n    loop invariant i == 2 * (i / 2);\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop assigns i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      i = i+2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int q){\n  int l, i, v, x, d, n, y, a, c;\n\n  l=36;\n  i=1;\n  v=5;\n  x=-5;\n  d=m;\n  n=-3;\n  y=k;\n  a=l;\n  c=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      i = i*2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      i = i*2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'd', 'i', 'k', 'l', 'm', 'n', 'q', 'v', 'x', 'y']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int q){\n  int l, i, v, x, d, n, y, a, c;\n\n  l=36;\n  i=1;\n  v=5;\n  x=-5;\n  d=m;\n  n=-3;\n  y=k;\n  a=l;\n  c=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i > 0;\n    loop invariant i <= 2*l;\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant l == 36;\n    loop assigns i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      i = i*2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p){\n  int l, i, v, k, t, r;\n\n  l=66;\n  i=0;\n  v=-1;\n  k=p;\n  t=m;\n  r=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'p', 'r', 't', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p){\n  int l, i, v, k, t, r;\n\n  l=66;\n  i=0;\n  v=-1;\n  k=p;\n  t=m;\n  r=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i <= l;\n    loop invariant l == 66;\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop assigns i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p,int q){\n  int l, i, v, n, k, h, g, u;\n\n  l=25;\n  i=0;\n  v=-6;\n  n=l;\n  k=p;\n  h=-3;\n  g=l;\n  u=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'g', 'h', 'i', 'k', 'l', 'n', 'p', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p,int q){\n  int l, i, v, n, k, h, g, u;\n\n  l=25;\n  i=0;\n  v=-6;\n  n=l;\n  k=p;\n  h=-3;\n  g=l;\n  u=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant l == 25;\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant a == \\at(a, Pre);\n    loop assigns i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int q){\n  int l, i, v, x, y, g, t, f;\n\n  l=52;\n  i=0;\n  v=b;\n  x=i;\n  y=m;\n  g=1;\n  t=q;\n  f=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      x = x*x;\n      y = y+v*x;\n      if (t*t<=l+5) {\n          t = t+x;\n      }\n      i = i+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      x = x*x;\n      y = y+v*x;\n      if (t*t<=l+5) {\n          t = t+x;\n      }\n      i = i+2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'f', 'g', 'i', 'l', 'm', 'q', 't', 'v', 'x', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int q){\n  int l, i, v, x, y, g, t, f;\n\n  l=52;\n  i=0;\n  v=b;\n  x=i;\n  y=m;\n  g=1;\n  t=q;\n  f=m;\n\n  \n  /*@\n\n    loop invariant i % 2 == 0;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant v == \\at(b, Pre) + (i/2) * ((i/2) - 1);\n\n    loop invariant x == 0;\n\n    loop invariant y == \\at(m, Pre);\n\n    loop invariant t == \\at(q, Pre);\n\n    loop assigns v, x, y, t, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+i;\n      x = x*x;\n      y = y+v*x;\n      if (t*t<=l+5) {\n          t = t+x;\n      }\n      i = i+2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int q){\n  int l, i, v, a, h, u, z, x;\n\n  l=54;\n  i=0;\n  v=i;\n  a=q;\n  h=i;\n  u=b;\n  z=k;\n  x=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      a = a-1;\n      v = v*2;\n      a = a+v;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      a = a-1;\n      v = v*2;\n      a = a+v;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'h', 'i', 'k', 'l', 'q', 'u', 'v', 'x', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int q){\n  int l, i, v, a, h, u, z, x;\n\n  l=54;\n  i=0;\n  v=i;\n  a=q;\n  h=i;\n  u=b;\n  z=k;\n  x=3;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant v >= 0;\n\n    loop invariant (a - 2*v - \\at(q, Pre)) % 3 == 0;\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns a, v;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      a = a-1;\n      v = v*2;\n      a = a+v;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p){\n  int l, i, v, k, h, x;\n\n  l=26;\n  i=0;\n  v=2;\n  k=l;\n  h=n;\n  x=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      k = k+v;\n      x = x+p;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      k = k+v;\n      x = x+p;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['h', 'i', 'k', 'l', 'm', 'n', 'p', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p){\n  int l, i, v, k, h, x;\n\n  l=26;\n  i=0;\n  v=2;\n  k=l;\n  h=n;\n  x=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v == i + 2;\n    loop invariant x == m + i * p;\n    loop invariant k == l + (i * (i + 5)) / 2;\n    loop assigns v, k, x, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      k = k+v;\n      x = x+p;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int q){\n  int l, i, v, u, t, e, w, j;\n\n  l=65;\n  i=0;\n  v=n;\n  u=8;\n  t=2;\n  e=l;\n  w=-6;\n  j=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      e = v+u+t;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      e = v+u+t;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'i', 'j', 'k', 'l', 'n', 'q', 't', 'u', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int q){\n  int l, i, v, u, t, e, w, j;\n\n  l=65;\n  i=0;\n  v=n;\n  u=8;\n  t=2;\n  e=l;\n  w=-6;\n  j=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v == n;\n    loop invariant u == 8;\n    loop invariant t == 2;\n    loop invariant l == 65;\n    loop invariant e == v + u + t || e == l;\n    loop assigns e, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      e = v+u+t;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int q){\n  int l, i, v, u, j, n, m, g;\n\n  l=25;\n  i=l;\n  v=-3;\n  u=l;\n  j=5;\n  n=8;\n  m=0;\n  g=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'g', 'i', 'j', 'l', 'm', 'n', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int q){\n  int l, i, v, u, j, n, m, g;\n\n  l=25;\n  i=l;\n  v=-3;\n  u=l;\n  j=5;\n  n=8;\n  m=0;\n  g=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 25;\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant a == \\at(a, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns i;\n    loop variant i;\n  */\n  while (i>0) {\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m){\n  int l, i, v;\n\n  l=49;\n  i=l;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      v = v-v;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      v = v-v;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m){\n  int l, i, v;\n\n  l=49;\n  i=l;\n  v=b;\n\n  \n  /*@\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v == 0 || v == b;\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+1;\n      v = v-v;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n){\n  int l, i, v;\n\n  l=25;\n  i=l;\n  v=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n){\n  int l, i, v;\n\n  l=25;\n  i=l;\n  v=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant l == 25;\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop assigns i;\n    loop variant i;\n  */\n  while (i>0) {\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int q){\n  int l, i, v, d, o, b, r, a;\n\n  l=(n%6)+20;\n  i=l;\n  v=6;\n  d=q;\n  o=k;\n  b=-8;\n  r=i;\n  a=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+2;\n      o = o+2;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+2;\n      o = o+2;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'd', 'i', 'k', 'l', 'n', 'o', 'q', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int q){\n  int l, i, v, d, o, b, r, a;\n\n  l=(n%6)+20;\n  i=l;\n  v=6;\n  d=q;\n  o=k;\n  b=-8;\n  r=i;\n  a=2;\n\n  \n  /*@\n\n    loop invariant ((v - o) == (6 - k));\n\n    loop invariant ((v + 2*i) == (6 + 2*l));\n\n    loop invariant (i >= 0);\n\n    loop invariant (i <= l);\n\n    loop invariant (k == \\at(k, Pre));\n\n    loop assigns v, o, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+2;\n      o = o+2;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p){\n  int l, i, v, j, n, e, b;\n\n  l=11;\n  i=0;\n  v=-4;\n  j=m;\n  n=p;\n  e=m;\n  b=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+j;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+j;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'e', 'i', 'j', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p){\n  int l, i, v, j, n, e, b;\n\n  l=11;\n  i=0;\n  v=-4;\n  j=m;\n  n=p;\n  e=m;\n  b=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v == -4 + i * j;\n    loop invariant l == 11;\n    loop invariant j == m;\n    loop invariant m == \\at(m, Pre);\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+j;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int q){\n  int l, i, v;\n\n  l=35;\n  i=l;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v-v;\n      v = v+v;\n      v = v+v;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v-v;\n      v = v+v;\n      v = v+v;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int q){\n  int l, i, v;\n\n  l=35;\n  i=l;\n  v=a;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant (i == l) ==> (v == a);\n\n    loop invariant (i < l) ==> (v == 0);\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v-v;\n      v = v+v;\n      v = v+v;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v, f, x, h, u, s, z, w;\n\n  l=13;\n  i=0;\n  v=-6;\n  f=i;\n  x=i;\n  h=m;\n  u=3;\n  s=m;\n  z=k;\n  w=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      h = h*h+v;\n      v = v%6;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      h = h*h+v;\n      v = v%6;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'f', 'h', 'i', 'k', 'l', 'm', 's', 'u', 'v', 'w', 'x', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v, f, x, h, u, s, z, w;\n\n  l=13;\n  i=0;\n  v=-6;\n  f=i;\n  x=i;\n  h=m;\n  u=3;\n  s=m;\n  z=k;\n  w=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant l == 13;\n  loop invariant 0 <= i && i <= l;\n  loop invariant i == 0 ==> h == \\at(m,Pre);\n  loop invariant i == 0 ==> v == -6;\n  loop invariant i >= 1 ==> v == v%6;\n  loop assigns h, v, i;\n  loop variant l - i;\n*/\nwhile (i<l) {\n      h = h*h+v;\n      v = v%6;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m){\n  int l, i, v, o, n, c, y;\n\n  l=10;\n  i=l;\n  v=5;\n  o=a;\n  n=b;\n  c=-8;\n  y=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+o;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+o;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'i', 'l', 'm', 'n', 'o', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m){\n  int l, i, v, o, n, c, y;\n\n  l=10;\n  i=l;\n  v=5;\n  o=a;\n  n=b;\n  c=-8;\n  y=i;\n\n  \n  /*@\n\n    loop invariant v + i*o == 5 + l*o;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant o == a;\n\n    loop invariant l == 10;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v+o;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int q){\n  int l, i, v, w, s, z, g, f;\n\n  l=38;\n  i=l;\n  v=-2;\n  w=-6;\n  s=n;\n  z=2;\n  g=q;\n  f=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+w;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+w;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'f', 'g', 'i', 'l', 'n', 'q', 's', 'v', 'w', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int q){\n  int l, i, v, w, s, z, g, f;\n\n  l=38;\n  i=l;\n  v=-2;\n  w=-6;\n  s=n;\n  z=2;\n  g=q;\n  f=b;\n\n  \n  /*@\n\n    loop invariant v + i*w == -2 + l*w;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v+w;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int q){\n  int l, i, v, e;\n\n  l=42;\n  i=0;\n  v=i;\n  e=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+2;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'i', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int q){\n  int l, i, v, e;\n\n  l=42;\n  i=0;\n  v=i;\n  e=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 2*i;\n    loop invariant i <= l;\n    loop invariant l == 42;\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant 0 <= i;\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n){\n  int l, i, v, r, g, b, s;\n\n  l=k+19;\n  i=l;\n  v=m;\n  r=2;\n  g=l;\n  b=-4;\n  s=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'g', 'i', 'k', 'l', 'm', 'n', 'r', 's', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n){\n  int l, i, v, r, g, b, s;\n\n  l=k+19;\n  i=l;\n  v=m;\n  r=2;\n  g=l;\n  b=-4;\n  s=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == k + 19;\n    loop invariant v >= m;\n    loop invariant (m <= l) ==> (v <= l);\n    loop assigns v;\n    loop variant l - v;\n  */\n  while (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p){\n  int l, i, v, a, f, u, s, n;\n\n  l=62;\n  i=l;\n  v=i;\n  a=m;\n  f=i;\n  u=l;\n  s=i;\n  n=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'f', 'i', 'l', 'm', 'n', 'p', 's', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p){\n  int l, i, v, a, f, u, s, n;\n\n  l=62;\n  i=l;\n  v=i;\n  a=m;\n  f=i;\n  u=l;\n  s=i;\n  n=b;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant l == 62;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop assigns i;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, q, o;\n\n  l=(b%9)+15;\n  i=l;\n  v=l;\n  q=2;\n  o=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'o', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, q, o;\n\n  l=(b%9)+15;\n  i=l;\n  v=l;\n  q=2;\n  o=-5;\n\n  \n  /*@\n\n    loop invariant l == (b % 9) + 15;\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop assigns i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int q){\n  int l, i, v, z, t;\n\n  l=69;\n  i=0;\n  v=i;\n  z=q;\n  t=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      i = i+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      i = i+2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'q', 't', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int q){\n  int l, i, v, z, t;\n\n  l=69;\n  i=0;\n  v=i;\n  z=q;\n  t=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i >= 0;\n    loop invariant v >= 0;\n    loop invariant 2*v == i;\n    loop invariant i <= l + 1;\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      i = i+2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int q){\n  int l, i, v;\n\n  l=62;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      if (v+4<l) {\n          v = v*i;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      if (v+4<l) {\n          v = v*i;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int q){\n  int l, i, v;\n\n  l=62;\n  i=0;\n  v=i;\n\n  \n  /*@\n\n    loop invariant v == 0;\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant l == 62;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+v;\n      if (v+4<l) {\n          v = v*i;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int q){\n  int l, i, v, y, e, b;\n\n  l=53;\n  i=0;\n  v=a;\n  y=4;\n  e=3;\n  b=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      i = i+4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      i = i+4;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'e', 'i', 'k', 'l', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int q){\n  int l, i, v, y, e, b;\n\n  l=53;\n  i=0;\n  v=a;\n  y=4;\n  e=3;\n  b=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i % 4 == 0;\n    loop invariant v == a + i/4;\n    loop invariant 0 <= i <= l + 3;\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = v+1;\n      i = i+4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p){\n  int l, i, v;\n\n  l=58;\n  i=0;\n  v=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (i+2<=p+l) {\n          v = v+i;\n      }\n      else {\n          v = v+i;\n      }\n      v = v-v;\n      v = v+v;\n      if (i+1<=l+l) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (i+2<=p+l) {\n          v = v+i;\n      }\n      else {\n          v = v+i;\n      }\n      v = v-v;\n      v = v+v;\n      if (i+1<=l+l) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p){\n  int l, i, v;\n\n  l=58;\n  i=0;\n  v=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant l == 58;\n    loop invariant (i == 0) ==> v == \\at(p, Pre);\n    loop invariant (i > 0) ==> v == 1;\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      if (i+2<=p+l) {\n          v = v+i;\n      }\n      else {\n          v = v+i;\n      }\n      v = v-v;\n      v = v+v;\n      if (i+1<=l+l) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n){\n  int l, i, v, w;\n\n  l=k;\n  i=0;\n  v=l;\n  w=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      w = w-1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      w = w-1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n){\n  int l, i, v, w;\n\n  l=k;\n  i=0;\n  v=l;\n  w=l;\n\n  \n  /*@\n\n    loop invariant l == \\at(k, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant v == l + i;\n\n    loop invariant w == l - i;\n\n    loop invariant i <= l || l <= 0;\n\n    loop assigns i, v, w;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      w = w-1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n){\n  int l, i, v;\n\n  l=68;\n  i=l;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      if ((i%2)==0) {\n          v = v+i;\n      }\n      v = v-l;\n      v = v+1;\n      v = v+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      if ((i%2)==0) {\n          v = v+i;\n      }\n      v = v-l;\n      v = v+1;\n      v = v+1;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n){\n  int l, i, v;\n\n  l=68;\n  i=l;\n  v=k;\n\n  \n  /*@\n\n    loop invariant l == 68;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre);\n\n    loop invariant v == \\at(k, Pre) - (l - i) * (l - 2) + ((l/2) * ((l/2) + 1) - (i/2) * ((i/2) + 1));\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      if ((i%2)==0) {\n          v = v+i;\n      }\n      v = v-l;\n      v = v+1;\n      v = v+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p){\n  int l, i, v, s, f, c, x, h;\n\n  l=80;\n  i=0;\n  v=m;\n  s=-3;\n  f=p;\n  c=i;\n  x=1;\n  h=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      c = c*c+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      c = c*c+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'f', 'h', 'i', 'l', 'm', 'n', 'p', 's', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p){\n  int l, i, v, s, f, c, x, h;\n\n  l=80;\n  i=0;\n  v=m;\n  s=-3;\n  f=p;\n  c=i;\n  x=1;\n  h=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i <= l;\n    loop invariant (i == 0) ==> (c == 0);\n    loop assigns i, c;\n    loop variant l - i;\n  */\n  while (i<l) {\n      c = c*c+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int p){\n  int l, i, v;\n\n  l=50;\n  i=l;\n  v=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+i;\n      v = v-v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+i;\n      v = v-v;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int p){\n  int l, i, v;\n\n  l=50;\n  i=l;\n  v=3;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant v == 0 || (v == 3 && i == l);\n\n    loop invariant l == 50;\n\n    loop invariant k == \\at(k, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v+i;\n      v = v-v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m){\n  int l, i, v, x, u;\n\n  l=52;\n  i=l;\n  v=l;\n  x=l;\n  u=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      x = x+u;\n      u = u+v;\n      if (u+2<l) {\n          x = x+2;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      x = x+u;\n      u = u+v;\n      if (u+2<l) {\n          x = x+2;\n      }\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'u', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m){\n  int l, i, v, x, u;\n\n  l=52;\n  i=l;\n  v=l;\n  x=l;\n  u=4;\n\n  \n  /*@\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant u == 4 + (l - i) * v;\n\n    loop invariant x == l + 4 * (l - i) + v * ((l - i) * (l - i - 1) / 2);\n\n    loop assigns x, u, i;\n\n  */\n  while (i>0) {\n      x = x+u;\n      u = u+v;\n      if (u+2<l) {\n          x = x+2;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int q){\n  int l, i, v, m, a, s, g, j;\n\n  l=k+21;\n  i=l;\n  v=q;\n  m=4;\n  a=b;\n  s=i;\n  g=k;\n  j=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'g', 'i', 'j', 'k', 'l', 'm', 'q', 's', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int q){\n  int l, i, v, m, a, s, g, j;\n\n  l=k+21;\n  i=l;\n  v=q;\n  m=4;\n  a=b;\n  s=i;\n  g=k;\n  j=3;\n\n  \n  /*@\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant l == k + 21;\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant l >= 0 ==> i >= 0;\n\n    loop assigns i;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n){\n  int l, i, v;\n\n  l=76;\n  i=0;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+4;\n      if (v+5<l) {\n          v = v-v;\n      }\n      else {\n          v = v+v;\n      }\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+4;\n      if (v+5<l) {\n          v = v-v;\n      }\n      else {\n          v = v+v;\n      }\n      v = v+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n){\n  int l, i, v;\n\n  l=76;\n  i=0;\n  v=n;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant l == 76;\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant (i == 0 ==> v == \\at(n, Pre));\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+4;\n      if (v+5<l) {\n          v = v-v;\n      }\n      else {\n          v = v+v;\n      }\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m){\n  int l, i, v, x, n, q;\n\n  l=74;\n  i=0;\n  v=m;\n  x=6;\n  n=b;\n  q=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      x = x+v;\n      n = n%8;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      x = x+v;\n      n = n%8;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'n', 'q', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m){\n  int l, i, v, x, n, q;\n\n  l=74;\n  i=0;\n  v=m;\n  x=6;\n  n=b;\n  q=m;\n\n  \n  /*@\n\n    loop invariant x == (6 - 2*\\at(m,Pre)) + 2*v;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant b == \\at(b,Pre) && k == \\at(k,Pre) && m == \\at(m,Pre);\n\n    loop invariant (i == 0 ==> n == \\at(b,Pre)) && (i >= 1 ==> -7 <= n && n <= 7);\n\n    loop assigns v, x, n, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v*2;\n      x = x+v;\n      n = n%8;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k){\n  int l, i, v;\n\n  l=41;\n  i=l;\n  v=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = k-l;\n      v = v+v;\n      v = v-v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = k-l;\n      v = v+v;\n      v = v-v;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k){\n  int l, i, v;\n\n  l=41;\n  i=l;\n  v=-8;\n\n  \n  /*@\n\n    loop invariant l == 41;\n\n    loop invariant i >= 0;\n\n    loop invariant i <= 41;\n\n    loop invariant v == 0 || v == -8;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = k-l;\n      v = v+v;\n      v = v-v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int q){\n  int l, i, v, o, x, t, a;\n\n  l=31;\n  i=0;\n  v=i;\n  o=q;\n  x=-1;\n  t=q;\n  a=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      t = t*t+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      t = t*t+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'o', 'q', 't', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int q){\n  int l, i, v, o, x, t, a;\n\n  l=31;\n  i=0;\n  v=i;\n  o=q;\n  x=-1;\n  t=q;\n  a=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant l == 31;\n    loop invariant v == 0;\n    loop invariant (i == 0) ==> (t == \\at(q, Pre));\n    loop assigns i, t;\n  */\n  while (i<l) {\n      t = t*t+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int p){\n  int l, i, v, u, n, o;\n\n  l=59;\n  i=0;\n  v=-3;\n  u=p;\n  n=i;\n  o=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      u = u-1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      u = u-1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'n', 'o', 'p', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int p){\n  int l, i, v, u, n, o;\n\n  l=59;\n  i=0;\n  v=-3;\n  u=p;\n  n=i;\n  o=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i <= l;\n    loop invariant v == -3 + i;\n    loop invariant u == p - i;\n    loop invariant p == \\at(p, Pre);\n    loop invariant a == \\at(a, Pre);\n    loop assigns i, v, u;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      v = v+1;\n      u = u-1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m){\n  int l, i, v, j, t, c, y, u;\n\n  l=57;\n  i=0;\n  v=1;\n  j=l;\n  t=l;\n  c=8;\n  y=a;\n  u=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+j;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+j;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'i', 'j', 'l', 'm', 't', 'u', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m){\n  int l, i, v, j, t, c, y, u;\n\n  l=57;\n  i=0;\n  v=1;\n  j=l;\n  t=l;\n  c=8;\n  y=a;\n  u=8;\n\n  \n  /*@\n\n    loop invariant v == 1 + i * j;\n\n    loop invariant j == l;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+j;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int p){\n  int l, i, v, t, f, u, z, q, b;\n\n  l=63;\n  i=0;\n  v=p;\n  t=k;\n  f=i;\n  u=-4;\n  z=k;\n  q=n;\n  b=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2+3;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2+3;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'f', 'i', 'k', 'l', 'n', 'p', 'q', 't', 'u', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int p){\n  int l, i, v, t, f, u, z, q, b;\n\n  l=63;\n  i=0;\n  v=p;\n  t=k;\n  f=i;\n  u=-4;\n  z=k;\n  q=n;\n  b=p;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant p == \\at(p,Pre) && k == \\at(k,Pre) && n == \\at(n,Pre);\n\n    loop invariant (\\at(p,Pre) + 3 == 0) ==> (v + 3 == 0);\n\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v*2+3;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v, b, d, e;\n\n  l=44;\n  i=0;\n  v=2;\n  b=8;\n  d=-2;\n  e=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      b = b+v;\n      d = d%9;\n      v = e*e;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      b = b+v;\n      d = d%9;\n      v = e*e;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'd', 'e', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v, b, d, e;\n\n  l=44;\n  i=0;\n  v=2;\n  b=8;\n  d=-2;\n  e=2;\n\n  \n  /*@\n\n    loop invariant l == 44;\n\n    loop invariant e == 2;\n\n    loop invariant d == -2;\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant (i == 0) ==> (v == 2);\n\n    loop invariant (i > 0) ==> (v == e*e);\n\n    loop invariant (i == 0) ==> (b == 8);\n\n    loop invariant (i > 0) ==> (b >= 12);\n\n    loop assigns v, b, d, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v*2;\n      b = b+v;\n      d = d%9;\n      v = e*e;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int p,int q){\n  int l, i, v, r, x, s, f, u;\n\n  l=12;\n  i=0;\n  v=-8;\n  r=0;\n  x=p;\n  s=-1;\n  f=l;\n  u=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+5;\n      x = x+3;\n      r = r+i;\n      if (i+7<=b+l) {\n          u = u+1;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+5;\n      x = x+3;\n      r = r+i;\n      if (i+7<=b+l) {\n          u = u+1;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'f', 'i', 'l', 'p', 'q', 'r', 's', 'u', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int p,int q){\n  int l, i, v, r, x, s, f, u;\n\n  l=12;\n  i=0;\n  v=-8;\n  r=0;\n  x=p;\n  s=-1;\n  f=l;\n  u=5;\n\n  \n  /*@\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant v == -8 + 5*i;\n\n    loop invariant x == p + 3*i;\n\n    loop invariant r == i*(i-1)/2;\n\n    loop invariant 5 <= u <= 5 + i;\n\n    loop assigns v, x, r, i, u;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+5;\n      x = x+3;\n      r = r+i;\n      if (i+7<=b+l) {\n          u = u+1;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n){\n  int l, i, v, w;\n\n  l=77;\n  i=l;\n  v=6;\n  w=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      w = w-1;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      w = w-1;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'n', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n){\n  int l, i, v, w;\n\n  l=77;\n  i=l;\n  v=6;\n  w=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v + w == 6 + \\at(b,Pre);\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v >= 6;\n    loop invariant w <= \\at(b,Pre);\n    loop assigns v, w, i;\n    loop variant i;\n  */\nwhile (i>0) {\n      v = v+1;\n      w = w-1;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v, d, e, u, s, w;\n\n  l=73;\n  i=l;\n  v=i;\n  d=k;\n  e=a;\n  u=l;\n  s=-2;\n  w=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'd', 'e', 'i', 'k', 'l', 'm', 's', 'u', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v, d, e, u, s, w;\n\n  l=73;\n  i=l;\n  v=i;\n  d=k;\n  e=a;\n  u=l;\n  s=-2;\n  w=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= 73;\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant l == 73;\n    loop assigns i;\n    loop variant i;\n  */\n  while (i>0) {\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, d, q, e;\n\n  l=22;\n  i=l;\n  v=-8;\n  d=l;\n  q=p;\n  e=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      d = d-1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      d = d-1;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'e', 'i', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, d, q, e;\n\n  l=22;\n  i=l;\n  v=-8;\n  d=l;\n  q=p;\n  e=n;\n\n  \n  /*@\n\n    loop invariant v + d == -8 + l;\n\n    loop invariant d == i;\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant p == \\at(p,Pre);\n\n    loop invariant n == \\at(n,Pre);\n\n    loop assigns v, d, i;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v+1;\n      d = d-1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int q){\n  int l, i, v, x, y, j, w, s;\n\n  l=56;\n  i=l;\n  v=i;\n  x=4;\n  y=a;\n  j=-3;\n  w=q;\n  s=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*4;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*4;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'j', 'l', 'q', 's', 'v', 'w', 'x', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int q){\n  int l, i, v, x, y, j, w, s;\n\n  l=56;\n  i=l;\n  v=i;\n  x=4;\n  y=a;\n  j=-3;\n  w=q;\n  s=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i <= l;\n    loop invariant v >= i;\n    loop invariant v >= l;\n    loop invariant v % 4 == 0;\n    loop assigns i, v;\n  */\n  while (i>0) {\n      v = v*4;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m){\n  int l, i, v, w, q, a, r;\n\n  l=(k%7)+18;\n  i=0;\n  v=b;\n  w=i;\n  q=k;\n  a=k;\n  r=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+w;\n      i = i+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+w;\n      i = i+2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'm', 'q', 'r', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m){\n  int l, i, v, w, q, a, r;\n\n  l=(k%7)+18;\n  i=0;\n  v=b;\n  w=i;\n  q=k;\n  a=k;\n  r=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant w == 0;\n   loop invariant i % 2 == 0;\n   loop invariant 0 <= i;\n   loop invariant i <= l + 1;\n   loop invariant v == \\at(b,Pre) + (i/2) * w;\n   loop assigns v, i;\n   loop variant l - i;\n */\n while (i<l) {\n       v = v+w;\n       i = i+2;\n   }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p){\n  int l, i, v, n, w, f, u, e;\n\n  l=61;\n  i=0;\n  v=b;\n  n=b;\n  w=m;\n  f=i;\n  u=0;\n  e=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'e', 'f', 'i', 'l', 'm', 'n', 'p', 'u', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p){\n  int l, i, v, n, w, f, u, e;\n\n  l=61;\n  i=0;\n  v=b;\n  n=b;\n  w=m;\n  f=i;\n  u=0;\n  e=b;\n\n  \n  /*@\n\n    loop invariant v == b + i*(i-1)/2;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m){\n  int l, i, v, p, o, q, f, u, g, c;\n\n  l=m;\n  i=0;\n  v=-6;\n  p=3;\n  o=l;\n  q=b;\n  f=a;\n  u=5;\n  g=-5;\n  c=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'f', 'g', 'i', 'l', 'm', 'o', 'p', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m){\n  int l, i, v, p, o, q, f, u, g, c;\n\n  l=m;\n  i=0;\n  v=-6;\n  p=3;\n  o=l;\n  q=b;\n  f=a;\n  u=5;\n  g=-5;\n  c=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i;\n    loop invariant (i <= l) || (l < 0);\n    loop invariant v == -6 + i*(i-1)/2;\n    loop invariant l == m;\n    loop assigns v, i;\n  */\n  while (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int q){\n  int l, i, v, o, u, h;\n\n  l=46;\n  i=0;\n  v=0;\n  o=m;\n  u=-8;\n  h=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*3;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*3;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'h', 'i', 'l', 'm', 'o', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int q){\n  int l, i, v, o, u, h;\n\n  l=46;\n  i=0;\n  v=0;\n  o=m;\n  u=-8;\n  h=m;\n\n  \n  /*@\n\n    loop invariant v == 0;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant l == 46;\n\n    loop invariant a == \\at(a, Pre) && m == \\at(m, Pre) && q == \\at(q, Pre);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v*3;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v, p, d, u, n, c, z, r;\n\n  l=a;\n  i=0;\n  v=a;\n  p=k;\n  d=-3;\n  u=-4;\n  n=l;\n  c=a;\n  z=a;\n  r=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      u = u*u+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      u = u*u+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'd', 'i', 'k', 'l', 'm', 'n', 'p', 'r', 'u', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v, p, d, u, n, c, z, r;\n\n  l=a;\n  i=0;\n  v=a;\n  p=k;\n  d=-3;\n  u=-4;\n  n=l;\n  c=a;\n  z=a;\n  r=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == \\at(a,Pre);\n    loop invariant l == \\at(a,Pre);\n    loop invariant i >= 0;\n    loop invariant (l < 0) || i <= l;\n    loop invariant (i == 0) ==> u == -4;\n    loop assigns u, i;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      u = u*u+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int q){\n  int l, i, v, u, x, m, h;\n\n  l=23;\n  i=0;\n  v=k;\n  u=i;\n  x=i;\n  m=q;\n  h=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      u = u+v;\n      x = x%2;\n      if (i+6<=x+l) {\n          x = x*2;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      u = u+v;\n      x = x%2;\n      if (i+6<=x+l) {\n          x = x*2;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['h', 'i', 'k', 'l', 'm', 'n', 'q', 'u', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int q){\n  int l, i, v, u, x, m, h;\n\n  l=23;\n  i=0;\n  v=k;\n  u=i;\n  x=i;\n  m=q;\n  h=2;\n\n  \n  /*@\n\n    loop invariant u == 2*v - 2*\\at(k, Pre);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant x == 0;\n\n    loop invariant k == \\at(k, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n\n    loop assigns v, u, x, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v*2;\n      u = u+v;\n      x = x%2;\n      if (i+6<=x+l) {\n          x = x*2;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p,int q){\n  int l, i, v, a, c, k, j;\n\n  l=35;\n  i=l;\n  v=0;\n  a=-6;\n  c=q;\n  k=-3;\n  j=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*3;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*3;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'i', 'j', 'k', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p,int q){\n  int l, i, v, a, c, k, j;\n\n  l=35;\n  i=l;\n  v=0;\n  a=-6;\n  c=q;\n  k=-3;\n  j=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant l == 35;\n   loop invariant i <= l;\n   loop invariant i >= 0;\n   loop invariant v == 0;\n   loop invariant n == \\at(n, Pre);\n   loop assigns v, i;\n   loop variant i;\n */\nwhile (i>0) {\n      v = v*3;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p,int q){\n  int l, i, v, d, w, y, e;\n\n  l=36;\n  i=0;\n  v=n;\n  d=l;\n  w=q;\n  y=i;\n  e=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+2;\n      w = w+4;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+2;\n      w = w+4;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'e', 'i', 'l', 'n', 'p', 'q', 'v', 'w', 'y']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p,int q){\n  int l, i, v, d, w, y, e;\n\n  l=36;\n  i=0;\n  v=n;\n  d=l;\n  w=q;\n  y=i;\n  e=q;\n\n  \n  /*@\n\n    loop invariant v == \\at(n, Pre) + 2*i;\n\n    loop invariant w == \\at(q, Pre) + 4*i;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant l == 36;\n\n    loop invariant n == \\at(n, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n\n    loop assigns v, w, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+2;\n      w = w+4;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m){\n  int l, i, v, e, s, f, z;\n\n  l=36;\n  i=0;\n  v=-4;\n  e=b;\n  s=k;\n  f=k;\n  z=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'e', 'f', 'i', 'k', 'l', 'm', 's', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m){\n  int l, i, v, e, s, f, z;\n\n  l=36;\n  i=0;\n  v=-4;\n  e=b;\n  s=k;\n  f=k;\n  z=k;\n\n  \n  /*@\n\n    loop invariant l == 36;\n\n    loop invariant -4 <= v && v <= l;\n\n    loop assigns v;\n\n  */\n  while (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int q){\n  int l, i, v, x, d;\n\n  l=54;\n  i=0;\n  v=5;\n  x=2;\n  d=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+x+d;\n      i = i+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+x+d;\n      i = i+3;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'd', 'i', 'l', 'q', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int q){\n  int l, i, v, x, d;\n\n  l=54;\n  i=0;\n  v=5;\n  x=2;\n  d=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant i % 3 == 0;\n    loop invariant v == 5 - 2*i;\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+x+d;\n      i = i+3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n){\n  int l, i, v, y;\n\n  l=16;\n  i=l;\n  v=n;\n  y=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      y = y+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      y = y+v;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'n', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n){\n  int l, i, v, y;\n\n  l=16;\n  i=l;\n  v=n;\n  y=i;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= 16;\n\n    loop invariant v + i == n + 16;\n\n    loop invariant y == 16 + (16 - i)*n + ((16 - i)*(17 - i))/2;\n\n    loop assigns i, v, y;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v+1;\n      y = y+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n){\n  int l, i, v, q;\n\n  l=52;\n  i=0;\n  v=4;\n  q=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      q = q+q;\n      q = q+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      q = q+q;\n      q = q+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n){\n  int l, i, v, q;\n\n  l=52;\n  i=0;\n  v=4;\n  q=n;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant (i == 0) ==> (q == \\at(n,Pre));\n\n    loop invariant (i > 0) ==> (q % 2 == 0);\n\n    loop assigns i, q;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      q = q+q;\n      q = q+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, r, e, t, z, q, h;\n\n  l=78;\n  i=0;\n  v=n;\n  r=6;\n  e=-2;\n  t=l;\n  z=3;\n  q=p;\n  h=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*3+3;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*3+3;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'e', 'h', 'i', 'l', 'n', 'p', 'q', 'r', 't', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, r, e, t, z, q, h;\n\n  l=78;\n  i=0;\n  v=n;\n  r=6;\n  e=-2;\n  t=l;\n  z=3;\n  q=p;\n  h=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant (i == 0) ==> (v == n);\n    loop invariant l == 78;\n    loop assigns v, i;\n  */\n  while (i<l) {\n      v = v*3+3;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p,int q){\n  int l, i, v;\n\n  l=q-7;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p,int q){\n  int l, i, v;\n\n  l=q-7;\n  i=0;\n  v=m;\n\n  \n  /*@\n\n    loop invariant l == q - 7;\n\n    loop invariant 0 <= i;\n\n    loop invariant (l >= 0) ==> (i <= l);\n\n    loop invariant (i > 0) ==> ((v + 2) % 2 == 0);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p){\n  int l, i, v, z, y, g, f, j;\n\n  l=(p%13)+17;\n  i=l;\n  v=-2;\n  z=8;\n  y=-6;\n  g=0;\n  f=n;\n  j=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*4;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*4;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['f', 'g', 'i', 'j', 'l', 'm', 'n', 'p', 'v', 'y', 'z']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p){\n  int l, i, v, z, y, g, f, j;\n\n  l=(p%13)+17;\n  i=l;\n  v=-2;\n  z=8;\n  y=-6;\n  g=0;\n  f=n;\n  j=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == (p % 13) + 17;\n    loop invariant 0 <= i && i <= l;\n    loop invariant v < 0;\n    loop invariant v % 2 == 0;\n    loop invariant i > 0 ==> v < 0;\n    loop assigns v, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v*4;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p){\n  int l, i, v, f;\n\n  l=47;\n  i=0;\n  v=p;\n  f=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      f = f+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      f = f+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['f', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p){\n  int l, i, v, f;\n\n  l=47;\n  i=0;\n  v=p;\n  f=l;\n\n  \n  /*@\n\n    loop invariant v == \\at(p, Pre) + i;\n\n    loop invariant f == l + i * \\at(p, Pre) + (i*(i+1))/2;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop assigns i, v, f;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      f = f+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p){\n  int l, i, v, z;\n\n  l=20;\n  i=l;\n  v=n;\n  z=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      z = z-1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      z = z-1;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p){\n  int l, i, v, z;\n\n  l=20;\n  i=l;\n  v=n;\n  z=i;\n\n  \n  /*@\n\n    loop invariant v == n + (l - i);\n\n    loop invariant z == i;\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant n == \\at(n, Pre);\n\n    loop assigns v, z, i;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v+1;\n      z = z-1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int q){\n  int l, i, v, p, e, d, t, u;\n\n  l=49;\n  i=0;\n  v=q;\n  p=-1;\n  e=l;\n  d=n;\n  t=1;\n  u=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*3+2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*3+2;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'e', 'i', 'l', 'n', 'p', 'q', 't', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int q){\n  int l, i, v, p, e, d, t, u;\n\n  l=49;\n  i=0;\n  v=q;\n  p=-1;\n  e=l;\n  d=n;\n  t=1;\n  u=-5;\n\n  \n  /*@\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant l == 49;\n\n    loop invariant v % 2 == \\at(q, Pre) % 2;\n\n    loop assigns v, i;\n\n  */\n  while (i<l) {\n      v = v*3+2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int q){\n  int l, i, v, f, r, g;\n\n  l=a+6;\n  i=l;\n  v=a;\n  f=b;\n  r=q;\n  g=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'f', 'g', 'i', 'l', 'q', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int q){\n  int l, i, v, f, r, g;\n\n  l=a+6;\n  i=l;\n  v=a;\n  f=b;\n  r=q;\n  g=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant l == \\at(a, Pre) + 6;\n    loop invariant \\at(a, Pre) <= v && v <= l;\n    loop assigns v;\n    loop variant l - v;\n  */\nwhile (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int p){\n  int l, i, v;\n\n  l=75;\n  i=0;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      v = v+v;\n      v = -8;\n      v = v+5;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      v = v+v;\n      v = -8;\n      v = v+5;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int p){\n  int l, i, v;\n\n  l=75;\n  i=0;\n  v=n;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant l == 75;\n\n    loop invariant k == \\at(k,Pre);\n\n    loop invariant n == \\at(n,Pre);\n\n    loop invariant p == \\at(p,Pre);\n\n    loop invariant (i == 0) ==> (v == \\at(n,Pre));\n\n    loop invariant (i > 0) ==> (v == -3);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+i;\n      v = v+v;\n      v = -8;\n      v = v+5;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p){\n  int l, i, v, k, w, x;\n\n  l=35;\n  i=l;\n  v=b;\n  k=i;\n  w=6;\n  x=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*3;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*3;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'p', 'v', 'w', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p){\n  int l, i, v, k, w, x;\n\n  l=35;\n  i=l;\n  v=b;\n  k=i;\n  w=6;\n  x=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 35;\n    loop invariant i >= 0;\n    loop invariant i <= l;\n\n    loop invariant ( \\at(b, Pre) == 0 ) ==> ( v == 0 );\n    loop assigns i, v;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v*3;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int q){\n  int l, i, v, k;\n\n  l=80;\n  i=0;\n  v=q;\n  k=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      k = k+v;\n      k = k+5;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      k = k+v;\n      k = k+5;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int q){\n  int l, i, v, k;\n\n  l=80;\n  i=0;\n  v=q;\n  k=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant v == q + 2*i;\n    loop invariant k == m + i*i + i*q + 5*i;\n    loop assigns i, v, k;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      k = k+v;\n      k = k+5;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p,int q){\n  int l, i, v;\n\n  l=32;\n  i=0;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = -5;\n      v = v+1;\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = -5;\n      v = v+1;\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p,int q){\n  int l, i, v;\n\n  l=32;\n  i=0;\n  v=a;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n\n    loop invariant (i > 0) ==> (v == -6);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = -5;\n      v = v+1;\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n){\n  int l, i, v, z, s, j;\n\n  l=24;\n  i=0;\n  v=l;\n  z=8;\n  s=n;\n  j=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      z = z+v;\n      z = z+1;\n      i = i+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      z = z+v;\n      z = z+1;\n      i = i+3;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'j', 'l', 'n', 's', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n){\n  int l, i, v, z, s, j;\n\n  l=24;\n  i=0;\n  v=l;\n  z=8;\n  s=n;\n  j=5;\n\n  \n  /*@\n\n    loop invariant 0 <= i;\n\n    loop invariant i % 3 == 0;\n\n    loop invariant i <= l + 2;\n\n    loop invariant v == l + i/3;\n\n    loop invariant z == 8 + (i/3) * (l + 2) + (i/3) * ((i/3) - 1) / 2;\n\n    loop assigns v, z, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      z = z+v;\n      z = z+1;\n      i = i+3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int p){\n  int l, i, v, h, r, e, u, n, j, c;\n\n  l=44;\n  i=0;\n  v=l;\n  h=3;\n  r=-6;\n  e=p;\n  u=i;\n  n=0;\n  j=p;\n  c=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'e', 'h', 'i', 'j', 'k', 'l', 'n', 'p', 'r', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int p){\n  int l, i, v, h, r, e, u, n, j, c;\n\n  l=44;\n  i=0;\n  v=l;\n  h=3;\n  r=-6;\n  e=p;\n  u=i;\n  n=0;\n  j=p;\n  c=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == l + (i*(i-1))/2;\n    loop invariant 0 <= i <= l;\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int p){\n  int l, i, v, u, d, o, c, r;\n\n  l=64;\n  i=0;\n  v=l;\n  u=k;\n  d=b;\n  o=b;\n  c=8;\n  r=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      u = u-1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      u = u-1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'd', 'i', 'k', 'l', 'o', 'p', 'r', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int p){\n  int l, i, v, u, d, o, c, r;\n\n  l=64;\n  i=0;\n  v=l;\n  u=k;\n  d=b;\n  o=b;\n  c=8;\n  r=3;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v == l + i;\n\n    loop invariant u + i == k;\n\n    loop invariant b == \\at(b,Pre) && k == \\at(k,Pre) && p == \\at(p,Pre);\n\n    loop assigns i, v, u;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      u = u-1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p){\n  int l, i, v, y, q, f;\n\n  l=51;\n  i=0;\n  v=i;\n  y=p;\n  q=p;\n  f=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      y = y*y;\n      q = q+v*y;\n      v = v*v+y;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      y = y*y;\n      q = q+v*y;\n      v = v*v+y;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['f', 'i', 'l', 'm', 'n', 'p', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p){\n  int l, i, v, y, q, f;\n\n  l=51;\n  i=0;\n  v=i;\n  y=p;\n  q=p;\n  f=l;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant l == 51;\n\n    loop invariant v >= 0;\n\n    loop invariant (i == 0 ==> (v == 0 && y == \\at(p, Pre) && q == \\at(p, Pre)));\n\n    loop invariant (i >= 1 ==> y >= 0);\n\n    loop invariant q >= \\at(p, Pre);\n\n    loop assigns v, y, q, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+i;\n      y = y*y;\n      q = q+v*y;\n      v = v*v+y;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p,int q){\n  int l, i, v, c, d, t, g, b;\n\n  l=72;\n  i=l;\n  v=q;\n  c=-4;\n  d=5;\n  t=5;\n  g=-5;\n  b=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      c = c+v;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      c = c+v;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'd', 'g', 'i', 'l', 'p', 'q', 't', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p,int q){\n  int l, i, v, c, d, t, g, b;\n\n  l=72;\n  i=l;\n  v=q;\n  c=-4;\n  d=5;\n  t=5;\n  g=-5;\n  b=p;\n\n  \n  /*@\n\n    loop invariant c - 2*v == -4 - 2*\\at(q,Pre);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant q == \\at(q,Pre);\n\n    loop assigns v, c, i;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v*2;\n      c = c+v;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int p){\n  int l, i, v, s, d, r;\n\n  l=30;\n  i=0;\n  v=5;\n  s=i;\n  d=i;\n  r=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      r = v+s+d;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      r = v+s+d;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'i', 'k', 'l', 'p', 'r', 's', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int p){\n  int l, i, v, s, d, r;\n\n  l=30;\n  i=0;\n  v=5;\n  s=i;\n  d=i;\n  r=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v == 5 + i;\n    loop invariant s == 0;\n    loop invariant d == 0;\n    loop invariant (i == 0) ==> (r == 1);\n    loop invariant (i != 0) ==> (r == v - 1);\n    loop assigns r, v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      r = v+s+d;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p){\n  int l, i, v, x, e, g, y, a;\n\n  l=21;\n  i=0;\n  v=i;\n  x=-6;\n  e=i;\n  g=l;\n  y=m;\n  a=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      e = e+3;\n      a = a+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      e = e+3;\n      a = a+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'e', 'g', 'i', 'l', 'm', 'p', 'v', 'x', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p){\n  int l, i, v, x, e, g, y, a;\n\n  l=21;\n  i=0;\n  v=i;\n  x=-6;\n  e=i;\n  g=l;\n  y=m;\n  a=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 21;\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v == i;\n    loop invariant e == 3*i;\n    loop invariant a == 21 + i*(i-1)/2;\n    loop assigns v, e, a, i;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      v = v+1;\n      e = e+3;\n      a = a+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int p,int q){\n  int l, i, v, a, w, o, r;\n\n  l=p;\n  i=0;\n  v=-2;\n  a=3;\n  w=-1;\n  o=5;\n  r=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      o = v+a+w;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      o = v+a+w;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'o', 'p', 'q', 'r', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int p,int q){\n  int l, i, v, a, w, o, r;\n\n  l=p;\n  i=0;\n  v=-2;\n  a=3;\n  w=-1;\n  o=5;\n  r=k;\n\n  \n  /*@\n\n    loop invariant l == \\at(p, Pre);\n\n    loop invariant (o == v + a + w) || i == 0;\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l || l <= 0;\n\n    loop assigns o, i;\n\n  */\nwhile (i<l) {\n      o = v+a+w;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n){\n  int l, i, v, z, s;\n\n  l=69;\n  i=l;\n  v=k;\n  z=-4;\n  s=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 's', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n){\n  int l, i, v, z, s;\n\n  l=69;\n  i=l;\n  v=k;\n  z=-4;\n  s=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant i + v - k == 69;\n   loop invariant 0 <= i <= 69;\n   loop invariant a == \\at(a, Pre);\n   loop invariant k == \\at(k, Pre);\n   loop invariant n == \\at(n, Pre);\n   loop assigns i, v;\n   loop variant i;\n */\nwhile (i>0) {\n      v = v+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k){\n  int l, i, v;\n\n  l=50;\n  i=0;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k){\n  int l, i, v;\n\n  l=50;\n  i=0;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant i >= 0 && i <= l;\n    loop invariant v == 2 + i*(i+1)/2;\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+i;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int p){\n  int l, i, v, e, x, h, k, j;\n\n  l=34;\n  i=l;\n  v=b;\n  e=l;\n  x=p;\n  h=5;\n  k=b;\n  j=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      e = e+v;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      e = e+v;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'e', 'h', 'i', 'j', 'k', 'l', 'p', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int p){\n  int l, i, v, e, x, h, k, j;\n\n  l=34;\n  i=l;\n  v=b;\n  e=l;\n  x=p;\n  h=5;\n  k=b;\n  j=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant e == 34 + 2*v - 2*\\at(b,Pre);\n    loop invariant i >= 0;\n    loop invariant i <= 34;\n    loop invariant a == \\at(a,Pre);\n    loop invariant b == \\at(b,Pre);\n    loop invariant p == \\at(p,Pre);\n    loop assigns v, e, i;\n  */\n  while (i>0) {\n      v = v*2;\n      e = e+v;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p){\n  int l, i, v, b, x, k, e, q, z;\n\n  l=62;\n  i=0;\n  v=l;\n  b=-2;\n  x=n;\n  k=-6;\n  e=n;\n  q=5;\n  z=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      b = b*b;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      b = b*b;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'e', 'i', 'k', 'l', 'n', 'p', 'q', 'v', 'x', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p){\n  int l, i, v, b, x, k, e, q, z;\n\n  l=62;\n  i=0;\n  v=l;\n  b=-2;\n  x=n;\n  k=-6;\n  e=n;\n  q=5;\n  z=n;\n\n  \n  /*@\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant v == l + i*(i-1)/2;\n\n    loop invariant (i == 0) ==> (b == -2);\n\n    loop invariant (i > 0) ==> (b >= 0);\n\n    loop assigns v, b, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+i;\n      b = b*b;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, o, t, a, w, k, r, d;\n\n  l=79;\n  i=l;\n  v=i;\n  o=p;\n  t=i;\n  a=-2;\n  w=b;\n  k=-2;\n  r=p;\n  d=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      o = o-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      o = o-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'd', 'i', 'k', 'l', 'n', 'o', 'p', 'r', 't', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, o, t, a, w, k, r, d;\n\n  l=79;\n  i=l;\n  v=i;\n  o=p;\n  t=i;\n  a=-2;\n  w=b;\n  k=-2;\n  r=p;\n  d=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v + o == i + p;\n    loop invariant v >= i;\n    loop invariant o <= p;\n    loop invariant i >= 0;\n    loop assigns v, o;\n  */\n  while (i>0) {\n      v = v+1;\n      o = o-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int p){\n  int l, i, v, s;\n\n  l=66;\n  i=0;\n  v=i;\n  s=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      s = s-1;\n      s = p;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      s = s-1;\n      s = p;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'p', 's', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int p){\n  int l, i, v, s;\n\n  l=66;\n  i=0;\n  v=i;\n  s=l;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant v == i;\n\n    loop invariant (i == 0) ==> (s == l);\n\n    loop invariant (i > 0) ==> (s == p);\n\n    loop invariant l == 66;\n\n    loop assigns v, s, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      s = s-1;\n      s = p;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n){\n  int l, i, v, h, u, o, j, z, p;\n\n  l=43;\n  i=1;\n  v=4;\n  h=-6;\n  u=l;\n  o=8;\n  j=a;\n  z=i;\n  p=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*4;\n      i = i*3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*4;\n      i = i*3;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'h', 'i', 'j', 'l', 'm', 'n', 'o', 'p', 'u', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n){\n  int l, i, v, h, u, o, j, z, p;\n\n  l=43;\n  i=1;\n  v=4;\n  h=-6;\n  u=l;\n  o=8;\n  j=a;\n  z=i;\n  p=a;\n\n  \n  /*@\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant l == 43;\n\n    loop invariant i > 0;\n\n    loop invariant v > 0;\n\n    loop invariant v % 4 == 0;\n\n    loop invariant i <= 3 * l;\n\n    loop assigns i, v;\n\n    loop variant 3 * l - i;\n\n  */\n  while (i<l) {\n      v = v*4;\n      i = i*3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n){\n  int l, i, v;\n\n  l=41;\n  i=0;\n  v=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      v = v+i;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      v = v+i;\n      v = v+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n){\n  int l, i, v;\n\n  l=41;\n  i=0;\n  v=-5;\n\n  \n  /*@\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant (i == 0) ==> (v == -5);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v-v;\n      v = v+i;\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int p){\n  int l, i, v, f, h;\n\n  l=12;\n  i=0;\n  v=b;\n  f=a;\n  h=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      f = f-1;\n      h = h+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      f = f-1;\n      h = h+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'f', 'h', 'i', 'l', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int p){\n  int l, i, v, f, h;\n\n  l=12;\n  i=0;\n  v=b;\n  f=a;\n  h=b;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant v == \\at(b, Pre) + i;\n\n    loop invariant f == \\at(a, Pre) - i;\n\n    loop invariant h == \\at(b, Pre) + i*(i-1)/2;\n\n    loop invariant l == 12;\n\n    loop assigns v, f, h, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      f = f-1;\n      h = h+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int q){\n  int l, i, v, c, y;\n\n  l=68;\n  i=0;\n  v=b;\n  c=k;\n  y=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      y = y+4;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      y = y+4;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'i', 'k', 'l', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int q){\n  int l, i, v, c, y;\n\n  l=68;\n  i=0;\n  v=b;\n  c=k;\n  y=-3;\n\n  \n  /*@\n\n    loop invariant v == b + 3*i;\n\n    loop invariant y == -3 + 4*i;\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns v, y, i;\n\n  */\n  while (i<l) {\n      v = v+3;\n      y = y+4;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int q){\n  int l, i, v, e, t, o;\n\n  l=32;\n  i=0;\n  v=-1;\n  e=a;\n  t=l;\n  o=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+2;\n      t = t+3;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+2;\n      t = t+3;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'e', 'i', 'l', 'o', 'q', 't', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int q){\n  int l, i, v, e, t, o;\n\n  l=32;\n  i=0;\n  v=-1;\n  e=a;\n  t=l;\n  o=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 2*i - 1;\n    loop invariant t == l + 3*i;\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns i, v, t;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+2;\n      t = t+3;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int p,int q){\n  int l, i, v, z, f, w, y;\n\n  l=60;\n  i=0;\n  v=2;\n  z=i;\n  f=q;\n  w=-6;\n  y=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      z = z+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      z = z+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'f', 'i', 'l', 'p', 'q', 'v', 'w', 'y', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int p,int q){\n  int l, i, v, z, f, w, y;\n\n  l=60;\n  i=0;\n  v=2;\n  z=i;\n  f=q;\n  w=-6;\n  y=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v == i + 2;\n    loop invariant z == 2*i + i*(i+1)/2;\n    loop assigns v, z, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      z = z+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n){\n  int l, i, v, x, z, q, p, a;\n\n  l=61;\n  i=0;\n  v=l;\n  x=k;\n  z=i;\n  q=n;\n  p=-8;\n  a=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*3;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*3;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'n', 'p', 'q', 'v', 'x', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n){\n  int l, i, v, x, z, q, p, a;\n\n  l=61;\n  i=0;\n  v=l;\n  x=k;\n  z=i;\n  q=n;\n  p=-8;\n  a=k;\n\n  \n  /*@\n\n    loop invariant l == 61;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant v > 0;\n\n    loop invariant v % 3 == 0 || i == 0;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v*3;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p,int q){\n  int l, i, v, r, h, b, y, n;\n\n  l=30;\n  i=l;\n  v=-5;\n  r=q;\n  h=l;\n  b=-1;\n  y=a;\n  n=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+2;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+2;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'h', 'i', 'l', 'n', 'p', 'q', 'r', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p,int q){\n  int l, i, v, r, h, b, y, n;\n\n  l=30;\n  i=l;\n  v=-5;\n  r=q;\n  h=l;\n  b=-1;\n  y=a;\n  n=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == -5 + 2*(l - i);\n\n    loop invariant 0 <= i <= l;\n    loop assigns i, v;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+2;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int p){\n  int l, i, v, x, t, g;\n\n  l=(k%7)+12;\n  i=0;\n  v=k;\n  x=p;\n  t=2;\n  g=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+x;\n      x = x+t;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+x;\n      x = x+t;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'g', 'i', 'k', 'l', 'p', 't', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int p){\n  int l, i, v, x, t, g;\n\n  l=(k%7)+12;\n  i=0;\n  v=k;\n  x=p;\n  t=2;\n  g=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant x == p + 2*i;\n    loop invariant v == k + i*p + i*(i-1);\n    loop assigns v, x, i;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      v = v+x;\n      x = x+t;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m){\n  int l, i, v, n, o, y;\n\n  l=m;\n  i=0;\n  v=l;\n  n=k;\n  o=3;\n  y=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      y = v+n+o;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      y = v+n+o;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'n', 'o', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m){\n  int l, i, v, n, o, y;\n\n  l=m;\n  i=0;\n  v=l;\n  n=k;\n  o=3;\n  y=4;\n\n  \n  /*@\n\n    loop invariant b == \\at(b, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre);\n\n    loop invariant l == m;\n\n    loop invariant v == l;\n\n    loop invariant (l >= 0) ==> (i <= l);\n\n    loop invariant (i > 0) ==> (y == v + n + o);\n\n    loop assigns y, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      y = v+n+o;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, h, o, a, r, x;\n\n  l=50;\n  i=l;\n  v=l;\n  h=-5;\n  o=-8;\n  a=l;\n  r=p;\n  x=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      h = h+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      h = h+v;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'h', 'i', 'l', 'n', 'o', 'p', 'r', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, h, o, a, r, x;\n\n  l=50;\n  i=l;\n  v=l;\n  h=-5;\n  o=-8;\n  a=l;\n  r=p;\n  x=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i + v == 2*l;\n    loop invariant l <= v && v <= 2*l;\n    loop invariant h == -5 + (v - l)*l + ((v - l)*(v - l + 1))/2;\n    loop invariant 0 <= i && i <= l;\n    loop assigns v, h, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+1;\n      h = h+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int p){\n  int l, i, v, j, q, h, x, r, z, w;\n\n  l=59;\n  i=1;\n  v=k;\n  j=b;\n  q=k;\n  h=l;\n  x=-1;\n  r=l;\n  z=k;\n  w=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      j = j+v;\n      i = i*2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      j = j+v;\n      i = i*2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'h', 'i', 'j', 'k', 'l', 'p', 'q', 'r', 'v', 'w', 'x', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int p){\n  int l, i, v, j, q, h, x, r, z, w;\n\n  l=59;\n  i=1;\n  v=k;\n  j=b;\n  q=k;\n  h=l;\n  x=-1;\n  r=l;\n  z=k;\n  w=k;\n\n  \n  /*@\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant v == k * i;\n\n    loop invariant j == b + 2 * k * (i - 1);\n\n    loop invariant 1 <= i && i <= 2 * l;\n\n    loop assigns v, j, i;\n\n  */\nwhile (i<l) {\n      v = v*2;\n      j = j+v;\n      i = i*2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n){\n  int l, i, v, p, b;\n\n  l=29;\n  i=l;\n  v=a;\n  p=i;\n  b=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+2;\n      b = b+1;\n      b = b+p;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+2;\n      b = b+1;\n      b = b+p;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n){\n  int l, i, v, p, b;\n\n  l=29;\n  i=l;\n  v=a;\n  p=i;\n  b=n;\n\n  \n  /*@\n\n    loop invariant v == a + 2*(l - i);\n\n    loop invariant b == n + (p+1)*(l - i);\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop assigns v, b, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+2;\n      b = b+1;\n      b = b+p;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m){\n  int l, i, v;\n\n  l=(m%9)+13;\n  i=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      if (v+2<l) {\n          v = a-m;\n      }\n      v = v+i;\n      v = v+1;\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      if (v+2<l) {\n          v = a-m;\n      }\n      v = v+i;\n      v = v+1;\n      v = v-v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m){\n  int l, i, v;\n\n  l=(m%9)+13;\n  i=0;\n  v=-1;\n\n  \n  /*@\n\n    loop invariant (0 <= i) && (i <= l);\n\n    loop invariant l == (m % 9) + 13;\n\n    loop invariant (v == -1) || (v == 0);\n\n    loop assigns v, i;\n\n    loop variant (l - i);\n\n  */\n  while (i<l) {\n      v = v-v;\n      if (v+2<l) {\n          v = a-m;\n      }\n      v = v+i;\n      v = v+1;\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int p){\n  int l, i, v, h, o, q, z, c;\n\n  l=60;\n  i=l;\n  v=p;\n  h=p;\n  o=0;\n  q=0;\n  z=l;\n  c=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      h = h+v;\n      o = o%2;\n      z = o*o;\n      o = o%8;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      h = h+v;\n      o = o%2;\n      z = o*o;\n      o = o%8;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'h', 'i', 'k', 'l', 'o', 'p', 'q', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int p){\n  int l, i, v, h, o, q, z, c;\n\n  l=60;\n  i=l;\n  v=p;\n  h=p;\n  o=0;\n  q=0;\n  z=l;\n  c=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant h == 2*v - p;\n    loop invariant 0 <= i && i <= l;\n    loop invariant (o == 0) || (o == 1);\n    loop invariant z <= l;\n    loop invariant p == \\at(p, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop assigns v, h, o, z, i;\n  */\n  while (i>0) {\n      v = v*2;\n      h = h+v;\n      o = o%2;\n      z = o*o;\n      o = o%8;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int p,int q){\n  int l, i, v, n, y, r;\n\n  l=34;\n  i=0;\n  v=l;\n  n=l;\n  y=p;\n  r=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      n = n+y;\n      y = y+v;\n      n = n+i;\n      r = r+2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      n = n+y;\n      y = y+v;\n      n = n+i;\n      r = r+2;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'n', 'p', 'q', 'r', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int p,int q){\n  int l, i, v, n, y, r;\n\n  l=34;\n  i=0;\n  v=l;\n  n=l;\n  y=p;\n  r=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == l;\n    loop invariant r == p + 2*i;\n    loop invariant y == p + i*v;\n    loop invariant n == l + i*p + (i*(i-1)/2)*(v+1);\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop assigns n, y, r, i;\n  */\n  while (i<l) {\n      n = n+y;\n      y = y+v;\n      n = n+i;\n      r = r+2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, u, z, j, q, x, h;\n\n  l=b+7;\n  i=0;\n  v=0;\n  u=2;\n  z=l;\n  j=p;\n  q=n;\n  x=n;\n  h=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      u = u+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      u = u+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'h', 'i', 'j', 'l', 'n', 'p', 'q', 'u', 'v', 'x', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, u, z, j, q, x, h;\n\n  l=b+7;\n  i=0;\n  v=0;\n  u=2;\n  z=l;\n  j=p;\n  q=n;\n  x=n;\n  h=p;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant v == 0;\n\n    loop invariant u == 2;\n\n    loop invariant l == \\at(b, Pre) + 7;\n\n    loop invariant b == \\at(b, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop invariant i <= l || l <= 0;\n\n    loop assigns i, v, u;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v*2;\n      u = u+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k){\n  int l, i, v;\n\n  l=38;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k){\n  int l, i, v;\n\n  l=38;\n  i=0;\n  v=4;\n\n  \n  /*@\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant ((i == 0) ==> (v == 4)) && ((i > 0) ==> (v == 0));\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p,int q){\n  int l, i, v, h, t;\n\n  l=78;\n  i=0;\n  v=q;\n  h=p;\n  t=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      t = t+3;\n      if (p<l+1) {\n          t = t+5;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      t = t+3;\n      if (p<l+1) {\n          t = t+5;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['h', 'i', 'l', 'm', 'p', 'q', 't', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p,int q){\n  int l, i, v, h, t;\n\n  l=78;\n  i=0;\n  v=q;\n  h=p;\n  t=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == q + i;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant (p < l + 1) ==> (t == i * 8);\n    loop invariant (p >= l + 1) ==> (t == i * 3);\n    loop invariant p == \\at(p, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns v, t, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      t = t+3;\n      if (p<l+1) {\n          t = t+5;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v;\n\n  l=27;\n  i=l;\n  v=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      v = v+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      v = v+v;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v;\n\n  l=27;\n  i=l;\n  v=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v >= 1;\n    loop invariant ((v + 2) % 3) == 0;\n    loop assigns i, v;\n    loop variant i;\n  */\nwhile (i>0) {\n      v = v+1;\n      v = v+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p){\n  int l, i, v, a, r;\n\n  l=62;\n  i=0;\n  v=3;\n  a=-5;\n  r=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      a = a-1;\n      r = r+2;\n      if (i+3<=i+l) {\n          a = a+1;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      a = a-1;\n      r = r+2;\n      if (i+3<=i+l) {\n          a = a+1;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'p', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p){\n  int l, i, v, a, r;\n\n  l=62;\n  i=0;\n  v=3;\n  a=-5;\n  r=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant l == 62;\n   loop invariant 0 <= i && i <= l;\n   loop invariant v == 3 + i;\n   loop invariant a == -5;\n   loop invariant r == -8 + 2*i;\n   loop invariant m == \\at(m, Pre);\n   loop invariant n == \\at(n, Pre);\n   loop invariant p == \\at(p, Pre);\n   loop assigns i, v, a, r;\n   loop variant l - i;\n */\nwhile (i<l) {\n      v = v+1;\n      a = a-1;\n      r = r+2;\n      if (i+3<=i+l) {\n          a = a+1;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, x;\n\n  l=63;\n  i=l;\n  v=p;\n  x=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+x+x;\n      v = v+1;\n      v = x-v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+x+x;\n      v = v+1;\n      v = x-v;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'p', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, x;\n\n  l=63;\n  i=l;\n  v=p;\n  x=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant i >= 0;\n   loop invariant i <= l;\n   loop invariant (((l - i) % 2) == 0) ==> (v == p);\n   loop invariant (((l - i) % 2) != 0) ==> (v == -p - x - 1);\n   loop assigns v, i;\n */\nwhile (i>0) {\n      v = v+x+x;\n      v = v+1;\n      v = x-v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m){\n  int l, i, v, f, w;\n\n  l=75;\n  i=l;\n  v=0;\n  f=m;\n  w=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+f+w;\n      v = v+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+f+w;\n      v = v+1;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'f', 'i', 'l', 'm', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m){\n  int l, i, v, f, w;\n\n  l=75;\n  i=l;\n  v=0;\n  f=m;\n  w=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == (l - i) * (f + w + 1);\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop assigns v, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+f+w;\n      v = v+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int q){\n  int l, i, v, e, t;\n\n  l=(b%14)+17;\n  i=0;\n  v=q;\n  e=i;\n  t=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+e+t;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+e+t;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'e', 'i', 'l', 'q', 't', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int q){\n  int l, i, v, e, t;\n\n  l=(b%14)+17;\n  i=0;\n  v=q;\n  e=i;\n  t=q;\n\n  \n  /*@\n\n    loop invariant v == \\at(q, Pre) + i*(e + t + 1);\n\n    loop invariant e == 0;\n\n    loop invariant t == \\at(q, Pre);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+e+t;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n){\n  int l, i, v;\n\n  l=31;\n  i=0;\n  v=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      v = v-v;\n      v = v+1;\n      v = v+4;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      v = v-v;\n      v = v+1;\n      v = v+4;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n){\n  int l, i, v;\n\n  l=31;\n  i=0;\n  v=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant (i == 0) ==> (v == -3);\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+i;\n      v = v-v;\n      v = v+1;\n      v = v+4;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p){\n  int l, i, v, y;\n\n  l=40;\n  i=l;\n  v=b;\n  y=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      y = y-1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      y = y-1;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'p', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p){\n  int l, i, v, y;\n\n  l=40;\n  i=l;\n  v=b;\n  y=l;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant y == i;\n\n    loop invariant v + i == b + l;\n\n    loop assigns i, v, y;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+1;\n      y = y-1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n){\n  int l, i, v, c, j, u, r, a;\n\n  l=53;\n  i=0;\n  v=k;\n  c=l;\n  j=5;\n  u=-2;\n  r=l;\n  a=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      u = v+c+j;\n      v = v+1;\n      u = u+j;\n      r = r+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      u = v+c+j;\n      v = v+1;\n      u = u+j;\n      r = r+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'i', 'j', 'k', 'l', 'n', 'r', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n){\n  int l, i, v, c, j, u, r, a;\n\n  l=53;\n  i=0;\n  v=k;\n  c=l;\n  j=5;\n  u=-2;\n  r=l;\n  a=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == k + i;\n    loop invariant r == l + i;\n    loop invariant i <= l;\n\n    loop invariant (i > 0) ==> (u - v == c + 2*j - 1);\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop assigns i, v, u, r;\n    loop variant l - i;\n  */\n  while (i<l) {\n      u = v+c+j;\n      v = v+1;\n      u = u+j;\n      r = r+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int q){\n  int l, i, v, r, u, o, t, h, c;\n\n  l=16;\n  i=1;\n  v=i;\n  r=8;\n  u=5;\n  o=i;\n  t=i;\n  h=a;\n  c=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      i = i*2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      i = i*2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'h', 'i', 'l', 'o', 'q', 'r', 't', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int q){\n  int l, i, v, r, u, o, t, h, c;\n\n  l=16;\n  i=1;\n  v=i;\n  r=8;\n  u=5;\n  o=i;\n  t=i;\n  h=a;\n  c=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 16;\n    loop invariant i >= 1;\n    loop invariant i <= l;\n    loop invariant l % i == 0;\n    loop invariant a == \\at(a, Pre);\n    loop assigns i;\n  */\n  while (i<l) {\n      i = i*2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n){\n  int l, i, v, x, r, q, k;\n\n  l=22;\n  i=0;\n  v=l;\n  x=l;\n  r=n;\n  q=m;\n  k=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      x = x+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      x = x+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'n', 'q', 'r', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n){\n  int l, i, v, x, r, q, k;\n\n  l=22;\n  i=0;\n  v=l;\n  x=l;\n  r=n;\n  q=m;\n  k=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v == l + 3*i;\n    loop invariant x == l*(i+1) + 3*i*(i+1)/2;\n    loop assigns v, x, i;\n  */\nwhile (i<l) {\n      v = v+3;\n      x = x+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int q){\n  int l, i, v, n;\n\n  l=(k%15)+18;\n  i=0;\n  v=i;\n  n=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+n+n;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+n+n;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int q){\n  int l, i, v, n;\n\n  l=(k%15)+18;\n  i=0;\n  v=i;\n  n=a;\n\n  \n  /*@\n\n    loop invariant l == (k % 15) + 18;\n\n    loop invariant n == a;\n\n    loop invariant v == i*(2*n + 1);\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+n+n;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int q){\n  int l, i, v, y, j, z;\n\n  l=55;\n  i=0;\n  v=l;\n  y=-8;\n  j=-5;\n  z=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      y = y-1;\n      z = z+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      y = y-1;\n      z = z+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'j', 'l', 'n', 'q', 'v', 'y', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int q){\n  int l, i, v, y, j, z;\n\n  l=55;\n  i=0;\n  v=l;\n  y=-8;\n  j=-5;\n  z=i;\n\n  \n  /*@\n\n    loop invariant v == l + i;\n\n    loop invariant y == -8 - i;\n\n    loop invariant z == i*(i-1)/2;\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop assigns v, y, z, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      y = y-1;\n      z = z+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m){\n  int l, i, v, y;\n\n  l=41;\n  i=l;\n  v=b;\n  y=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+y+y;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+y+y;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m){\n  int l, i, v, y;\n\n  l=41;\n  i=l;\n  v=b;\n  y=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v == b + 2*y*(l - i);\n    loop invariant l == 41;\n    loop assigns v, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+y+y;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int q){\n  int l, i, v, y, h, s, d, z;\n\n  l=72;\n  i=0;\n  v=i;\n  y=l;\n  h=q;\n  s=l;\n  d=i;\n  z=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      y = y+h;\n      h = h+v;\n      h = h+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      y = y+h;\n      h = h+v;\n      h = h+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'h', 'i', 'k', 'l', 'q', 's', 'v', 'y', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int q){\n  int l, i, v, y, h, s, d, z;\n\n  l=72;\n  i=0;\n  v=i;\n  y=l;\n  h=q;\n  s=l;\n  d=i;\n  z=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i <= l;\n    loop invariant h == q + i;\n    loop invariant y == l + i*q + i*(i-1)/2;\n    loop assigns i, h, y;\n  */\n  while (i<l) {\n      y = y+h;\n      h = h+v;\n      h = h+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int p){\n  int l, i, v, e, q, d;\n\n  l=69;\n  i=0;\n  v=l;\n  e=l;\n  q=2;\n  d=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      e = e+q;\n      q = q+v;\n      q = q+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      e = e+q;\n      q = q+v;\n      q = q+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'e', 'i', 'k', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int p){\n  int l, i, v, e, q, d;\n\n  l=69;\n  i=0;\n  v=l;\n  e=l;\n  q=2;\n  d=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant e == 69 + 35*i*i - 33*i;\n    loop invariant q == 2 + 70*i;\n    loop invariant v == l;\n    loop assigns e, q, i;\n  */\n  while (i<l) {\n      e = e+q;\n      q = q+v;\n      q = q+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int q){\n  int l, i, v, w, u, f, n;\n\n  l=71;\n  i=0;\n  v=a;\n  w=0;\n  u=1;\n  f=a;\n  n=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      w = w+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      w = w+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'f', 'i', 'l', 'm', 'n', 'q', 'u', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int q){\n  int l, i, v, w, u, f, n;\n\n  l=71;\n  i=0;\n  v=a;\n  w=0;\n  u=1;\n  f=a;\n  n=8;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant l == 71;\n\n    loop invariant w == 2*v - 2*a;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop assigns v, w, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v*2;\n      w = w+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n){\n  int l, i, v, e, z, t;\n\n  l=25;\n  i=l;\n  v=i;\n  e=4;\n  z=a;\n  t=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+3;\n      z = z+3;\n      z = z+t;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+3;\n      z = z+3;\n      z = z+t;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'e', 'i', 'l', 'm', 'n', 't', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n){\n  int l, i, v, e, z, t;\n\n  l=25;\n  i=l;\n  v=i;\n  e=4;\n  z=a;\n  t=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 100 - 3*i;\n    loop invariant z == a + (l - i) * (3 + a);\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant t == a;\n    loop assigns i, v, z;\n  */\n  while (i>0) {\n      v = v+3;\n      z = z+3;\n      z = z+t;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int q){\n  int l, i, v, e;\n\n  l=(a%14)+18;\n  i=l;\n  v=-4;\n  e=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      e = e+v;\n      v = v+3;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      e = e+v;\n      v = v+3;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'e', 'i', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int q){\n  int l, i, v, e;\n\n  l=(a%14)+18;\n  i=l;\n  v=-4;\n  e=a;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v == 4*(l - i) - 4;\n\n    loop invariant e == a + 2*(l - i)*(l - i) - 5*(l - i);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns v, e, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+1;\n      e = e+v;\n      v = v+3;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int p){\n  int l, i, v, f, u, r, m, g;\n\n  l=b-6;\n  i=0;\n  v=b;\n  f=p;\n  u=b;\n  r=i;\n  m=b;\n  g=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      f = f-1;\n      u = u+1;\n      r = r+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      f = f-1;\n      u = u+1;\n      r = r+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'f', 'g', 'i', 'l', 'm', 'p', 'r', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int p){\n  int l, i, v, f, u, r, m, g;\n\n  l=b-6;\n  i=0;\n  v=b;\n  f=p;\n  u=b;\n  r=i;\n  m=b;\n  g=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == b + i;\n    loop invariant f == p - i;\n    loop invariant u == b + i;\n    loop invariant r == i*(i-1)/2;\n    loop invariant 0 <= i;\n    loop invariant i <= l || l < 0;\n    loop assigns v, f, u, r, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      f = f-1;\n      u = u+1;\n      r = r+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      if (v+2<l) {\n          v = v+1;\n      }\n      v = v+i;\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      if (v+2<l) {\n          v = v+1;\n      }\n      v = v+i;\n      v = v-v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant v == 0 || v == l;\n    loop invariant l == 34;\n    loop invariant a == \\at(a, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = v+v;\n      if (v+2<l) {\n          v = v+1;\n      }\n      v = v+i;\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int q){\n  int l, i, v, w, t;\n\n  l=78;\n  i=0;\n  v=m;\n  w=5;\n  t=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      w = w-1;\n      w = w+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      w = w-1;\n      w = w+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'q', 't', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int q){\n  int l, i, v, w, t;\n\n  l=78;\n  i=0;\n  v=m;\n  w=5;\n  t=i;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant v == m + i;\n\n    loop invariant w == 5 + i*m + i*(i - 1)/2;\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns i, v, w;\n\n  */\n  while (i<l) {\n      v = v+1;\n      w = w-1;\n      w = w+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v, u, o, j;\n\n  l=38;\n  i=l;\n  v=-5;\n  u=i;\n  o=i;\n  j=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      if (i%3==1) {\n          v = v+1;\n      }\n      else {\n          u = u+1;\n      }\n      if (i%3==2) {\n          o = o+1;\n      }\n      else {\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      if (i%3==1) {\n          v = v+1;\n      }\n      else {\n          u = u+1;\n      }\n      if (i%3==2) {\n          o = o+1;\n      }\n      else {\n      }\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'j', 'k', 'l', 'm', 'o', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v, u, o, j;\n\n  l=38;\n  i=l;\n  v=-5;\n  u=i;\n  o=i;\n  j=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i > 0;\n    loop invariant v >= -5;\n    loop invariant u >= i;\n    loop invariant o >= i;\n    loop invariant (i % 3 == 1) ==> (u == i) && (o == i);\n    loop invariant (i % 3 != 1) ==> (v == -5);\n    loop assigns v, u, o;\n  */\n  while (i>0) {\n      if (i%3==1) {\n          v = v+1;\n      }\n      else {\n          u = u+1;\n      }\n      if (i%3==2) {\n          o = o+1;\n      }\n      else {\n      }\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p,int q){\n  int l, i, v, c, u, m, r, z;\n\n  l=10;\n  i=l;\n  v=q;\n  c=l;\n  u=6;\n  m=q;\n  r=8;\n  z=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      c = c+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      c = c+v;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'i', 'l', 'm', 'n', 'p', 'q', 'r', 'u', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p,int q){\n  int l, i, v, c, u, m, r, z;\n\n  l=10;\n  i=l;\n  v=q;\n  c=l;\n  u=6;\n  m=q;\n  r=8;\n  z=n;\n\n  \n  /*@\n\n    loop invariant c == l + 2*v - 2*q;\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns c, i, v;\n\n  */\n  while (i>0) {\n      v = v*2;\n      c = c+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n){\n  int l, i, v, j, d, e, y, f;\n\n  l=73;\n  i=0;\n  v=5;\n  j=l;\n  d=n;\n  e=k;\n  y=i;\n  f=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      i = i+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      i = i+3;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'd', 'e', 'f', 'i', 'j', 'k', 'l', 'n', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n){\n  int l, i, v, j, d, e, y, f;\n\n  l=73;\n  i=0;\n  v=5;\n  j=l;\n  d=n;\n  e=k;\n  y=i;\n  f=n;\n\n  \n  /*@\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant 0 <= i;\n\n    loop invariant i % 3 == 0;\n\n    loop invariant v % 5 == 0;\n\n    loop invariant i <= l + 2;\n\n    loop invariant v >= 5;\n\n    loop assigns i, v;\n\n  */\nwhile (i<l) {\n      v = v*2;\n      i = i+3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int p,int q){\n  int l, i, v, o, d;\n\n  l=37;\n  i=0;\n  v=-4;\n  o=p;\n  d=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      o = o+v;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      o = o+v;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'i', 'k', 'l', 'o', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int p,int q){\n  int l, i, v, o, d;\n\n  l=37;\n  i=0;\n  v=-4;\n  o=p;\n  d=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == -4 + 2*i;\n    loop invariant o == p + i*i - 4*i;\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant k == \\at(k, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop assigns v, o, i;\n  */\n  while (i<l) {\n      v = v+1;\n      o = o+v;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int q){\n  int l, i, v, p, w, g;\n\n  l=35;\n  i=l;\n  v=1;\n  p=a;\n  w=i;\n  g=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*3+4;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*3+4;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'g', 'i', 'k', 'l', 'p', 'q', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int q){\n  int l, i, v, p, w, g;\n\n  l=35;\n  i=l;\n  v=1;\n  p=a;\n  w=i;\n  g=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant ((v + 2) % 3) == 0;\n    loop invariant v >= 1;\n    loop assigns v, i;\n  */\n  while (i>0) {\n      v = v*3+4;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int p,int q){\n  int l, i, v;\n\n  l=40;\n  i=0;\n  v=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+3<l) {\n          v = v-v;\n      }\n      else {\n          v = v+6;\n      }\n      v = v+i;\n      v = v+v;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+3<l) {\n          v = v-v;\n      }\n      else {\n          v = v+6;\n      }\n      v = v+i;\n      v = v+v;\n      v = v+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int p,int q){\n  int l, i, v;\n\n  l=40;\n  i=0;\n  v=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant b == \\at(b, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant l == 40;\n    loop invariant 0 <= i <= l;\n    loop invariant v % 4 == 0;\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      if (v+3<l) {\n          v = v-v;\n      }\n      else {\n          v = v+6;\n      }\n      v = v+i;\n      v = v+v;\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, h, e, w, u, k;\n\n  l=39;\n  i=l;\n  v=b;\n  h=-1;\n  e=n;\n  w=l;\n  u=p;\n  k=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      h = h+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      h = h+v;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'e', 'h', 'i', 'k', 'l', 'n', 'p', 'u', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, h, e, w, u, k;\n\n  l=39;\n  i=l;\n  v=b;\n  h=-1;\n  e=n;\n  w=l;\n  u=p;\n  k=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v == b + (l - i);\n    loop invariant h == -1 + (l - i) * b + ((l - i) * (l - i + 1)) / 2;\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop assigns v, h, i;\n  */\n  while (i>0) {\n      v = v+1;\n      h = h+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n){\n  int l, i, v;\n\n  l=m;\n  i=0;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      v = v+2;\n      if (i+2<=v+l) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      v = v+2;\n      if (i+2<=v+l) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n){\n  int l, i, v;\n\n  l=m;\n  i=0;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant l == m;\n   loop invariant i >= 0;\n   loop invariant (l >= 0) ==> (i <= l);\n   loop invariant (i == 0) ==> (v == b);\n   loop assigns i, v;\n   loop variant (l - i);\n */\nwhile (i<l) {\n      v = v-v;\n      v = v+2;\n      if (i+2<=v+l) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int p){\n  int l, i, v;\n\n  l=22;\n  i=0;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int p){\n  int l, i, v;\n\n  l=22;\n  i=0;\n  v=b;\n\n  \n  /*@\n\n    loop invariant v - 2*i == b;\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int p){\n  int l, i, v, c, r, q, n;\n\n  l=30;\n  i=0;\n  v=a;\n  c=-1;\n  r=p;\n  q=i;\n  n=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      c = c+v;\n      c = c+q;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      c = c+v;\n      c = c+q;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'i', 'l', 'n', 'p', 'q', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int p){\n  int l, i, v, c, r, q, n;\n\n  l=30;\n  i=0;\n  v=a;\n  c=-1;\n  r=p;\n  q=i;\n  n=i;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant 0 <= i;\n\n    loop invariant v == a + i;\n\n    loop invariant c == -1 + i*a + i*(i+1)/2;\n\n    loop invariant q == 0;\n\n    loop invariant l == 30;\n\n    loop assigns v, c, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      c = c+v;\n      c = c+q;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int q){\n  int l, i, v, o;\n\n  l=(b%7)+14;\n  i=0;\n  v=n;\n  o=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      o = o-1;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      o = o-1;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'o', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int q){\n  int l, i, v, o;\n\n  l=(b%7)+14;\n  i=0;\n  v=n;\n  o=n;\n\n  \n  /*@\n\n    loop invariant v == n + i*(i+1)/2;\n\n    loop invariant o == n - i;\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant l == (b % 7) + 14;\n\n    loop assigns v, o, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      o = o-1;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int q){\n  int l, i, v, p, h, k, u, n;\n\n  l=(a%16)+16;\n  i=0;\n  v=a;\n  p=b;\n  h=a;\n  k=8;\n  u=a;\n  n=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      p = p+h;\n      h = h+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      p = p+h;\n      h = h+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'h', 'i', 'k', 'l', 'n', 'p', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int q){\n  int l, i, v, p, h, k, u, n;\n\n  l=(a%16)+16;\n  i=0;\n  v=a;\n  p=b;\n  h=a;\n  k=8;\n  u=a;\n  n=1;\n\n  \n  /*@\n\n    loop invariant v == a;\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant h == a*(i+1);\n\n    loop invariant p == b + a * i * (i+1) / 2;\n\n    loop invariant l == (a % 16) + 16;\n\n    loop assigns p, h, i;\n\n  */\n  while (i<l) {\n      p = p+h;\n      h = h+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int q){\n  int l, i, v, r, d, a, t;\n\n  l=(m%8)+16;\n  i=l;\n  v=i;\n  r=l;\n  d=5;\n  a=m;\n  t=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      r = r/2;\n      v = r*r;\n      v = v+r;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      r = r/2;\n      v = r*r;\n      v = v+r;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'd', 'i', 'l', 'm', 'n', 'q', 'r', 't', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int q){\n  int l, i, v, r, d, a, t;\n\n  l=(m%8)+16;\n  i=l;\n  v=i;\n  r=l;\n  d=5;\n  a=m;\n  t=n;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant r >= 0;\n\n    loop invariant r <= l;\n\n    loop invariant v >= 0;\n\n    loop invariant i < l ==> v == r*r + r;\n\n    loop assigns v, r, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v*2;\n      r = r/2;\n      v = r*r;\n      v = v+r;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n){\n  int l, i, v, h, t, y, m, c, j, s;\n\n  l=19;\n  i=l;\n  v=i;\n  h=-8;\n  t=-6;\n  y=0;\n  m=a;\n  c=a;\n  j=b;\n  s=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n      v = v*3+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n      v = v*3+2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'h', 'i', 'j', 'l', 'm', 'n', 's', 't', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n){\n  int l, i, v, h, t, y, m, c, j, s;\n\n  l=19;\n  i=l;\n  v=i;\n  h=-8;\n  t=-6;\n  y=0;\n  m=a;\n  c=a;\n  j=b;\n  s=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 19;\n    loop invariant v >= 0;\n    loop invariant v <= 3*v + 5;\n    loop assigns v;\n  */\n  while (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n      v = v*3+2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int p,int q){\n  int l, i, v, r, t, d;\n\n  l=k;\n  i=0;\n  v=q;\n  r=i;\n  t=-1;\n  d=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      r = r*r;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      r = r*r;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'i', 'k', 'l', 'p', 'q', 'r', 't', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int p,int q){\n  int l, i, v, r, t, d;\n\n  l=k;\n  i=0;\n  v=q;\n  r=i;\n  t=-1;\n  d=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l || l < 0;\n    loop invariant v == q + i*(i-1)/2;\n    loop invariant r == 0;\n    loop invariant l == k;\n    loop invariant q == \\at(q, Pre);\n    loop assigns v, r, i;\n  */\n  while (i<l) {\n      v = v+i;\n      r = r*r;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n){\n  int l, i, v, g, y, s, w, x, r, t;\n\n  l=58;\n  i=l;\n  v=l;\n  g=l;\n  y=m;\n  s=-1;\n  w=n;\n  x=n;\n  r=n;\n  t=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+g;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+g;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['g', 'i', 'k', 'l', 'm', 'n', 'r', 's', 't', 'v', 'w', 'x', 'y']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n){\n  int l, i, v, g, y, s, w, x, r, t;\n\n  l=58;\n  i=l;\n  v=l;\n  g=l;\n  y=m;\n  s=-1;\n  w=n;\n  x=n;\n  r=n;\n  t=-3;\n\n  \n  /*@\n\n    loop invariant g == l;\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v >= l;\n\n    loop invariant (v - l) % g == 0;\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+g;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int q){\n  int l, i, v;\n\n  l=36;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int q){\n  int l, i, v;\n\n  l=36;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 36;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v == 0;\n    loop assigns v, i;\n  */\n  while (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p){\n  int l, i, v;\n\n  l=(b%6)+15;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      v = v-v;\n      v = v-v;\n      v = v+i;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      v = v-v;\n      v = v-v;\n      v = v+i;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p){\n  int l, i, v;\n\n  l=(b%6)+15;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == (b % 6) + 15;\n    loop invariant 0 <= i && i <= l;\n    loop invariant (i == 0) ==> (v == m);\n    loop invariant (i > 0) ==> (v == 2*(i - 1));\n    loop invariant b == \\at(b, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre);\n    loop assigns v, i;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      v = v+1;\n      v = v-v;\n      v = v-v;\n      v = v+i;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p){\n  int l, i, v, s, t, w, k, u, b, a;\n\n  l=24;\n  i=0;\n  v=l;\n  s=-4;\n  t=l;\n  w=p;\n  k=l;\n  u=0;\n  b=m;\n  a=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+s;\n      s = s+t;\n      i = i+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+s;\n      s = s+t;\n      i = i+2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'm', 'n', 'p', 's', 't', 'u', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p){\n  int l, i, v, s, t, w, k, u, b, a;\n\n  l=24;\n  i=0;\n  v=l;\n  s=-4;\n  t=l;\n  w=p;\n  k=l;\n  u=0;\n  b=m;\n  a=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant s == -4 + (i/2) * l;\n    loop invariant v == l - 4*(i/2) + l * ((i/2) * ((i/2) - 1)) / 2;\n    loop invariant 0 <= i <= l;\n    loop invariant i % 2 == 0;\n    loop assigns i, v, s;\n  */\n  while (i<l) {\n      v = v+s;\n      s = s+t;\n      i = i+2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, u, f, h;\n\n  l=59;\n  i=l;\n  v=8;\n  u=3;\n  f=b;\n  h=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      f = f+3;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      f = f+3;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'f', 'h', 'i', 'l', 'n', 'p', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, u, f, h;\n\n  l=59;\n  i=l;\n  v=8;\n  u=3;\n  f=b;\n  h=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 8 + (l - i);\n    loop invariant f == b + 3 * (l - i);\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop assigns i, v, f;\n  */\n  while (i>0) {\n      v = v+1;\n      f = f+3;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n){\n  int l, i, v, q, m;\n\n  l=9;\n  i=l;\n  v=n;\n  q=2;\n  m=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      q = q+v;\n      q = q+i;\n      if (i+6<=l+l) {\n          v = v+1;\n      }\n      else {\n          m = m+1;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      q = q+v;\n      q = q+i;\n      if (i+6<=l+l) {\n          v = v+1;\n      }\n      else {\n          m = m+1;\n      }\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n){\n  int l, i, v, q, m;\n\n  l=9;\n  i=l;\n  v=n;\n  q=2;\n  m=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant i <= l;\n   loop invariant i >= 0;\n   loop invariant v == n + 2*(l - i);\n   loop invariant q == 2 + (l - i)*(n + l + 1) + ((l - i)*(l - i - 1))/2;\n   loop invariant m == 6;\n   loop assigns v, q, m, i;\n   loop variant i;\n */\nwhile (i>0) {\n      v = v+1;\n      q = q+v;\n      q = q+i;\n      if (i+6<=l+l) {\n          v = v+1;\n      }\n      else {\n          m = m+1;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int q){\n  int l, i, v, c;\n\n  l=66;\n  i=0;\n  v=6;\n  c=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      c = c-1;\n      if (i<i+2) {\n          c = c+v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      c = c-1;\n      if (i<i+2) {\n          c = c+v;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'i', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int q){\n  int l, i, v, c;\n\n  l=66;\n  i=0;\n  v=6;\n  c=i;\n\n  \n  /*@\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant v == 6 + i;\n\n    loop invariant c == (i*i + 11*i) / 2;\n\n    loop assigns v, c, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      c = c-1;\n      if (i<i+2) {\n          c = c+v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int p){\n  int l, i, v, y, t, c, q, g;\n\n  l=58;\n  i=l;\n  v=m;\n  y=l;\n  t=2;\n  c=l;\n  q=m;\n  g=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      y = y+v;\n      c = -4;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      y = y+v;\n      c = -4;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'g', 'i', 'k', 'l', 'm', 'p', 'q', 't', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int p){\n  int l, i, v, y, t, c, q, g;\n\n  l=58;\n  i=l;\n  v=m;\n  y=l;\n  t=2;\n  c=l;\n  q=m;\n  g=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v + i == m + l;\n    loop invariant y == l + (l - i) * m + ((l - i) * (l - i + 1)) / 2;\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant (i < l) ==> c == -4;\n    loop assigns v, y, c, i;\n  */\n  while (i>0) {\n      v = v+1;\n      y = y+v;\n      c = -4;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int q){\n  int l, i, v, h;\n\n  l=63;\n  i=0;\n  v=i;\n  h=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      h = h-1;\n      v = v+h;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      h = h-1;\n      v = v+h;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'h', 'i', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int q){\n  int l, i, v, h;\n\n  l=63;\n  i=0;\n  v=i;\n  h=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 63;\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant h == -i;\n    loop invariant 2*v == -(i*(i-1));\n    loop assigns i, v, h;\n  */\n  while (i<l) {\n      v = v+1;\n      h = h-1;\n      v = v+h;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int q){\n  int l, i, v, m, h, w, r, f, g;\n\n  l=62;\n  i=l;\n  v=0;\n  m=k;\n  h=4;\n  w=1;\n  r=a;\n  f=-8;\n  g=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      w = w*w+v;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      w = w*w+v;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'q', 'r', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int q){\n  int l, i, v, m, h, w, r, f, g;\n\n  l=62;\n  i=l;\n  v=0;\n  m=k;\n  h=4;\n  w=1;\n  r=a;\n  f=-8;\n  g=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant w == 1;\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns i, w;\n    loop variant i;\n  */\n  while (i>0) {\n      w = w*w+v;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int p,int q){\n  int l, i, v;\n\n  l=58;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v<l+2) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v<l+2) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int p,int q){\n  int l, i, v;\n\n  l=58;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant 0 <= i && i <= l;\n   loop invariant l <= v && v <= 2*l;\n   loop invariant (i == 0) ==> (v == l);\n   loop invariant (i > 0) ==> (v == 2*l);\n   loop invariant l == 58;\n   loop invariant b == \\at(b, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n   loop assigns v, i;\n   loop variant l - i;\n */\nwhile (i<l) {\n      if (v<l+2) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m){\n  int l, i, v;\n\n  l=40;\n  i=0;\n  v=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      v = v-v;\n      v = v+v;\n      v = v+v;\n      v = v+6;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      v = v-v;\n      v = v+v;\n      v = v+v;\n      v = v+6;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m){\n  int l, i, v;\n\n  l=40;\n  i=0;\n  v=-2;\n\n  \n  /*@\n\n    loop invariant l == 40;\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant (i == 0) ==> (v == -2);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      v = v-v;\n      v = v+v;\n      v = v+v;\n      v = v+6;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int q){\n  int l, i, v, s, m, f;\n\n  l=43;\n  i=l;\n  v=q;\n  s=1;\n  m=i;\n  f=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+i;\n      s = s*s;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+i;\n      s = s*s;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'f', 'i', 'l', 'm', 'n', 'q', 's', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int q){\n  int l, i, v, s, m, f;\n\n  l=43;\n  i=l;\n  v=q;\n  s=1;\n  m=i;\n  f=q;\n\n  \n  /*@\n\n    loop invariant v == q + (l - i) * l - ((l - i) * (l - i - 1)) / 2;\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant s == 1;\n\n    loop assigns v, i, s;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+i;\n      s = s*s;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p){\n  int l, i, v;\n\n  l=46;\n  i=l;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      v = v+4;\n      v = v-v;\n      v = v+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      v = v+4;\n      v = v-v;\n      v = v+v;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p){\n  int l, i, v;\n\n  l=46;\n  i=l;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 46;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v == a || v == 0;\n    loop invariant a == \\at(a, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop assigns v, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+1;\n      v = v+4;\n      v = v-v;\n      v = v+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p,int q){\n  int l, i, v, j, g, b, e, d, h, t;\n\n  l=40;\n  i=l;\n  v=i;\n  j=-5;\n  g=l;\n  b=l;\n  e=p;\n  d=q;\n  h=l;\n  t=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+j;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+j;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'd', 'e', 'g', 'h', 'i', 'j', 'l', 'p', 'q', 't', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p,int q){\n  int l, i, v, j, g, b, e, d, h, t;\n\n  l=40;\n  i=l;\n  v=i;\n  j=-5;\n  g=l;\n  b=l;\n  e=p;\n  d=q;\n  h=l;\n  t=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant j == -5;\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v == 5*i - 4*l;\n    loop assigns i, v;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+j;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int p){\n  int l, i, v, t, b, f;\n\n  l=30;\n  i=l;\n  v=6;\n  t=l;\n  b=3;\n  f=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+5;\n      b = b+1;\n      if ((i%7)==0) {\n          b = b+1;\n      }\n      else {\n          b = b+4;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+5;\n      b = b+1;\n      if ((i%7)==0) {\n          b = b+1;\n      }\n      else {\n          b = b+4;\n      }\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'f', 'i', 'k', 'l', 'n', 'p', 't', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int p){\n  int l, i, v, t, b, f;\n\n  l=30;\n  i=l;\n  v=6;\n  t=l;\n  b=3;\n  f=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 6 + 5*(l - i);\n    loop invariant b == 3 + 5*(l - i) - 3*( (l/7) - (i/7) );\n    loop invariant 0 <= i && i <= l;\n    loop invariant l == 30;\n    loop assigns v, b, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+5;\n      b = b+1;\n      if ((i%7)==0) {\n          b = b+1;\n      }\n      else {\n          b = b+4;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n){\n  int l, i, v, f, r, q, g, t, k;\n\n  l=15;\n  i=l;\n  v=b;\n  f=l;\n  r=i;\n  q=l;\n  g=-4;\n  t=-8;\n  k=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+f;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+f;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'f', 'g', 'i', 'k', 'l', 'n', 'q', 'r', 't', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n){\n  int l, i, v, f, r, q, g, t, k;\n\n  l=15;\n  i=l;\n  v=b;\n  f=l;\n  r=i;\n  q=l;\n  g=-4;\n  t=-8;\n  k=i;\n\n  \n  /*@\n\n    loop invariant f == l;\n\n    loop invariant (v - b) % l == 0;\n\n    loop invariant v >= b;\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+f;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m){\n  int l, i, v;\n\n  l=71;\n  i=l;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      if (b<b+1) {\n          v = v+1;\n      }\n      else {\n          v = v+1;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      if (b<b+1) {\n          v = v+1;\n      }\n      else {\n          v = v+1;\n      }\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m){\n  int l, i, v;\n\n  l=71;\n  i=l;\n  v=m;\n\n  \n  /*@\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant v == m + (l - i);\n\n    loop assigns v, i;\n\n  */\n  while (i>0) {\n      if (b<b+1) {\n          v = v+1;\n      }\n      else {\n          v = v+1;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n){\n  int l, i, v;\n\n  l=60;\n  i=0;\n  v=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      v = v+1;\n      if (i+1<=v+l) {\n          v = v+1;\n      }\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      v = v+1;\n      if (i+1<=v+l) {\n          v = v+1;\n      }\n      v = v-v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n){\n  int l, i, v;\n\n  l=60;\n  i=0;\n  v=6;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant l == 60;\n\n    loop invariant v >= 0;\n\n    loop invariant v == 0 || (i == 0 && v == 6);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+v;\n      v = v+1;\n      if (i+1<=v+l) {\n          v = v+1;\n      }\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, z, r, o, s, w, a, y;\n\n  l=60;\n  i=l;\n  v=n;\n  z=n;\n  r=n;\n  o=p;\n  s=-5;\n  w=-4;\n  a=-3;\n  y=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2+1;\n      z = z*v+1;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2+1;\n      z = z*v+1;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'n', 'o', 'p', 'r', 's', 'v', 'w', 'y', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, z, r, o, s, w, a, y;\n\n  l=60;\n  i=l;\n  v=n;\n  z=n;\n  r=n;\n  o=p;\n  s=-5;\n  w=-4;\n  a=-3;\n  y=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant (i == l) ==> (v == n);\n    loop invariant (i == l) ==> (z == n);\n    loop assigns v, z, i;\n  */\n  while (i>0) {\n      v = v*2+1;\n      z = z*v+1;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, g, t, s;\n\n  l=56;\n  i=0;\n  v=i;\n  g=i;\n  t=l;\n  s=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*3+3;\n      g = g*v+3;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*3+3;\n      g = g*v+3;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'g', 'i', 'l', 'n', 'p', 's', 't', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, g, t, s;\n\n  l=56;\n  i=0;\n  v=i;\n  g=i;\n  t=l;\n  s=i;\n\n  \n  /*@\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant v >= 0;\n\n    loop invariant g >= 0;\n\n    loop invariant (i > 0) ==> (v >= 3);\n\n    loop invariant (i > 0) ==> (g >= 3);\n\n    loop assigns v, g, i;\n\n  */\n  while (i<l) {\n      v = v*3+3;\n      g = g*v+3;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int q){\n  int l, i, v, g, w, u, y, t, c, h;\n\n  l=(b%8)+7;\n  i=0;\n  v=-2;\n  g=b;\n  w=-6;\n  u=-3;\n  y=2;\n  t=l;\n  c=q;\n  h=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+g;\n      g = g+w;\n      w = w+3;\n      g = h+i;\n      w = w*2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+g;\n      g = g+w;\n      w = w+3;\n      g = h+i;\n      w = w*2;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'g', 'h', 'i', 'l', 'm', 'q', 't', 'u', 'v', 'w', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int q){\n  int l, i, v, g, w, u, y, t, c, h;\n\n  l=(b%8)+7;\n  i=0;\n  v=-2;\n  g=b;\n  w=-6;\n  u=-3;\n  y=2;\n  t=l;\n  c=q;\n  h=l;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant w == -6;\n\n    loop invariant h == l;\n\n    loop invariant (i == 0) ==> (v == -2);\n\n    loop invariant (i > 0) ==> (g == h + i - 1);\n\n    loop assigns v, g, w, i;\n\n  */\n  while (i<l) {\n      v = v+g;\n      g = g+w;\n      w = w+3;\n      g = h+i;\n      w = w*2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int q){\n  int l, i, v, z, d, m, w, j, b, x;\n\n  l=18;\n  i=l;\n  v=l;\n  z=4;\n  d=k;\n  m=q;\n  w=0;\n  j=-6;\n  b=-3;\n  x=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+i;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+i;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'i', 'j', 'k', 'l', 'm', 'n', 'q', 'v', 'w', 'x', 'z']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int q){\n  int l, i, v, z, d, m, w, j, b, x;\n\n  l=18;\n  i=l;\n  v=l;\n  z=4;\n  d=k;\n  m=q;\n  w=0;\n  j=-6;\n  b=-3;\n  x=-6;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant v == l + (l*(l+1))/2 - (i*(i+1))/2;\n\n    loop invariant v <= l + (l*(l+1))/2;\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+i;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v, p, j;\n\n  l=57;\n  i=0;\n  v=8;\n  p=0;\n  j=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      p = p+j;\n      j = j+v;\n      p = p+6;\n      p = p+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      p = p+j;\n      j = j+v;\n      p = p+6;\n      p = p+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'j', 'k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v, p, j;\n\n  l=57;\n  i=0;\n  v=8;\n  p=0;\n  j=l;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant l == 57;\n\n    loop invariant j == 57 + 8*i;\n\n    loop invariant p == 4*i*i + 60*i;\n\n    loop invariant v == 8;\n\n    loop invariant 0 <= i;\n\n    loop assigns i, j, p;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      p = p+j;\n      j = j+v;\n      p = p+6;\n      p = p+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v, b;\n\n  l=17;\n  i=0;\n  v=4;\n  b=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+4;\n      b = b+4;\n      b = b+v;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+4;\n      b = b+4;\n      b = b+v;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v, b;\n\n  l=17;\n  i=0;\n  v=4;\n  b=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant v == 4 + 5*i;\n   loop invariant b == k + 12*i + (5*i*(i-1))/2;\n   loop invariant 0 <= i && i <= l;\n   loop invariant l == 17;\n   loop assigns v, b, i;\n */\nwhile (i<l) {\n      v = v+4;\n      b = b+4;\n      b = b+v;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int q){\n  int l, i, v, y;\n\n  l=80;\n  i=l;\n  v=l;\n  y=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      y = y-1;\n      v = v+1;\n      y = y+1;\n      if (v+4<l) {\n          y = y+i;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      y = y-1;\n      v = v+1;\n      y = y+1;\n      if (v+4<l) {\n          y = y+i;\n      }\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int q){\n  int l, i, v, y;\n\n  l=80;\n  i=l;\n  v=l;\n  y=3;\n\n  \n  /*@\n\n    loop invariant v == 3*l - 2*i;\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant y == 3;\n\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && q == \\at(q, Pre);\n\n    loop invariant l == 80;\n\n    loop assigns v, i, y;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+1;\n      y = y-1;\n      v = v+1;\n      y = y+1;\n      if (v+4<l) {\n          y = y+i;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n){\n  int l, i, v, q;\n\n  l=34;\n  i=0;\n  v=b;\n  q=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+q+q;\n      v = v+1;\n      v = q-v;\n      if (i+5<=i+l) {\n          v = l+b;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+q+q;\n      v = v+1;\n      v = q-v;\n      if (i+5<=i+l) {\n          v = l+b;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n){\n  int l, i, v, q;\n\n  l=34;\n  i=0;\n  v=b;\n  q=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant (i == 0) ==> (v == b);\n    loop invariant (i > 0) ==> (v == l + b);\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+q+q;\n      v = v+1;\n      v = q-v;\n      if (i+5<=i+l) {\n          v = l+b;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int p){\n  int l, i, v;\n\n  l=36;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (i+2<=p+l) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (i+2<=p+l) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int p){\n  int l, i, v;\n\n  l=36;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 36;\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant v == 0 || v == 4;\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      if (i+2<=p+l) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int p){\n  int l, i, v, y;\n\n  l=57;\n  i=0;\n  v=a;\n  y=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      y = y-1;\n      v = v+y;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      y = y-1;\n      v = v+y;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'p', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int p){\n  int l, i, v, y;\n\n  l=57;\n  i=0;\n  v=a;\n  y=b;\n\n  \n  /*@\n\n    loop invariant v == a + b*i;\n\n    loop invariant y == b - i;\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop assigns v, y, i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      y = y-1;\n      v = v+y;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int q){\n  int l, i, v, u, g;\n\n  l=58;\n  i=0;\n  v=2;\n  u=n;\n  g=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      u = u+v;\n      g = g+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      u = u+v;\n      g = g+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['g', 'i', 'k', 'l', 'n', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int q){\n  int l, i, v, u, g;\n\n  l=58;\n  i=0;\n  v=2;\n  u=n;\n  g=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i <= l;\n    loop invariant v == i + 2;\n    loop invariant u == n + (i*i + 5*i)/2;\n    loop invariant g == n + i*(i-1)/2;\n    loop assigns i, v, u, g;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      u = u+v;\n      g = g+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p,int q){\n  int l, i, v;\n\n  l=43;\n  i=0;\n  v=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p,int q){\n  int l, i, v;\n\n  l=43;\n  i=0;\n  v=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 43;\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant v <= -2;\n    loop invariant (i == 0) ==> (v == -2);\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+v;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int p,int q){\n  int l, i, v, f, h, m, r;\n\n  l=76;\n  i=0;\n  v=i;\n  f=4;\n  h=k;\n  m=l;\n  r=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+2<=l) {\n          v = v+2;\n      }\n      else {\n          v = l;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+2<=l) {\n          v = v+2;\n      }\n      else {\n          v = l;\n      }\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['f', 'h', 'i', 'k', 'l', 'm', 'p', 'q', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int p,int q){\n  int l, i, v, f, h, m, r;\n\n  l=76;\n  i=0;\n  v=i;\n  f=4;\n  h=k;\n  m=l;\n  r=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i == 0;\n    loop invariant l == 76;\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant 0 <= v;\n    loop invariant v <= l;\n    loop invariant (v == l) || (v % 2 == 0);\n    loop invariant k == \\at(k, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns v;\n  */\n  while (i<l) {\n      if (v+2<=l) {\n          v = v+2;\n      }\n      else {\n          v = l;\n      }\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p){\n  int l, i, v, t, q, r, g;\n\n  l=49;\n  i=0;\n  v=4;\n  t=p;\n  q=p;\n  r=a;\n  g=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      t = t-1;\n      t = t+i;\n      q = r-q;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      t = t-1;\n      t = t+i;\n      q = r-q;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'g', 'i', 'l', 'n', 'p', 'q', 'r', 't', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p){\n  int l, i, v, t, q, r, g;\n\n  l=49;\n  i=0;\n  v=4;\n  t=p;\n  q=p;\n  r=a;\n  g=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant v == i + 4;\n    loop invariant t == p + (i*i - 3*i)/2;\n    loop invariant (i % 2 == 0) ==> (q == p);\n    loop invariant (i % 2 != 0) ==> (q == a - p);\n    loop assigns v, t, q, i;\n  */\n  while (i<l) {\n      v = v+1;\n      t = t-1;\n      t = t+i;\n      q = r-q;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int q){\n  int l, i, v, d, h, e, x;\n\n  l=55;\n  i=0;\n  v=i;\n  d=-2;\n  h=i;\n  e=n;\n  x=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+4;\n      d = d+v;\n      h = h+d;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+4;\n      d = d+v;\n      h = h+d;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'e', 'h', 'i', 'l', 'n', 'q', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int q){\n  int l, i, v, d, h, e, x;\n\n  l=55;\n  i=0;\n  v=i;\n  d=-2;\n  h=i;\n  e=n;\n  x=1;\n\n  \n  /*@\n\n    loop invariant v == 4*i;\n\n    loop invariant d == 2*i*i + 2*i - 2;\n\n    loop invariant h == (2*i*i*i + 6*i*i - 2*i)/3;\n\n    loop invariant 0 <= i <= l;\n\n    loop assigns v, d, h, i;\n\n  */\nwhile (i<l) {\n      v = v+4;\n      d = d+v;\n      h = h+d;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p){\n  int l, i, v, e, d, m, w;\n\n  l=10;\n  i=0;\n  v=5;\n  e=i;\n  d=p;\n  m=i;\n  w=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      d = d+4;\n      m = m+4;\n      d = m-d;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      d = d+4;\n      m = m+4;\n      d = m-d;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'd', 'e', 'i', 'l', 'm', 'n', 'p', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p){\n  int l, i, v, e, d, m, w;\n\n  l=10;\n  i=0;\n  v=5;\n  e=i;\n  d=p;\n  m=i;\n  w=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i <= l;\n    loop invariant v == 5 + 3*i;\n    loop invariant m == 4*i;\n    loop invariant (i % 2 == 0) ==> (d == p + 2*i);\n    loop invariant (i % 2 == 1) ==> (d == -p + 2*i - 2);\n    loop invariant a == \\at(a, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop assigns v, d, m, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+3;\n      d = d+4;\n      m = m+4;\n      d = m-d;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int q){\n  int l, i, v, k, g, f, r;\n\n  l=43;\n  i=1;\n  v=i;\n  k=q;\n  g=-4;\n  f=m;\n  r=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      k = k+v;\n      i = i*2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      k = k+v;\n      i = i*2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'f', 'g', 'i', 'k', 'l', 'm', 'q', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int q){\n  int l, i, v, k, g, f, r;\n\n  l=43;\n  i=1;\n  v=i;\n  k=q;\n  g=-4;\n  f=m;\n  r=a;\n\n  \n  /*@\n\n    loop invariant v == i;\n\n    loop invariant k == q + 2*i - 2;\n\n    loop invariant 1 <= i && i <= 2*l;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns v, k, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v*2;\n      k = k+v;\n      i = i*2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int p){\n  int l, i, v, u, x;\n\n  l=58;\n  i=0;\n  v=i;\n  u=l;\n  x=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      u = u+x;\n      x = x+v;\n      if ((i%6)==0) {\n          u = u+5;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      u = u+x;\n      x = x+v;\n      if ((i%6)==0) {\n          u = u+5;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'p', 'u', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int p){\n  int l, i, v, u, x;\n\n  l=58;\n  i=0;\n  v=i;\n  u=l;\n  x=l;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant v == 0;\n\n    loop invariant x == l;\n\n    loop invariant u == l + l*i + 5 * ((i + 5) / 6);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop assigns u, x, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      u = u+x;\n      x = x+v;\n      if ((i%6)==0) {\n          u = u+5;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int q){\n  int l, i, v, s, a, d;\n\n  l=70;\n  i=1;\n  v=q;\n  s=q;\n  a=-6;\n  d=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      s = s*s;\n      i = i*3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      s = s*s;\n      i = i*3;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'd', 'i', 'k', 'l', 'm', 'q', 's', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int q){\n  int l, i, v, s, a, d;\n\n  l=70;\n  i=1;\n  v=q;\n  s=q;\n  a=-6;\n  d=6;\n\n  \n  /*@\n\n    loop invariant i - 2*v == 1 - 2 * \\at(q,Pre);\n\n    loop invariant i >= 1 && (i == 1 || i % 3 == 0);\n\n    loop invariant (i == 1 && s == \\at(q,Pre)) || (i > 1 && s >= 0);\n\n    loop invariant k == \\at(k,Pre) && m == \\at(m,Pre) && q == \\at(q,Pre);\n\n    loop invariant i <= 3 * l;\n\n    loop assigns v, s, i;\n\n  */\nwhile (i<l) {\n      v = v+i;\n      s = s*s;\n      i = i*3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int q){\n  int l, i, v, t, a, p, b;\n\n  l=q-4;\n  i=0;\n  v=n;\n  t=0;\n  a=-2;\n  p=i;\n  b=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      t = t*t;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      t = t*t;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'n', 'p', 'q', 't', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int q){\n  int l, i, v, t, a, p, b;\n\n  l=q-4;\n  i=0;\n  v=n;\n  t=0;\n  a=-2;\n  p=i;\n  b=l;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant (l <= 0) || i <= l;\n\n    loop invariant v == \\at(n, Pre) + i*(i-1)/2;\n\n    loop invariant t == 0;\n\n    loop invariant k == \\at(k, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n\n    loop assigns v, t, i;\n\n  */\nwhile (i<l) {\n      v = v+i;\n      t = t*t;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int q){\n  int l, i, v, e, o, s, j, w, d, m;\n\n  l=(n%29)+18;\n  i=0;\n  v=-3;\n  e=-6;\n  o=0;\n  s=q;\n  j=-5;\n  w=1;\n  d=i;\n  m=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+e;\n      e = e+o;\n      o = o+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+e;\n      e = e+o;\n      o = o+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'e', 'i', 'j', 'l', 'm', 'n', 'o', 'q', 's', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int q){\n  int l, i, v, e, o, s, j, w, d, m;\n\n  l=(n%29)+18;\n  i=0;\n  v=-3;\n  e=-6;\n  o=0;\n  s=q;\n  j=-5;\n  w=1;\n  d=i;\n  m=n;\n\n  \n  /*@\n\n    loop invariant o == i;\n\n    loop invariant 2*(e + 6) == i*(i - 1);\n\n    loop invariant i*(i - 1)*(i - 2) == 6*(v + 3 + 6*i);\n\n    loop invariant 0 <= i;\n\n    loop invariant (l < 0) || i <= l;\n\n    loop invariant n == \\at(n,Pre) && q == \\at(q,Pre) && b == \\at(b,Pre);\n\n    loop assigns v, e, o, i;\n\n  */\nwhile (i<l) {\n      v = v+e;\n      e = e+o;\n      o = o+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p,int q){\n  int l, i, v, c;\n\n  l=23;\n  i=0;\n  v=p;\n  c=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      c = c-1;\n      c = c+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      c = c-1;\n      c = c+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'i', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p,int q){\n  int l, i, v, c;\n\n  l=23;\n  i=0;\n  v=p;\n  c=a;\n\n  \n  /*@\n\n    loop invariant v == \\at(p,Pre) + i;\n\n    loop invariant c == \\at(a,Pre) + i * \\at(p,Pre) + i*(i-1)/2;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant p == \\at(p,Pre) && a == \\at(a,Pre);\n\n    loop assigns i, v, c;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      c = c-1;\n      c = c+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k){\n  int l, i, v;\n\n  l=18;\n  i=0;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      v = v+1;\n      i = i+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      v = v+1;\n      i = i+2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k){\n  int l, i, v;\n\n  l=18;\n  i=0;\n  v=a;\n\n  \n  /*@\n\n    loop invariant v == a + 2*i;\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant i % 2 == 0;\n\n    loop invariant l == 18;\n\n    loop assigns v, i;\n\n  */\n  while (i<l) {\n      v = v+3;\n      v = v+1;\n      i = i+2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p){\n  int l, i, v;\n\n  l=p;\n  i=l;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v-v;\n      v = v+3;\n      if ((i%4)==0) {\n          v = v-v;\n      }\n      v = v-v;\n      v = v-v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v-v;\n      v = v+3;\n      if ((i%4)==0) {\n          v = v-v;\n      }\n      v = v-v;\n      v = v-v;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p){\n  int l, i, v;\n\n  l=p;\n  i=l;\n  v=l;\n\n  \n  /*@\n\n    loop invariant l == \\at(p, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant (l > 0) ==> (0 <= i);\n\n    loop invariant (i == l) ==> v == l;\n\n    loop invariant (i < l) ==> v == 0;\n\n    loop assigns v, i;\n\n  */\nwhile (i>0) {\n      v = v-v;\n      v = v+3;\n      if ((i%4)==0) {\n          v = v-v;\n      }\n      v = v-v;\n      v = v-v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n){\n  int l, i, v;\n\n  l=61;\n  i=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      if (k<i+1) {\n          v = v+v;\n      }\n      v = v+v;\n      v = v+1;\n      if (v+3<l) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      if (k<i+1) {\n          v = v+v;\n      }\n      v = v+v;\n      v = v+1;\n      if (v+3<l) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n){\n  int l, i, v;\n\n  l=61;\n  i=0;\n  v=k;\n\n  \n  /*@\n\n    loop invariant l == 61;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant i > 0 ==> v == 0;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v-v;\n      if (k<i+1) {\n          v = v+v;\n      }\n      v = v+v;\n      v = v+1;\n      if (v+3<l) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p){\n  int l, i, v, u, x, y, e, t, o;\n\n  l=67;\n  i=0;\n  v=i;\n  u=i;\n  x=i;\n  y=-4;\n  e=m;\n  t=m;\n  o=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      u = u+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      u = u+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'e', 'i', 'l', 'm', 'o', 'p', 't', 'u', 'v', 'x', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p){\n  int l, i, v, u, x, y, e, t, o;\n\n  l=67;\n  i=0;\n  v=i;\n  u=i;\n  x=i;\n  y=-4;\n  e=m;\n  t=m;\n  o=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant 0 <= i;\n    loop invariant l == 67;\n    loop invariant v == 0;\n    loop invariant u == 0;\n    loop assigns v, u, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v*2;\n      u = u+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p){\n  int l, i, v, z, f, j;\n\n  l=77;\n  i=l;\n  v=i;\n  z=-5;\n  f=-4;\n  j=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+z;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+z;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'f', 'i', 'j', 'l', 'n', 'p', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p){\n  int l, i, v, z, f, j;\n\n  l=77;\n  i=l;\n  v=i;\n  z=-5;\n  f=-4;\n  j=a;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= 77;\n\n    loop invariant v <= 77;\n\n    loop invariant (77 - v) % 5 == 0;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+z;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p,int q){\n  int l, i, v;\n\n  l=76;\n  i=0;\n  v=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (i<q+1) {\n          v = v;\n      }\n      else {\n          v = v+i;\n      }\n      v = v+v;\n      v = l+(-4);\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (i<q+1) {\n          v = v;\n      }\n      else {\n          v = v+i;\n      }\n      v = v+v;\n      v = l+(-4);\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p,int q){\n  int l, i, v;\n\n  l=76;\n  i=0;\n  v=1;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant v == 1 || v == l - 4;\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      if (i<q+1) {\n          v = v;\n      }\n      else {\n          v = v+i;\n      }\n      v = v+v;\n      v = l+(-4);\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m){\n  int l, i, v, g, j, x;\n\n  l=a;\n  i=0;\n  v=m;\n  g=-2;\n  j=l;\n  x=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*3+2;\n      g = g*v+2;\n      j = g*g;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*3+2;\n      g = g*v+2;\n      j = g*g;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'g', 'i', 'j', 'l', 'm', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m){\n  int l, i, v, g, j, x;\n\n  l=a;\n  i=0;\n  v=m;\n  g=-2;\n  j=l;\n  x=5;\n\n  \n  /*@\n\n    loop invariant l == \\at(a, Pre);\n\n    loop invariant 0 <= i;\n\n    loop invariant (l >= 0) ==> i <= l;\n\n    loop invariant (i == 0) ==> (v == \\at(m, Pre) && g == -2 && j == l);\n\n    loop invariant (i > 0) ==> j == g * g;\n\n    loop invariant (i > 0) ==> ((v + 1) % 3 == 0);\n\n    loop assigns v, g, j, i;\n\n  */\nwhile (i<l) {\n      v = v*3+2;\n      g = g*v+2;\n      j = g*g;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int p,int q){\n  int l, i, v;\n\n  l=9;\n  i=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%4)==0) {\n          v = v+v;\n      }\n      else {\n          v = q+b;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%4)==0) {\n          v = v+v;\n      }\n      else {\n          v = q+b;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int p,int q){\n  int l, i, v;\n\n  l=9;\n  i=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant (i == 0) ==> (v == -1);\n    loop invariant (b == \\at(b, Pre) && q == \\at(q, Pre));\n    loop assigns i, v;\n  */\nwhile (i<l) {\n      if ((i%4)==0) {\n          v = v+v;\n      }\n      else {\n          v = q+b;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m){\n  int l, i, v, g, t, x;\n\n  l=20;\n  i=0;\n  v=i;\n  g=b;\n  t=i;\n  x=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+2;\n      g = g+v;\n      t = t+g;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+2;\n      g = g+v;\n      t = t+g;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'g', 'i', 'k', 'l', 'm', 't', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m){\n  int l, i, v, g, t, x;\n\n  l=20;\n  i=0;\n  v=i;\n  g=b;\n  t=i;\n  x=l;\n\n  \n  /*@\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant v == 2*i;\n\n    loop invariant g == b + i*(i+1);\n\n    loop invariant t == i*b + i*(i+1)*(i+2)/3;\n\n    loop assigns v, g, t, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+2;\n      g = g+v;\n      t = t+g;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int p,int q){\n  int l, i, v, m;\n\n  l=48;\n  i=l;\n  v=l;\n  m=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+m+m;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+m+m;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int p,int q){\n  int l, i, v, m;\n\n  l=48;\n  i=l;\n  v=l;\n  m=p;\n\n  \n  /*@\n\n    loop invariant v == l + 2*m*(l - i);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant m == \\at(p, Pre);\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v+m+m;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int q){\n  int l, i, v, c, d;\n\n  l=62;\n  i=0;\n  v=a;\n  c=q;\n  d=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      c = c+d;\n      d = d+v;\n      v = v+d;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      c = c+d;\n      d = d+v;\n      v = v+d;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'd', 'i', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int q){\n  int l, i, v, c, d;\n\n  l=62;\n  i=0;\n  v=a;\n  c=q;\n  d=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant c + d - v == q + m - a;\n    loop invariant a == \\at(a, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns c, d, v, i;\n  */\n  while (i<l) {\n      c = c+d;\n      d = d+v;\n      v = v+d;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int p){\n  int l, i, v, r, z, f;\n\n  l=60;\n  i=l;\n  v=b;\n  r=b;\n  z=1;\n  f=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+r;\n      r = r+z;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+r;\n      r = r+z;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'f', 'i', 'l', 'p', 'r', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int p){\n  int l, i, v, r, z, f;\n\n  l=60;\n  i=l;\n  v=b;\n  r=b;\n  z=1;\n  f=0;\n\n  \n  /*@\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant 2*v == r*r - b*b - r + 3*b;\n\n    loop invariant r >= b;\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n\n    loop assigns v, r, i;\n\n  */\n  while (i>0) {\n      v = v+r;\n      r = r+z;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int q){\n  int l, i, v;\n\n  l=(m%6)+13;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+v;\n      v = v+v;\n      v = v+1;\n      v = v+v;\n      v = v-v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+v;\n      v = v+v;\n      v = v+1;\n      v = v+v;\n      v = v-v;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int q){\n  int l, i, v;\n\n  l=(m%6)+13;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0 && i <= l;\n    loop invariant (i == l) ==> (v == l);\n    loop invariant (i < l) ==> (v == 0);\n    loop assigns i, v;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+v;\n      v = v+v;\n      v = v+1;\n      v = v+v;\n      v = v-v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m){\n  int l, i, v;\n\n  l=28;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (i+3<=b+l) {\n          v = v+6;\n      }\n      v = v+i;\n      v = v+1;\n      v = b+a;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (i+3<=b+l) {\n          v = v+6;\n      }\n      v = v+i;\n      v = v+1;\n      v = b+a;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m){\n  int l, i, v;\n\n  l=28;\n  i=0;\n  v=m;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant (i==0 && v==\\at(m,Pre)) || (i>0 && v == b + a + 1);\n\n    loop invariant a == \\at(a,Pre) && b == \\at(b,Pre) && m == \\at(m,Pre);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      if (i+3<=b+l) {\n          v = v+6;\n      }\n      v = v+i;\n      v = v+1;\n      v = b+a;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n){\n  int l, i, v;\n\n  l=(n%11)+10;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      v = b;\n      if ((i%5)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+i;\n      }\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      v = b;\n      if ((i%5)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+i;\n      }\n      v = v+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n){\n  int l, i, v;\n\n  l=(n%11)+10;\n  i=0;\n  v=i;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant (i == 0) ==> (v == 0);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v-v;\n      v = b;\n      if ((i%5)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+i;\n      }\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p){\n  int l, i, v, y, e;\n\n  l=14;\n  i=0;\n  v=m;\n  y=m;\n  e=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+y+e;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+y+e;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'e', 'i', 'l', 'm', 'p', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p){\n  int l, i, v, y, e;\n\n  l=14;\n  i=0;\n  v=m;\n  y=m;\n  e=p;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v == m + i*(m + p);\n\n    loop invariant y == m;\n\n    loop invariant e == p;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+y+e;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int q){\n  int l, i, v, f, d, b;\n\n  l=18;\n  i=0;\n  v=8;\n  f=n;\n  d=i;\n  b=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      b = b*b+v;\n      v = v%5;\n      d = b+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      b = b*b+v;\n      v = v%5;\n      d = b+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'f', 'i', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int q){\n  int l, i, v, f, d, b;\n\n  l=18;\n  i=0;\n  v=8;\n  f=n;\n  d=i;\n  b=n;\n\n  \n  /*@\n\n    loop invariant l == 18;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant (i == 0 ==> v == 8) && (i > 0 ==> 0 <= v && v <= 4);\n\n    loop invariant i > 0 ==> d == b + (i - 1);\n\n    loop invariant m == \\at(m,Pre) && n == \\at(n,Pre) && q == \\at(q,Pre);\n\n    loop assigns b, v, d, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      b = b*b+v;\n      v = v%5;\n      d = b+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v;\n\n  l=38;\n  i=0;\n  v=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%2)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+4;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%2)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+4;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v;\n\n  l=38;\n  i=0;\n  v=-4;\n\n  \n  /*@\n\n    loop invariant (i == 0) ==> (v == -4);\n\n    loop invariant i <= l;\n\n    loop invariant 0 <= i;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      if ((i%2)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+4;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p){\n  int l, i, v, c;\n\n  l=m+14;\n  i=0;\n  v=a;\n  c=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+c+c;\n      v = v+1;\n      c = c+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+c+c;\n      v = v+1;\n      c = c+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p){\n  int l, i, v, c;\n\n  l=m+14;\n  i=0;\n  v=a;\n  c=l;\n\n  \n  /*@\n\n    loop invariant i >= 0 && (l <= 0 || i <= l);\n\n    loop invariant c == l + i;\n\n    loop invariant v == \\at(a,Pre) + i*(2*l + i);\n\n    loop invariant l == \\at(m,Pre) + 14;\n\n    loop invariant a == \\at(a,Pre) && m == \\at(m,Pre) && p == \\at(p,Pre);\n\n    loop assigns v, c, i;\n\n  */\nwhile (i<l) {\n      v = v+c+c;\n      v = v+1;\n      c = c+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v, d;\n\n  l=9;\n  i=0;\n  v=k;\n  d=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+d+d;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+d+d;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'd', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v, d;\n\n  l=9;\n  i=0;\n  v=k;\n  d=m;\n\n  \n  /*@\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant v == k + 2*d*i;\n\n    loop invariant d == m;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+d+d;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, m, a, w;\n\n  l=(b%16)+18;\n  i=0;\n  v=b;\n  m=l;\n  a=l;\n  w=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      m = m-1;\n      v = v+5;\n      v = 6;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      m = m-1;\n      v = v+5;\n      v = 6;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'n', 'p', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, m, a, w;\n\n  l=(b%16)+18;\n  i=0;\n  v=b;\n  m=l;\n  a=l;\n  w=-2;\n\n  /*>> LOOP INVARIANT TO FILL <<*/\n    /*@\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant m == l - i;\n    loop invariant (i > 0) ==> (v == 6);\n    loop invariant l == (b % 16) + 18;\n    loop assigns v, m, i;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      v = v+1;\n      m = m-1;\n      v = v+5;\n      v = 6;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int q){\n  int l, i, v, w;\n\n  l=q;\n  i=0;\n  v=n;\n  w=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      w = w+w;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      w = w+w;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'q', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int q){\n  int l, i, v, w;\n\n  l=q;\n  i=0;\n  v=n;\n  w=i;\n\n  \n  /*@\n\n    loop invariant w == 0;\n\n    loop invariant l == \\at(q,Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l || l <= 0;\n\n    loop assigns i, w;\n\n  */\nwhile (i<l) {\n      w = w+w;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n){\n  int l, i, v, t, k, q, o, y, s, w;\n\n  l=64;\n  i=l;\n  v=n;\n  t=n;\n  k=i;\n  q=4;\n  o=l;\n  y=n;\n  s=-4;\n  w=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v!=0&&t!=0) {\n      if (v>t) {\n          v = v-t;\n      }\n      else {\n          t = t-v;\n      }\n      v = v*2+1;\n      t = t*v+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (v!=0&&t!=0) {\n      if (v>t) {\n          v = v-t;\n      }\n      else {\n          t = t-v;\n      }\n      v = v*2+1;\n      t = t*v+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'n', 'o', 'q', 's', 't', 'v', 'w', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n){\n  int l, i, v, t, k, q, o, y, s, w;\n\n  l=64;\n  i=l;\n  v=n;\n  t=n;\n  k=i;\n  q=4;\n  o=l;\n  y=n;\n  s=-4;\n  w=a;\n\n  \n  /*@\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant \\at(n,Pre) > 0 ==> v > 0;\n\n    loop invariant \\at(n,Pre) > 0 ==> t > 0;\n\n    loop invariant \\at(n,Pre) > 0 ==> v != 0 && t != 0;\n\n    loop assigns v, t;\n\n  */\n  while (v!=0&&t!=0) {\n      if (v>t) {\n          v = v-t;\n      }\n      else {\n          t = t-v;\n      }\n      v = v*2+1;\n      t = t*v+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v, e, h, t, j, w;\n\n  l=37;\n  i=l;\n  v=m;\n  e=l;\n  h=-6;\n  t=m;\n  j=0;\n  w=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      e = e+v;\n      e = e+3;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      e = e+v;\n      e = e+3;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'e', 'h', 'i', 'j', 'k', 'l', 'm', 't', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v, e, h, t, j, w;\n\n  l=37;\n  i=l;\n  v=m;\n  e=l;\n  h=-6;\n  t=m;\n  j=0;\n  w=i;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v >= m;\n\n    loop invariant 2*(e - l) == (v - m) * (v + m + 7);\n\n    loop assigns v, e, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+1;\n      e = e+v;\n      e = e+3;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p){\n  int l, i, v, f;\n\n  l=62;\n  i=0;\n  v=i;\n  f=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      f = f+f;\n      f = f+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      f = f+f;\n      f = f+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'f', 'i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p){\n  int l, i, v, f;\n\n  l=62;\n  i=0;\n  v=i;\n  f=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v == 0;\n    loop invariant l == 62;\n    loop invariant f % 2 == 0;\n    loop invariant f >= 0;\n    loop assigns i, f;\n  */\n  while (i<l) {\n      f = f+f;\n      f = f+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n){\n  int l, i, v, s, u, p, k;\n\n  l=38;\n  i=l;\n  v=m;\n  s=8;\n  u=i;\n  p=l;\n  k=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+3;\n      u = u+4;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+3;\n      u = u+4;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'n', 'p', 's', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n){\n  int l, i, v, s, u, p, k;\n\n  l=38;\n  i=l;\n  v=m;\n  s=8;\n  u=i;\n  p=l;\n  k=l;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v == m + 3*(l - i);\n\n    loop invariant u == 5*l - 4*i;\n\n    loop invariant m == \\at(m, Pre);\n\n    loop assigns v, u, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+3;\n      u = u+4;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int q){\n  int l, i, v, j;\n\n  l=22;\n  i=0;\n  v=0;\n  j=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+j+j;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+j+j;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'j', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int q){\n  int l, i, v, j;\n\n  l=22;\n  i=0;\n  v=0;\n  j=b;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant v == 2*j*i;\n\n    loop invariant j == b;\n\n    loop invariant l == 22;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+j+j;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n){\n  int l, i, v, y, z, t, k, w, o;\n\n  l=73;\n  i=l;\n  v=0;\n  y=a;\n  z=1;\n  t=i;\n  k=n;\n  w=a;\n  o=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      y = y+v;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      y = y+v;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'n', 'o', 't', 'v', 'w', 'y', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n){\n  int l, i, v, y, z, t, k, w, o;\n\n  l=73;\n  i=l;\n  v=0;\n  y=a;\n  z=1;\n  t=i;\n  k=n;\n  w=a;\n  o=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 0;\n    loop invariant y == a;\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant a == \\at(a, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop assigns v, y, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v*2;\n      y = y+v;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p){\n  int l, i, v;\n\n  l=75;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v-v;\n      if (i+5<=n+l) {\n          v = v-v;\n      }\n      else {\n          v = v+v;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v-v;\n      if (i+5<=n+l) {\n          v = v-v;\n      }\n      else {\n          v = v+v;\n      }\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p){\n  int l, i, v;\n\n  l=75;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 75;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v <= i;\n    loop invariant v >= 0;\n    loop invariant (i < l) ==> (v == 0);\n    loop assigns i, v;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v-v;\n      if (i+5<=n+l) {\n          v = v-v;\n      }\n      else {\n          v = v+v;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v, y, e, t, n, w, g;\n\n  l=66;\n  i=0;\n  v=-6;\n  y=k;\n  e=k;\n  t=m;\n  n=5;\n  w=-2;\n  g=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*4;\n      y = y/4;\n      y = y*2;\n      i = i+5;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*4;\n      y = y/4;\n      y = y*2;\n      i = i+5;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'e', 'g', 'i', 'k', 'l', 'm', 'n', 't', 'v', 'w', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v, y, e, t, n, w, g;\n\n  l=66;\n  i=0;\n  v=-6;\n  y=k;\n  e=k;\n  t=m;\n  n=5;\n  w=-2;\n  g=m;\n\n  \n  /*@\n\n    loop invariant i % 5 == 0;\n\n    loop invariant 0 <= i && i <= l + 4;\n\n    loop invariant (i == 0) ==> (v == -6 && y == k);\n\n    loop invariant (i == 0 || v % 4 == 0);\n\n    loop invariant k == \\at(k,Pre) && m == \\at(m,Pre) && a == \\at(a,Pre);\n\n    loop assigns v, y, i;\n\n    loop variant l + 4 - i;\n\n  */\nwhile (i<l) {\n      v = v*4;\n      y = y/4;\n      y = y*2;\n      i = i+5;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m){\n  int l, i, v, u, o;\n\n  l=68;\n  i=0;\n  v=i;\n  u=-5;\n  o=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      u = u+o;\n      o = o+v;\n      o = o+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      u = u+o;\n      o = o+v;\n      o = o+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'o', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m){\n  int l, i, v, u, o;\n\n  l=68;\n  i=0;\n  v=i;\n  u=-5;\n  o=i;\n\n  \n  /*@\n\n    loop invariant l == 68;\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant u == -5;\n\n    loop invariant o == 0;\n\n    loop invariant v == 0;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop assigns u, o, i;\n\n  */\n  while (i<l) {\n      u = u+o;\n      o = o+v;\n      o = o+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int q){\n  int l, i, v, d, r, a;\n\n  l=54;\n  i=l;\n  v=n;\n  d=q;\n  r=6;\n  a=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'd', 'i', 'l', 'm', 'n', 'q', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int q){\n  int l, i, v, d, r, a;\n\n  l=54;\n  i=l;\n  v=n;\n  d=q;\n  r=6;\n  a=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant l == 54;\n    loop invariant (n >= 0) ==> (v >= 0);\n    loop invariant (n <= 0) ==> (v <= 0);\n    loop assigns v, i;\n  */\n  while (i>0) {\n      v = v*2;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n){\n  int l, i, v, u, x, q, j, r, m, f;\n\n  l=(b%14)+12;\n  i=0;\n  v=2;\n  u=-2;\n  x=k;\n  q=i;\n  j=-5;\n  r=-1;\n  m=4;\n  f=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      u = u+v;\n      x = x%8;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      u = u+v;\n      x = x%8;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'f', 'i', 'j', 'k', 'l', 'm', 'n', 'q', 'r', 'u', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n){\n  int l, i, v, u, x, q, j, r, m, f;\n\n  l=(b%14)+12;\n  i=0;\n  v=2;\n  u=-2;\n  x=k;\n  q=i;\n  j=-5;\n  r=-1;\n  m=4;\n  f=n;\n\n  \n  /*@\n\n    loop invariant u == 2*v - 6;\n\n    loop invariant x % 8 == \\at(k, Pre) % 8;\n\n    loop invariant v >= 2;\n\n    loop invariant i >= 0;\n\n    loop invariant i == 0 || i <= l;\n\n    loop assigns v, u, x, i;\n\n  */\nwhile (i<l) {\n      v = v*2;\n      u = u+v;\n      x = x%8;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p,int q){\n  int l, i, v, h;\n\n  l=72;\n  i=0;\n  v=m;\n  h=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+h+h;\n      v = v+1;\n      i = i+4;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+h+h;\n      v = v+1;\n      i = i+4;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['h', 'i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p,int q){\n  int l, i, v, h;\n\n  l=72;\n  i=0;\n  v=m;\n  h=-5;\n\n  \n  /*@\n\n    loop invariant l == 72;\n\n    loop invariant h == -5;\n\n    loop invariant i % 4 == 0;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant v == m + (i/4) * (2*h + 1);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+h+h;\n      v = v+1;\n      i = i+4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int q){\n  int l, i, v, p;\n\n  l=71;\n  i=0;\n  v=2;\n  p=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      p = p+v;\n      v = v+1;\n      p = p+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      p = p+v;\n      v = v+1;\n      p = p+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int q){\n  int l, i, v, p;\n\n  l=71;\n  i=0;\n  v=2;\n  p=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant 0 <= i && i <= l;\n    loop invariant v == 2 + 2*i;\n    loop invariant p == 2*i*i + 5*i;\n    loop assigns v, p, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      p = p+v;\n      v = v+1;\n      p = p+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int q){\n  int l, i, v, g, d, w, h, k, c;\n\n  l=m;\n  i=0;\n  v=i;\n  g=i;\n  d=-1;\n  w=n;\n  h=n;\n  k=-1;\n  c=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*3+3;\n      g = g*v+3;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*3+3;\n      g = g*v+3;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'd', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'q', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int q){\n  int l, i, v, g, d, w, h, k, c;\n\n  l=m;\n  i=0;\n  v=i;\n  g=i;\n  d=-1;\n  w=n;\n  h=n;\n  k=-1;\n  c=q;\n\n  \n  /*@\n\n    loop invariant l == \\at(m,Pre);\n\n    loop invariant 0 <= i;\n\n    loop invariant l < 0 || i <= l;\n\n    loop invariant v >= 0;\n\n    loop invariant g >= 0;\n\n    loop invariant v % 3 == 0 && g % 3 == 0;\n\n    loop assigns v, g, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v*3+3;\n      g = g*v+3;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p,int q){\n  int l, i, v, t, b, d;\n\n  l=45;\n  i=0;\n  v=a;\n  t=-6;\n  b=i;\n  d=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      d = v+t+b;\n      v = v+1;\n      d = t-d;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      d = v+t+b;\n      v = v+1;\n      d = t-d;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'd', 'i', 'l', 'p', 'q', 't', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p,int q){\n  int l, i, v, t, b, d;\n\n  l=45;\n  i=0;\n  v=a;\n  t=-6;\n  b=i;\n  d=a;\n\n  \n  /*@\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == 0;\n\n    loop invariant t == -6;\n\n    loop invariant v == a + i;\n\n\n    loop invariant (i > 0) ==> (d == -a - (i - 1));\n\n    loop invariant i <= l;\n\n    loop assigns i, v, d;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      d = v+t+b;\n      v = v+1;\n      d = t-d;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p){\n  int l, i, v, t;\n\n  l=63;\n  i=0;\n  v=-4;\n  t=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      t = t+1;\n      v = v+4;\n      t = t+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      t = t+1;\n      v = v+4;\n      t = t+3;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'p', 't', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p){\n  int l, i, v, t;\n\n  l=63;\n  i=0;\n  v=-4;\n  t=m;\n\n  /* >>> LOOP INVARIANTS TO FILL <<< */\n    /*@\n    loop invariant 4*v - 5*t == -16 - 5*m;\n    loop invariant l == 63;\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant m == \\at(m, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop assigns v, t;\n  */\n  while (i<l) {\n      v = v+1;\n      t = t+1;\n      v = v+4;\n      t = t+3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n){\n  int l, i, v, o, j, e, y, x;\n\n  l=49;\n  i=0;\n  v=k;\n  o=l;\n  j=l;\n  e=n;\n  y=6;\n  x=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      j = j+1;\n      e = e+1;\n      x = x+y;\n      if (i+5<=n+l) {\n          j = j+i;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      j = j+1;\n      e = e+1;\n      x = x+y;\n      if (i+5<=n+l) {\n          j = j+i;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'e', 'i', 'j', 'k', 'l', 'n', 'o', 'v', 'x', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n){\n  int l, i, v, o, j, e, y, x;\n\n  l=49;\n  i=0;\n  v=k;\n  o=l;\n  j=l;\n  e=n;\n  y=6;\n  x=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant v == k + i;\n    loop invariant e == n + i;\n    loop invariant x == a + i*y;\n    loop invariant j >= l + i;\n    loop assigns v, j, e, x, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      j = j+1;\n      e = e+1;\n      x = x+y;\n      if (i+5<=n+l) {\n          j = j+i;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int q){\n  int l, i, v, z, j, u, d;\n\n  l=(m%7)+13;\n  i=l;\n  v=-2;\n  z=a;\n  j=i;\n  u=i;\n  d=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v!=0&&z!=0) {\n      if (v>z) {\n          v = v-z;\n      }\n      else {\n          z = z-v;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (v!=0&&z!=0) {\n      if (v>z) {\n          v = v-z;\n      }\n      else {\n          z = z-v;\n      }\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'd', 'i', 'j', 'l', 'm', 'q', 'u', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int q){\n  int l, i, v, z, j, u, d;\n\n  l=(m%7)+13;\n  i=l;\n  v=-2;\n  z=a;\n  j=i;\n  u=i;\n  d=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v != 0;\n\n    loop invariant (v > z) ==> (v - z > 0);\n    loop invariant (z > v) ==> (z - v > 0);\n    loop assigns v, z;\n  */\nwhile (v!=0&&z!=0) {\n      if (v>z) {\n          v = v-z;\n      }\n      else {\n          z = z-v;\n      }\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p){\n  int l, i, v, c, b, e, s;\n\n  l=38;\n  i=0;\n  v=a;\n  c=n;\n  b=p;\n  e=p;\n  s=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      e = v+c+b;\n      v = v+1;\n      s = s+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      e = v+c+b;\n      v = v+1;\n      s = s+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'e', 'i', 'l', 'n', 'p', 's', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p){\n  int l, i, v, c, b, e, s;\n\n  l=38;\n  i=0;\n  v=a;\n  c=n;\n  b=p;\n  e=p;\n  s=-4;\n\n  \n  /*@\n\n    loop invariant v == a + i;\n\n    loop invariant s == -4 + i*(i - 1)/2;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant b == \\at(p, Pre) && c == \\at(n, Pre);\n\n    loop invariant l == 38;\n\n    loop invariant i == 0 ==> e == b;\n\n    loop invariant i > 0 ==> e == v - 1 + c + b;\n\n    loop assigns e, v, s, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      e = v+c+b;\n      v = v+1;\n      s = s+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m){\n  int l, i, v, c, d, x;\n\n  l=68;\n  i=0;\n  v=i;\n  c=-5;\n  d=-3;\n  x=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      c = c+v;\n      d = d%6;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      c = c+v;\n      d = d%6;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'd', 'i', 'k', 'l', 'm', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m){\n  int l, i, v, c, d, x;\n\n  l=68;\n  i=0;\n  v=i;\n  c=-5;\n  d=-3;\n  x=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant l == 68;\n    loop invariant v == 0;\n    loop invariant c == -5;\n    loop invariant d == -3;\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop assigns v, c, d, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v*2;\n      c = c+v;\n      d = d%6;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n){\n  int l, i, v;\n\n  l=16;\n  i=l;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+v;\n      v = v-v;\n      v = v-v;\n      v = v-v;\n      v = v+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+v;\n      v = v-v;\n      v = v-v;\n      v = v-v;\n      v = v+1;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n){\n  int l, i, v;\n\n  l=16;\n  i=l;\n  v=l;\n\n  \n  /*@\n\n    loop invariant (v == 1) || (i == l && v == l);\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant l == 16;\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v+v;\n      v = v-v;\n      v = v-v;\n      v = v-v;\n      v = v+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p){\n  int l, i, v, e, c, k;\n\n  l=14;\n  i=0;\n  v=6;\n  e=i;\n  c=6;\n  k=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      e = e+v;\n      k = k+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      e = e+v;\n      k = k+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'e', 'i', 'k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p){\n  int l, i, v, e, c, k;\n\n  l=14;\n  i=0;\n  v=6;\n  e=i;\n  c=6;\n  k=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v == i + 6;\n    loop invariant e == 6*i + i*(i+1)/2;\n    loop invariant k == p + i*(i-1)/2;\n    loop assigns v, e, k, i;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      v = v+1;\n      e = e+v;\n      k = k+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int q){\n  int l, i, v, a, g, f, b;\n\n  l=36;\n  i=l;\n  v=k;\n  a=q;\n  g=-5;\n  f=i;\n  b=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*3+4;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*3+4;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'f', 'g', 'i', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int q){\n  int l, i, v, a, g, f, b;\n\n  l=36;\n  i=l;\n  v=k;\n  a=q;\n  g=-5;\n  f=i;\n  b=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant i <= l;\n   loop invariant i >= 0;\n   loop invariant ((v - k) % 2 == 0);\n   loop invariant k == \\at(k,Pre);\n   loop invariant n == \\at(n,Pre);\n   loop invariant q == \\at(q,Pre);\n   loop assigns i, v;\n   loop variant i;\n */\nwhile (i>0) {\n      v = v*3+4;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, o;\n\n  l=51;\n  i=0;\n  v=i;\n  o=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+2;\n      o = o+v;\n      o = o+o;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+2;\n      o = o+v;\n      o = o+o;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'o', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, o;\n\n  l=51;\n  i=0;\n  v=i;\n  o=p;\n\n  \n  /*@\n\n    loop invariant v == 2 * i;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant l == 51;\n\n    loop invariant (i == 0 ==> o == \\at(p,Pre));\n\n    loop invariant (i >= 1 ==> o % 2 == 0);\n\n    loop assigns i, v, o;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+2;\n      o = o+v;\n      o = o+o;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int q){\n  int l, i, v;\n\n  l=28;\n  i=0;\n  v=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int q){\n  int l, i, v;\n\n  l=28;\n  i=0;\n  v=-8;\n\n  \n  /*@\n\n    loop invariant v == -8 + 2*i;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant l == 28;\n\n    loop invariant m == \\at(m,Pre) && n == \\at(n,Pre) && q == \\at(q,Pre);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int q){\n  int l, i, v;\n\n  l=66;\n  i=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      v = v+v;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      v = v+v;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int q){\n  int l, i, v;\n\n  l=66;\n  i=0;\n  v=q;\n\n  \n  /*@\n\n    loop invariant l == 66;\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant (i == 0) ==> (v == q);\n\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+i;\n      v = v+v;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v, o, c, z, d;\n\n  l=17;\n  i=l;\n  v=4;\n  o=a;\n  c=k;\n  z=i;\n  d=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      o = o+v;\n      z = z+4;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      o = o+v;\n      z = z+4;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'd', 'i', 'k', 'l', 'm', 'o', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v, o, c, z, d;\n\n  l=17;\n  i=l;\n  v=4;\n  o=a;\n  c=k;\n  z=i;\n  d=k;\n\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v == l - i + 4;\n    loop invariant o == a + 4*(l - i) + ((l - i)*(l - i + 1))/2;\n    loop invariant z == 5*l - 4*i;\n    loop assigns v, o, z, i;\n    loop variant i;\n  */\nwhile (i>0) {\n      v = v+1;\n      o = o+v;\n      z = z+4;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p){\n  int l, i, v, z;\n\n  l=64;\n  i=0;\n  v=-4;\n  z=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      z = z+v;\n      z = z+z;\n      v = v+6;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      z = z+v;\n      z = z+z;\n      v = v+6;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'p', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p){\n  int l, i, v, z;\n\n  l=64;\n  i=0;\n  v=-4;\n  z=n;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant v == -4 + 9*i;\n\n    loop invariant (i == 0) ==> (z == n);\n\n    loop invariant (i > 0) ==> (z % 2 == 0);\n\n    loop assigns i, v, z;\n\n  */\n  while (i<l) {\n      v = v+3;\n      z = z+v;\n      z = z+z;\n      v = v+6;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int p){\n  int l, i, v, c, x;\n\n  l=p;\n  i=0;\n  v=l;\n  c=3;\n  x=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+c+x;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+c+x;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'i', 'l', 'p', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int p){\n  int l, i, v, c, x;\n\n  l=p;\n  i=0;\n  v=l;\n  c=3;\n  x=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == l + i*(c + x + 1);\n    loop invariant (l >= 0) ==> (0 <= i && i <= l);\n    loop invariant x == l;\n    loop invariant l == \\at(p, Pre);\n    loop invariant c == 3;\n    loop assigns v, i;\n  */\n  while (i<l) {\n      v = v+c+x;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int p,int q){\n  int l, i, v, a, n, z;\n\n  l=42;\n  i=0;\n  v=l;\n  a=4;\n  n=0;\n  z=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      a = a+v;\n      n = n+z;\n      n = n+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      a = a+v;\n      n = n+z;\n      n = n+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'n', 'p', 'q', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int p,int q){\n  int l, i, v, a, n, z;\n\n  l=42;\n  i=0;\n  v=l;\n  a=4;\n  n=0;\n  z=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant 0 <= i;\n    loop invariant v == l + i;\n    loop invariant a == 4 + l*i + i*(i+1)/2;\n    loop invariant n == i*(p + 1);\n    loop assigns v, a, n, i;\n  */\n  while (i<l) {\n      v = v+1;\n      a = a+v;\n      n = n+z;\n      n = n+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p,int q){\n  int l, i, v, a, z, r;\n\n  l=(p%39)+16;\n  i=1;\n  v=q;\n  a=q;\n  z=q;\n  r=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*4;\n      a = a/4;\n      i = i*2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*4;\n      a = a/4;\n      i = i*2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'q', 'r', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p,int q){\n  int l, i, v, a, z, r;\n\n  l=(p%39)+16;\n  i=1;\n  v=q;\n  a=q;\n  z=q;\n  r=i;\n\n  \n  /*@\n\n    loop invariant i > 0;\n\n    loop invariant v == \\at(q, Pre) * i * i;\n\n    loop invariant ( \\at(q, Pre) >= 0 ==> a * i * i <= \\at(q, Pre) )\n                   && ( \\at(q, Pre) <= 0 ==> a * i * i >= \\at(q, Pre) );\n\n    loop invariant l == (\\at(p, Pre) % 39) + 16;\n\n    loop invariant p == \\at(p, Pre) && q == \\at(q, Pre);\n\n    loop assigns v, a, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v*4;\n      a = a/4;\n      i = i*2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p){\n  int l, i, v;\n\n  l=50;\n  i=0;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+5;\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+5;\n      v = v-v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p){\n  int l, i, v;\n\n  l=50;\n  i=0;\n  v=b;\n\n  \n  /*@\n\n    loop invariant (i == 0 ==> v == \\at(b,Pre)) && (i > 0 ==> v == 0);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant b == \\at(b,Pre);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant p == \\at(p,Pre);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+5;\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int q){\n  int l, i, v, o, j, z, t;\n\n  l=77;\n  i=0;\n  v=i;\n  o=l;\n  j=m;\n  z=l;\n  t=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+4;\n      j = j+1;\n      if ((i%7)==0) {\n          v = 4;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+4;\n      j = j+1;\n      if ((i%7)==0) {\n          v = 4;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'j', 'l', 'm', 'o', 'q', 't', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int q){\n  int l, i, v, o, j, z, t;\n\n  l=77;\n  i=0;\n  v=i;\n  o=l;\n  j=m;\n  z=l;\n  t=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i <= l;\n    loop invariant j == m + i;\n    loop invariant v <= 4*i;\n    loop invariant (i > 0) ==> (v >= 4);\n    loop invariant l == 77;\n    loop assigns v, j, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+4;\n      j = j+1;\n      if ((i%7)==0) {\n          v = 4;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int q){\n  int l, i, v, b, f, w, c, g;\n\n  l=40;\n  i=l;\n  v=k;\n  b=q;\n  f=-3;\n  w=l;\n  c=l;\n  g=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+4;\n      f = f+2;\n      v = g-v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+4;\n      f = f+2;\n      v = g-v;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'f', 'g', 'i', 'k', 'l', 'n', 'q', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int q){\n  int l, i, v, b, f, w, c, g;\n\n  l=40;\n  i=l;\n  v=k;\n  b=q;\n  f=-3;\n  w=l;\n  c=l;\n  g=0;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant f == -3 + 2*(l - i);\n\n    loop invariant ((l - i) % 2 == 0) ==> v == \\at(k,Pre);\n\n    loop invariant ((l - i) % 2 != 0) ==> v == -\\at(k,Pre) - 4;\n\n    loop invariant k == \\at(k,Pre);\n\n    loop assigns v, f, i;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v+4;\n      f = f+2;\n      v = g-v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n){\n  int l, i, v;\n\n  l=58;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+2<l) {\n          v = v+i;\n      }\n      v = v-v;\n      v = v+1;\n      v = v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+2<l) {\n          v = v+i;\n      }\n      v = v-v;\n      v = v+1;\n      v = v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n){\n  int l, i, v;\n\n  l=58;\n  i=0;\n  v=l;\n\n  \n  /*@\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant (i == 0 ==> v == l) && (i > 0 ==> v == 1);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      if (v+2<l) {\n          v = v+i;\n      }\n      v = v-v;\n      v = v+1;\n      v = v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int p){\n  int l, i, v;\n\n  l=56;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (i+6<=m+l) {\n          v = v-v;\n      }\n      v = v+i;\n      v = v-v;\n      v = v+6;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (i+6<=m+l) {\n          v = v-v;\n      }\n      v = v+i;\n      v = v-v;\n      v = v+6;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int p){\n  int l, i, v;\n\n  l=56;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant ( (i == 0) ==> (v == m) ) &&\n                 ( (i > 0) ==> (v == 6) ) &&\n                 (0 <= i && i <= l);\n   loop invariant k == \\at(k, Pre);\n   loop invariant m == \\at(m, Pre);\n   loop invariant p == \\at(p, Pre);\n   loop assigns i, v;\n   loop variant l - i;\n */\nwhile (i<l) {\n      if (i+6<=m+l) {\n          v = v-v;\n      }\n      v = v+i;\n      v = v-v;\n      v = v+6;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int p){\n  int l, i, v, r, z, e, d;\n\n  l=(p%10)+9;\n  i=0;\n  v=-3;\n  r=-5;\n  z=i;\n  e=l;\n  d=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      e = e*e+v;\n      v = v%5;\n      e = d*d;\n      i = i+3;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      e = e*e+v;\n      v = v%5;\n      e = d*d;\n      i = i+3;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'e', 'i', 'k', 'l', 'm', 'p', 'r', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int p){\n  int l, i, v, r, z, e, d;\n\n  l=(p%10)+9;\n  i=0;\n  v=-3;\n  r=-5;\n  z=i;\n  e=l;\n  d=i;\n\n  \n  /*@\n\n    loop invariant i % 3 == 0;\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l + 2;\n\n    loop invariant v == -3;\n\n    loop invariant d == 0;\n\n    loop invariant i == 0 || e == d*d;\n\n    loop assigns e, v, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      e = e*e+v;\n      v = v%5;\n      e = d*d;\n      i = i+3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p){\n  int l, i, v, x, t, y, s;\n\n  l=(m%6)+9;\n  i=l;\n  v=n;\n  x=i;\n  t=n;\n  y=-5;\n  s=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+4;\n      t = t+1;\n      t = t+1;\n      y = s-y;\n      if (v<v+1) {\n          x = x+1;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+4;\n      t = t+1;\n      t = t+1;\n      y = s-y;\n      if (v<v+1) {\n          x = x+1;\n      }\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'p', 's', 't', 'v', 'x', 'y']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p){\n  int l, i, v, x, t, y, s;\n\n  l=(m%6)+9;\n  i=l;\n  v=n;\n  x=i;\n  t=n;\n  y=-5;\n  s=p;\n\n  \n  /*@\n\n    loop invariant l == (m%6) + 9;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant t + 2 * i == n + 2 * l;\n\n    loop invariant v - 4 * (l - i) == n;\n\n    loop invariant x + i == 2 * l;\n\n    loop invariant ((l - i) % 2 == 0 ==> y == -5) && ((l - i) % 2 != 0 ==> y == s + 5);\n\n    loop assigns v, t, y, x, i;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v+4;\n      t = t+1;\n      t = t+1;\n      y = s-y;\n      if (v<v+1) {\n          x = x+1;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m){\n  int l, i, v, a, z;\n\n  l=57;\n  i=0;\n  v=-5;\n  a=k;\n  z=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+a+z;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+a+z;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'm', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m){\n  int l, i, v, a, z;\n\n  l=57;\n  i=0;\n  v=-5;\n  a=k;\n  z=l;\n\n  \n  /*@\n\n    loop invariant v == -5 + i*(a + z);\n\n    loop invariant a == \\at(k, Pre);\n\n    loop invariant z == l;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+a+z;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p,int q){\n  int l, i, v, m, o;\n\n  l=27;\n  i=l;\n  v=-4;\n  m=i;\n  o=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+m+o;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+m+o;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'o', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p,int q){\n  int l, i, v, m, o;\n\n  l=27;\n  i=l;\n  v=-4;\n  m=i;\n  o=a;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v == -4 + (l - i) * (m + o);\n\n    loop invariant o == a;\n\n    loop invariant m == l;\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+m+o;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m){\n  int l, i, v;\n\n  l=27;\n  i=l;\n  v=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = 8;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = 8;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m){\n  int l, i, v;\n\n  l=27;\n  i=l;\n  v=-4;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant v == -4 || v == 8;\n\n    loop invariant l == 27;\n\n    loop assigns v, i;\n\n  */\n  while (i>0) {\n      v = 8;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int q){\n  int l, i, v, d, n, r;\n\n  l=75;\n  i=l;\n  v=q;\n  d=i;\n  n=m;\n  r=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*3;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*3;\n      i = i/2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'i', 'l', 'm', 'n', 'q', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int q){\n  int l, i, v, d, n, r;\n\n  l=75;\n  i=l;\n  v=q;\n  d=i;\n  n=m;\n  r=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant i <= l;\n   loop invariant i >= 0;\n   loop invariant v * q >= 0;\n   loop invariant v >= 0 <==> q >= 0;\n   loop assigns v, i;\n */\nwhile (i>0) {\n      v = v*3;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n){\n  int l, i, v, s, z, o;\n\n  l=33;\n  i=0;\n  v=6;\n  s=5;\n  z=-4;\n  o=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      s = s+v;\n      z = z+s;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      s = s+v;\n      z = z+s;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'o', 's', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n){\n  int l, i, v, s, z, o;\n\n  l=33;\n  i=0;\n  v=6;\n  s=5;\n  z=-4;\n  o=n;\n\n  \n  /*@\n\n    loop invariant v == 6 + 3 * i;\n\n    loop invariant 2 * (s - 5) == 3 * i * (i + 5);\n\n    loop invariant 2 * (z + 4 - 5 * i) == i * (i + 1) * (i + 8);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre);\n\n    loop assigns v, s, z, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+3;\n      s = s+v;\n      z = z+s;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p){\n  int l, i, v;\n\n  l=43;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+2;\n      v = v+i;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+2;\n      v = v+i;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p){\n  int l, i, v;\n\n  l=43;\n  i=0;\n  v=m;\n\n  \n  /*@\n\n    loop invariant v == m + i*(i+1);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant l == 43;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+2;\n      v = v+i;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p,int q){\n  int l, i, v;\n\n  l=69;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      if (v+7<l) {\n          v = v+i;\n      }\n      else {\n          v = v+6;\n      }\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      if (v+7<l) {\n          v = v+i;\n      }\n      else {\n          v = v+6;\n      }\n      v = v+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p,int q){\n  int l, i, v;\n\n  l=69;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant (i == 0) ==> (v == 69);\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant l == 69;\n    loop invariant v >= 0;\n    loop assigns v, i;\n  */\n  while (i<l) {\n      v = v-v;\n      if (v+7<l) {\n          v = v+i;\n      }\n      else {\n          v = v+6;\n      }\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p){\n  int l, i, v, o, w, r, q, s, g;\n\n  l=43;\n  i=l;\n  v=i;\n  o=2;\n  w=-3;\n  r=p;\n  q=1;\n  s=m;\n  g=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+i;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+i;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'g', 'i', 'l', 'm', 'o', 'p', 'q', 'r', 's', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p){\n  int l, i, v, o, w, r, q, s, g;\n\n  l=43;\n  i=l;\n  v=i;\n  o=2;\n  w=-3;\n  r=p;\n  q=1;\n  s=m;\n  g=m;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v == l + (l - i)*l - ((l - i)*(l - i - 1))/2;\n\n    loop invariant l == 43;\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+i;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p,int q){\n  int l, i, v, m, d, f;\n\n  l=38;\n  i=0;\n  v=q;\n  m=l;\n  d=-2;\n  f=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      d = d+2;\n      m = m+f;\n      m = m+d;\n      d = d+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      d = d+2;\n      m = m+f;\n      m = m+d;\n      d = d+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'f', 'i', 'l', 'm', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p,int q){\n  int l, i, v, m, d, f;\n\n  l=38;\n  i=0;\n  v=q;\n  m=l;\n  d=-2;\n  f=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v == q + 3*i;\n    loop invariant d == -2 + 3*i;\n    loop invariant m == 38 - 4*i + (3*i*(i-1))/2;\n    loop invariant l == 38;\n    loop invariant q == \\at(q, Pre);\n    loop assigns v, d, m, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+3;\n      d = d+2;\n      m = m+f;\n      m = m+d;\n      d = d+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, q, t, m, x, d, u, f;\n\n  l=46;\n  i=0;\n  v=b;\n  q=i;\n  t=n;\n  m=i;\n  x=-1;\n  d=n;\n  u=l;\n  f=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      q = q*q;\n      t = t+v*q;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      q = q*q;\n      t = t+v*q;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'f', 'i', 'l', 'm', 'n', 'p', 'q', 't', 'u', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, q, t, m, x, d, u, f;\n\n  l=46;\n  i=0;\n  v=b;\n  q=i;\n  t=n;\n  m=i;\n  x=-1;\n  d=n;\n  u=l;\n  f=l;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant v == b + i*(i-1)/2;\n\n    loop invariant q == 0;\n\n    loop invariant t == n;\n\n    loop assigns v, q, t, i;\n\n    loop variant l - i;\n\n  */\n  while (i < l) {\n      v = v + i;\n      q = q * q;\n      t = t + v * q;\n      i = i + 1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int q){\n  int l, i, v, j, d;\n\n  l=40;\n  i=0;\n  v=8;\n  j=6;\n  d=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      j = j+v;\n      v = v+1;\n      if ((i%7)==0) {\n          d = d+1;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      j = j+v;\n      v = v+1;\n      if ((i%7)==0) {\n          d = d+1;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'i', 'j', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int q){\n  int l, i, v, j, d;\n\n  l=40;\n  i=0;\n  v=8;\n  j=6;\n  d=b;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant v == 8 + 2 * i;\n\n    loop invariant (j - i * (v - i)) == 6;\n\n    loop invariant d == b + (i + 6) / 7;\n\n    loop assigns v, j, d, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      j = j+v;\n      v = v+1;\n      if ((i%7)==0) {\n          d = d+1;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int q){\n  int l, i, v, x, t, g, z, c, y;\n\n  l=55;\n  i=0;\n  v=m;\n  x=m;\n  t=q;\n  g=q;\n  z=l;\n  c=0;\n  y=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*4;\n      x = x/4;\n      if (x+2<l) {\n          t = t*2;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*4;\n      x = x/4;\n      if (x+2<l) {\n          t = t*2;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'g', 'i', 'l', 'm', 'q', 't', 'v', 'x', 'y', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int q){\n  int l, i, v, x, t, g, z, c, y;\n\n  l=55;\n  i=0;\n  v=m;\n  x=m;\n  t=q;\n  g=q;\n  z=l;\n  c=0;\n  y=l;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant l == 55;\n\n    loop invariant (i == 0) ==> (v == m && x == m && t == q);\n\n    loop invariant i > 0 ==> v % 4 == 0;\n\n    loop assigns v, x, t, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v*4;\n      x = x/4;\n      if (x+2<l) {\n          t = t*2;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int q){\n  int l, i, v;\n\n  l=q-6;\n  i=0;\n  v=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      v = v+3;\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      v = v+3;\n      v = v-v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int q){\n  int l, i, v;\n\n  l=q-6;\n  i=0;\n  v=-4;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant (i == 0 && v == -4) || (i > 0 && v == 0);\n\n    loop invariant (i == 0 || i <= l);\n\n    loop invariant l == \\at(q, Pre) - 6;\n\n    loop invariant q == \\at(q, Pre) && m == \\at(m, Pre) && b == \\at(b, Pre);\n\n    loop assigns i, v;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      v = v+3;\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int q){\n  int l, i, v;\n\n  l=58;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      if (i+6<=q+l) {\n          v = v+1;\n      }\n      v = v-v;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      if (i+6<=q+l) {\n          v = v+1;\n      }\n      v = v-v;\n      v = v+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int q){\n  int l, i, v;\n\n  l=58;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant l == 58;\n   loop invariant 0 <= i && i <= l;\n   loop invariant (i == 0) ==> (v == l);\n   loop invariant (i > 0) ==> (v == 0);\n   loop assigns i, v;\n   loop variant l - i;\n */\nwhile (i<l) {\n      v = v-v;\n      if (i+6<=q+l) {\n          v = v+1;\n      }\n      v = v-v;\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p){\n  int l, i, v, a, q, o, z, f;\n\n  l=24;\n  i=0;\n  v=0;\n  a=-1;\n  q=n;\n  o=2;\n  z=p;\n  f=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      a = a+v;\n      v = v+4;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      a = a+v;\n      v = v+4;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'f', 'i', 'l', 'n', 'o', 'p', 'q', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p){\n  int l, i, v, a, q, o, z, f;\n\n  l=24;\n  i=0;\n  v=0;\n  a=-1;\n  q=n;\n  o=2;\n  z=p;\n  f=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 5*i;\n    loop invariant a == -1 + (i*(5*i - 3))/2;\n    loop invariant i <= l;\n    loop invariant 0 <= i;\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop assigns v, a, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      a = a+v;\n      v = v+4;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p){\n  int l, i, v, g, h, o, z;\n\n  l=23;\n  i=0;\n  v=l;\n  g=p;\n  h=-5;\n  o=m;\n  z=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v!=0&&g!=0) {\n      if (v>g) {\n          v = v-g;\n      }\n      else {\n          g = g-v;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (v!=0&&g!=0) {\n      if (v>g) {\n          v = v-g;\n      }\n      else {\n          g = g-v;\n      }\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'g', 'h', 'i', 'l', 'm', 'o', 'p', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p){\n  int l, i, v, g, h, o, z;\n\n  l=23;\n  i=0;\n  v=l;\n  g=p;\n  h=-5;\n  o=m;\n  z=m;\n\n  \n  /*@\n\n    loop invariant (p >= 0) ==> v >= 0;\n\n    loop invariant (p >= 0) ==> g >= 0;\n\n    loop assigns v, g;\n\n  */\n  while (v!=0&&g!=0) {\n      if (v>g) {\n          v = v-g;\n      }\n      else {\n          g = g-v;\n      }\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p,int q){\n  int l, i, v, t, x, z, d, y, s, m;\n\n  l=68;\n  i=0;\n  v=5;\n  t=n;\n  x=6;\n  z=-4;\n  d=0;\n  y=p;\n  s=q;\n  m=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+t;\n      t = t+x;\n      x = x+2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+t;\n      t = t+x;\n      x = x+2;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['d', 'i', 'l', 'm', 'n', 'p', 'q', 's', 't', 'v', 'x', 'y', 'z']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p,int q){\n  int l, i, v, t, x, z, d, y, s, m;\n\n  l=68;\n  i=0;\n  v=5;\n  t=n;\n  x=6;\n  z=-4;\n  d=0;\n  y=p;\n  s=q;\n  m=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant t == n + i*i + 5*i;\n    loop invariant x == 6 + 2*i;\n    loop invariant v == 5 + i*n + i*(i-1)*(i+7)/3;\n    loop assigns v, t, x, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+t;\n      t = t+x;\n      x = x+2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int p,int q){\n  int l, i, v;\n\n  l=p+11;\n  i=0;\n  v=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%5)==0) {\n          v = v+1;\n      }\n      else {\n          v = v+4;\n      }\n      if (v+3<l) {\n          v = v+3;\n      }\n      v = v+1;\n      if ((i%6)==0) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%5)==0) {\n          v = v+1;\n      }\n      else {\n          v = v+4;\n      }\n      if (v+3<l) {\n          v = v+3;\n      }\n      v = v+1;\n      if ((i%6)==0) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int p,int q){\n  int l, i, v;\n\n  l=p+11;\n  i=0;\n  v=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == p + 11;\n    loop invariant 0 <= i;\n    loop invariant i <= l || l <= 0;\n    loop invariant (p <= 0) ==> (v >= p);\n    loop assigns i, v;\n  */\nwhile (i<l) {\n      if ((i%5)==0) {\n          v = v+1;\n      }\n      else {\n          v = v+4;\n      }\n      if (v+3<l) {\n          v = v+3;\n      }\n      v = v+1;\n      if ((i%6)==0) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m){\n  int l, i, v, w, u, x;\n\n  l=32;\n  i=1;\n  v=i;\n  w=0;\n  u=1;\n  x=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      w = w/2;\n      v = v+i;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      w = w/2;\n      v = v+i;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'u', 'v', 'w', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m){\n  int l, i, v, w, u, x;\n\n  l=32;\n  i=1;\n  v=i;\n  w=0;\n  u=1;\n  x=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 32;\n    loop invariant i <= l;\n    loop invariant i > 0;\n    loop invariant w == 0;\n    loop invariant v % i == 0;\n    loop invariant v >= i;\n    loop assigns v, w;\n  */\nwhile (i<l) {\n      v = v*2;\n      w = w/2;\n      v = v+i;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int p){\n  int l, i, v, n, o;\n\n  l=50;\n  i=0;\n  v=k;\n  n=8;\n  o=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      n = n+v;\n      n = n+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      n = n+v;\n      n = n+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'o', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int p){\n  int l, i, v, n, o;\n\n  l=50;\n  i=0;\n  v=k;\n  n=8;\n  o=i;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant v == k + i;\n\n    loop invariant n == i*i + i*(2*k + 1) + 8;\n\n    loop invariant l == 50;\n\n    loop assigns i, v, n;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      n = n+v;\n      n = n+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int q){\n  int l, i, v, t, u, f, c, x;\n\n  l=63;\n  i=0;\n  v=2;\n  t=k;\n  u=i;\n  f=k;\n  c=-5;\n  x=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      f = v+t+u;\n      v = v+1;\n      t = t+u;\n      u = u+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      f = v+t+u;\n      v = v+1;\n      t = t+u;\n      u = u+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'f', 'i', 'k', 'l', 'q', 't', 'u', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int q){\n  int l, i, v, t, u, f, c, x;\n\n  l=63;\n  i=0;\n  v=2;\n  t=k;\n  u=i;\n  f=k;\n  c=-5;\n  x=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i <= l;\n    loop invariant v == i + 2;\n    loop invariant u == i;\n    loop invariant t == k + i*(i-1)/2;\n    loop invariant (i == 0) ==> (f == k);\n    loop invariant k == \\at(k, Pre);\n    loop assigns f, v, t, u, i;\n  */\n  while (i<l) {\n      f = v+t+u;\n      v = v+1;\n      t = t+u;\n      u = u+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      v = v-v;\n      v = v+1;\n      v = v+1;\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      v = v-v;\n      v = v+1;\n      v = v+1;\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=i;\n\n  \n  /*@\n\n    loop invariant l == 34;\n\n    loop invariant i <= l;\n\n    loop invariant (i == 0) ==> (v == 0);\n\n    loop invariant i >= 0;\n\n    loop invariant v >= 0;\n\n    loop assigns i, v;\n\n  */\n  while (i<l) {\n      v = v-v;\n      v = v-v;\n      v = v+1;\n      v = v+1;\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      v = v-v;\n      v = v+1;\n      v = v+1;\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      v = v-v;\n      v = v+1;\n      v = v+1;\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant (i == 0) ==> (v == 0);\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v-v;\n      v = v-v;\n      v = v+1;\n      v = v+1;\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int q){\n  int l, i, v, r, f, b, s, d;\n\n  l=52;\n  i=0;\n  v=k;\n  r=k;\n  f=-6;\n  b=n;\n  s=8;\n  d=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      r = r/2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      r = r/2;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'd', 'f', 'i', 'k', 'l', 'm', 'n', 'q', 'r', 's', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int q){\n  int l, i, v, r, f, b, s, d;\n\n  l=52;\n  i=0;\n  v=k;\n  r=k;\n  f=-6;\n  b=n;\n  s=8;\n  d=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant l == 52;\n    loop invariant (k >= 0) ==> (r <= k);\n    loop invariant (k >= 0) ==> (v >= k);\n    loop assigns i, v, r;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v*2;\n      r = r/2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v, h, g, z, t, c;\n\n  l=25;\n  i=l;\n  v=-6;\n  h=l;\n  g=a;\n  z=l;\n  t=-4;\n  c=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      z = z*z+v;\n      v = v%6;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      z = z*z+v;\n      v = v%6;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'q', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v, h, g, z, t, c;\n\n  l=25;\n  i=l;\n  v=-6;\n  h=l;\n  g=a;\n  z=l;\n  t=-4;\n  c=q;\n\n  /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant v == -6 || (-5 <= v && v <= 5);\n    loop invariant l == 25;\n    loop invariant i == l ==> (z == l && v == -6);\n    loop invariant a == \\at(a,Pre) && n == \\at(n,Pre) && p == \\at(p,Pre) && q == \\at(q,Pre);\n    loop assigns i, v, z;\n    loop variant i;\n  */\nwhile (i>0) {\n      z = z*z+v;\n      v = v%6;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=i;\n\n  /*@\n    loop invariant i <= l;\n    loop invariant 0 <= i;\n    loop invariant v == 0;\n    loop invariant l == 34;\n    loop invariant a == \\at(a, Pre);\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int n){\n  int l, i, v, r, g;\n\n  l=15;\n  i=0;\n  v=a;\n  r=i;\n  g=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      r = r-1;\n      v = g-v;\n      r = r+3;\n      r = r+g;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      r = r-1;\n      v = g-v;\n      r = r+3;\n      r = r+g;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'g', 'i', 'k', 'l', 'n', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int n){\n  int l, i, v, r, g;\n\n  l=15;\n  i=0;\n  v=a;\n  r=i;\n  g=a;\n\n  /*@ \n    loop invariant g == a;\n    loop invariant l == 15;\n    loop invariant 0 <= i <= l;\n    loop invariant r == i * (2 + g);\n    loop invariant (i % 2 == 0) ==> (v == a);\n    loop invariant (i % 2 == 1) ==> (v == -1);\n    loop assigns v, r, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      r = r-1;\n      v = g-v;\n      r = r+3;\n      r = r+g;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p,int q){\n  int l, i, v, z, h, j;\n\n  l=18;\n  i=0;\n  v=i;\n  z=p;\n  h=-6;\n  j=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      z = z+v;\n      h = h%3;\n      j = j*2;\n      j = j%2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      z = z+v;\n      h = h%3;\n      j = j*2;\n      j = j%2;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'h', 'i', 'j', 'l', 'm', 'p', 'q', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p,int q){\n  int l, i, v, z, h, j;\n\n  l=18;\n  i=0;\n  v=i;\n  z=p;\n  h=-6;\n  j=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant v == 0;\n    loop invariant z == \\at(p, Pre);\n    loop invariant h <= 0;\n    loop invariant (i == 0) ==> (j == 18);\n    loop invariant (i > 0) ==> (j == 0);\n    loop variant l - i;\n    loop assigns v, z, h, j, i;\n  */\nwhile (i<l) {\n      v = v*2;\n      z = z+v;\n      h = h%3;\n      j = j*2;\n      j = j%2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n,int p){\n  int l, i, v, w, z, q, b;\n\n  l=41;\n  i=l;\n  v=1;\n  w=l;\n  z=-2;\n  q=l;\n  b=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      w = w+v;\n      z = z%4;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      w = w+v;\n      z = z%4;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'p', 'v', 'w', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n,int p){\n  int l, i, v, w, z, q, b;\n\n  l=41;\n  i=l;\n  v=1;\n  w=l;\n  z=-2;\n  q=l;\n  b=-3;\n\n  /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant z == -2;\n    loop invariant w == 2*v + 39;\n    loop invariant 0 <= i && i <= l;\n    loop invariant v >= 1;\n    loop assigns v, w, z, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v*2;\n      w = w+v;\n      z = z%4;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int m){\n  int l, i, v;\n\n  l=b+19;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%6)==0) {\n          v = l-(-4);\n      }\n      v = v+v;\n      if (i+7<=v+l) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%6)==0) {\n          v = l-(-4);\n      }\n      v = v+v;\n      if (i+7<=v+l) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int m){\n  int l, i, v;\n\n  l=b+19;\n  i=0;\n  v=l;\n\n  /*@\n    loop invariant l == b + 19;\n    loop invariant 0 <= i;\n    loop invariant (l >= 0) ==> i <= l;\n    loop invariant (l >= 0) ==> v >= 0;\n    loop assigns i, v;\n    loop variant l - i;\n  @*/\n  while (i<l) {\n      if ((i%6)==0) {\n          v = l-(-4);\n      }\n      v = v+v;\n      if (i+7<=v+l) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p,int q){\n  int l, i, v;\n\n  l=11;\n  i=l;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v-v;\n      if ((i%3)==0) {\n          v = v-i;\n      }\n      v = v%3;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v-v;\n      if ((i%3)==0) {\n          v = v-i;\n      }\n      v = v%3;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p,int q){\n  int l, i, v;\n\n  l=11;\n  i=l;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant (i == l) ==> (v == 2);\n    loop invariant (i < l) ==> (v == 0);\n    loop assigns i, v;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v-v;\n      if ((i%3)==0) {\n          v = v-i;\n      }\n      v = v%3;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int p,int q){\n  int l, i, v, h, z, m, o, r, c, u;\n\n  l=51;\n  i=0;\n  v=q;\n  h=i;\n  z=5;\n  m=-1;\n  o=k;\n  r=6;\n  c=q;\n  u=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2+4;\n      h = h*v+4;\n      h = h*h+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2+4;\n      h = h*v+4;\n      h = h*h+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'h', 'i', 'k', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int p,int q){\n  int l, i, v, h, z, m, o, r, c, u;\n\n  l=51;\n  i=0;\n  v=q;\n  h=i;\n  z=5;\n  m=-1;\n  o=k;\n  r=6;\n  c=q;\n  u=i;\n\n  /*@ \n     loop invariant 0 <= i <= l;\n     loop invariant (i == 0) ==> (h == 0);\n     loop invariant (i == 0) ==> (v == q);\n     loop invariant l == 51;\n     loop assigns v, h, i;\n  @*/\n  while (i<l) {\n      v = v*2+4;\n      h = h*v+4;\n      h = h*h+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v, f, e, x, z;\n\n  l=26;\n  i=0;\n  v=-4;\n  f=a;\n  e=q;\n  x=i;\n  z=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      e = e+3;\n      x = x+1;\n      i = i+2;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      e = e+3;\n      x = x+1;\n      i = i+2;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'e', 'i', 'l', 'n', 'p', 'q', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v, f, e, x, z;\n\n  l=26;\n  i=0;\n  v=-4;\n  f=a;\n  e=q;\n  x=i;\n  z=-5;\n\n  /*@\n     loop invariant i <= l;\n     loop invariant i >= 0;\n     loop invariant i % 2 == 0;\n     loop invariant 2*v == -8 + 3*i;\n     loop invariant 2*e == 2*q + 3*i;\n     loop invariant i == 2*x;\n     loop assigns v, e, x, i;\n     loop variant l - i;\n  */\n  while (i<l) {\n      v = v+3;\n      e = e+3;\n      x = x+1;\n      i = i+2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int p,int q){\n  int l, i, v, r, s;\n\n  l=19;\n  i=0;\n  v=8;\n  r=b;\n  s=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+r+s;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+r+s;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'p', 'q', 'r', 's', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int p,int q){\n  int l, i, v, r, s;\n\n  l=19;\n  i=0;\n  v=8;\n  r=b;\n  s=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant v == 8 + i*(r + s + 1);\n    loop invariant i <= l;\n    loop invariant 0 <= i;\n    loop invariant l == 19;\n    loop invariant b == \\at(b, Pre);\n    loop invariant s == 0;\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+r+s;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v;\n\n  l=a+17;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v;\n\n  l=a+17;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant l == a + 17;\n    loop invariant i >= 0;\n    loop invariant (l >= 0) ==> (i <= l);\n    loop invariant (i == 0) ==> (v == 4);\n    loop invariant (i != 0) ==> (v == i - 1);\n    loop assigns v, i;\n  */\nwhile (i<l) {\n      v = v-v;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int p,int q){\n  int l, i, v, w, u, t;\n\n  l=58;\n  i=0;\n  v=i;\n  w=i;\n  u=a;\n  t=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      w = w*w;\n      u = u+v*w;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      w = w*w;\n      u = u+v*w;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'p', 'q', 'u', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int p,int q){\n  int l, i, v, w, u, t;\n\n  l=58;\n  i=0;\n  v=i;\n  w=i;\n  u=a;\n  t=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant i <= l;\n    loop invariant v == i*(i-1)/2;\n    loop invariant w == 0;\n    loop invariant u == a;\n    loop invariant i >= 0;\n    loop assigns v, w, u, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+i;\n      w = w*w;\n      u = u+v*w;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int p){\n  int l, i, v;\n\n  l=40;\n  i=0;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      if ((i%8)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+2;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      if ((i%8)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+2;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int p){\n  int l, i, v;\n\n  l=40;\n  i=0;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant 0 <= i <= l;\n    loop invariant l == 40;\n    loop invariant (i == 0) ==> (v == b);\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      if ((i%8)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+2;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p,int q){\n  int l, i, v, n, x, h, g;\n\n  l=14;\n  i=l;\n  v=a;\n  n=-2;\n  x=a;\n  h=q;\n  g=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      n = n+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      n = n+v;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p,int q){\n  int l, i, v, n, x, h, g;\n\n  l=14;\n  i=l;\n  v=a;\n  n=-2;\n  x=a;\n  h=q;\n  g=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant n == 2*v - 2*a - 2;\n    loop invariant a == \\at(a, Pre);\n    loop assigns v, n, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v*2;\n      n = n+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int n){\n  int l, i, v, u, g, y, q, h, o, d;\n\n  l=46;\n  i=0;\n  v=n;\n  u=6;\n  g=m;\n  y=4;\n  q=-2;\n  h=a;\n  o=k;\n  d=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2+2;\n      u = u*v+2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2+2;\n      u = u*v+2;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'n', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int n){\n  int l, i, v, u, g, y, q, h, o, d;\n\n  l=46;\n  i=0;\n  v=n;\n  u=6;\n  g=m;\n  y=4;\n  q=-2;\n  h=a;\n  o=k;\n  d=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n     loop invariant i >= 0;\n     loop invariant i <= l;\n     loop invariant (i == 0) ==> (v == n);\n     loop invariant (i == 0) ==> (u == 6);\n     loop assigns v, u, i;\n     loop variant l - i;\n  */\n  while (i<l) {\n      v = v*2+2;\n      u = u*v+2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int p){\n  int l, i, v, h, x, z, t, c;\n\n  l=n+19;\n  i=0;\n  v=p;\n  h=p;\n  x=n;\n  z=p;\n  t=8;\n  c=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*3+3;\n      h = h*v+3;\n      c = c*c+z;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n### Loop Context ###\n\n1. Pre-Condition (Before Loop Entry):\n   No pre-condition specified\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*3+3;\n      h = h*v+3;\n      c = c*c+z;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['c', 'h', 'i', 'k', 'l', 'm', 'n', 'p', 't', 'v', 'x', 'z']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int p){\n  int l, i, v, h, x, z, t, c;\n\n  l=n+19;\n  i=0;\n  v=p;\n  h=p;\n  x=n;\n  z=p;\n  t=8;\n  c=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant 0 <= i;\n   loop invariant (l >= 0) ==> (i <= l);\n   loop invariant (i == 0) ==> (v == p);\n   loop invariant (i > 0) ==> (v % 3 == 0);\n   loop invariant (i == 0) ==> (h == p);\n   loop invariant (i == 0) ==> (c == m);\n   loop assigns v, h, c, i;\n */\nwhile (i<l) {\n      v = v*3+3;\n      h = h*v+3;\n      c = c*c+z;\n      i = i+1;\n  }\n\n}"}
