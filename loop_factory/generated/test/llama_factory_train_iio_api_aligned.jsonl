{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int q){\n  int l, i, v, w, u;\n\n  l=18;\n  i=0;\n  v=q;\n  w=8;\n  u=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+w+u;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (u == 18) && (w == 8) && (v == \\at(q, Pre)) && (i == 0) && (l == 18) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+w+u;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + w@last + u@last. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; q keeps q@last; u keeps u@last; w keeps w@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'q', 'u', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int q){\n  int l, i, v, w, u;\n\n  l=18;\n  i=0;\n  v=q;\n  w=8;\n  u=l;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant l == 18;\n\n    loop invariant w == 8 && u == 18;\n\n    loop invariant v == \\at(q, Pre) + i * (w + u);\n\n    loop invariant w == 8;\n\n    loop invariant u == l;\n\n    loop invariant v == q + 26*i;\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant i <= l;\n\n    loop invariant 0 <= i;\n\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && q == \\at(q, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant v == q + i*(w+u);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant v == \\at(q, Pre) + i*(w + u);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+w+u;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int p){\n  int l, i, v, s;\n\n  l=(m%7)+17;\n  i=0;\n  v=a;\n  s=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      i = i+2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (s == \\at(m, Pre)) && (v == \\at(a, Pre)) && (i == 0) && (l == \\at(m, Pre) % 7 + 17) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      i = i+2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 2; v: v@last -> v@last + 1. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last; s keeps s@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int p){\n  int l, i, v, s;\n\n  l=(m%7)+17;\n  i=0;\n  v=a;\n  s=m;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n\n    loop invariant i % 2 == 0;\n\n    loop invariant v == a + i/2;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant l == (m % 7) + 17;\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l + 1;\n\n    loop invariant l == (\\at(m,Pre) % 7) + 17;\n\n    loop invariant a == \\at(a,Pre);\n\n    loop invariant 2*(v - \\at(a, Pre)) == i;\n\n    loop invariant l == (\\at(m, Pre) % 7) + 17;\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant 2*v == 2*\\at(a, Pre) + i;\n\n    loop invariant l == m % 7 + 17;\n\n    loop assigns i, v;\n\n  */\n  while (i<l) {\n      v = v+1;\n      i = i+2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int q){\n  int l, i, v;\n\n  l=m;\n  i=0;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v%7;\n      v = v*v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(a, Pre)) && (i == 0) && (l == \\at(m, Pre)) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v%7;\n      v = v*v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last % 7). Changed: i: i@last -> i@last + 1; v: v@last -> v@last % 7. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int q){\n  int l, i, v;\n\n  l=m;\n  i=0;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == \\at(m, Pre);\n    loop invariant i >= 0;\n\n    loop invariant (i > 0) ==> (v >= 0 && v <= 36);\n    loop invariant a == \\at(a, Pre);\n    loop invariant 0 <= i;\n    loop invariant (l >= 0 ==> i <= l);\n    loop invariant (i == 0 ==> v == \\at(a, Pre)) && (i > 0 ==> 0 <= v && v <= 36);\n    loop invariant l == m;\n    loop invariant (i == 0) ==> (v == a);\n    loop invariant (i > 0) ==> (v == 0 || v == 1 || v == 4 || v == 9 || v == 16 || v == 25 || v == 36);\n    loop invariant (l >= 0) ==> (i <= l);\n    loop invariant (i == 0) ==> (v == \\at(a, Pre));\n    loop invariant (i > 0) ==> (0 <= v && v <= 36);\n    loop assigns v, i;\n  */\n  while (i<l) {\n      v = v%7;\n      v = v*v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int p){\n  int l, i, v, f;\n\n  l=67;\n  i=0;\n  v=6;\n  f=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      f = f+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (f == \\at(k, Pre)) && (v == 6) && (i == 0) && (l == 67) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      f = f+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: f: f@last -> f@last + (v@last + 1; i: i@last -> i@last + 1; v: v@last -> v@last + 1. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['f', 'i', 'k', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int p){\n  int l, i, v, f;\n\n  l=67;\n  i=0;\n  v=6;\n  f=k;\n\n  \n  /*@\n\n    loop invariant v == 6 + i;\n\n    loop invariant f == \\at(k, Pre) + 6*i + (i*(i+1))/2;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant f == k + 7*i + i*(i-1)/2;\n\n    loop invariant i >= 0;\n\n    loop invariant l == 67;\n\n    loop invariant f == k + 6*i + i*(i+1)/2;\n\n    loop invariant f == \\at(k,Pre) + 6*i + (i*(i+1))/2;\n\n    loop invariant k == \\at(k,Pre);\n\n    loop assigns v, f, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      f = f+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int q){\n  int l, i, v, w, z;\n\n  l=68;\n  i=l;\n  v=-6;\n  w=8;\n  z=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+w+z;\n      v = v+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (z == 1) && (w == 8) && (v == -6) && (i == 68) && (l == 68) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+w+z;\n      v = v+1;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + w@last + z@last + 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; q keeps q@last; w keeps w@last; z keeps z@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'q', 'v', 'w', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int q){\n  int l, i, v, w, z;\n\n  l=68;\n  i=l;\n  v=-6;\n  w=8;\n  z=1;\n\n  \n  /*@\n\n    loop invariant l == 68;\n\n    loop invariant w == 8;\n\n    loop invariant z == 1;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v == -6 + (l - i) * (w + z + 1);\n\n    loop invariant 0 <= i && i <= 68;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant w == 8 && z == 1;\n\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && q == \\at(q, Pre);\n\n    loop invariant v + 10 * i == 674;\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= 68;\n\n    loop invariant v + i*(w + z + 1) == 674;\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+w+z;\n      v = v+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int n){\n  int l, i, v, q, s;\n\n  l=(b%15)+18;\n  i=0;\n  v=3;\n  q=n;\n  s=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      q = q+s;\n      i = i+2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (s == \\at(m, Pre)) && (q == \\at(n, Pre)) && (v == 3) && (i == 0) && (l == \\at(b, Pre) % 15 + 18) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      q = q+s;\n      i = i+2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 2; q: q@last -> q@last + s@last. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last; s keeps s@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'n', 'q', 's']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int n){\n  int l, i, v, q, s;\n\n  l=(b%15)+18;\n  i=0;\n  v=3;\n  q=n;\n  s=m;\n\n  \n  /*@\n\n    loop invariant 2*(q - \\at(n, Pre)) == i * s;\n\n    loop invariant 0 <= i && i <= l + 1;\n\n    loop invariant i % 2 == 0;\n\n    loop invariant s == \\at(m, Pre);\n\n    loop invariant l == (\\at(b, Pre) % 15) + 18;\n\n    loop invariant q == n + (i/2) * s;\n\n    loop invariant i <= l + 1;\n\n    loop invariant l == (b % 15) + 18;\n\n    loop invariant q - n == s * (i/2);\n\n    loop invariant q == n + s * (i/2);\n\n    loop invariant s == m;\n\n    loop invariant l == (\\at(b,Pre) % 15) + 18;\n\n    loop invariant i >= 0;\n\n\n    loop invariant q == n + m * (i/2);\n\n    loop invariant b == \\at(b,Pre);\n\n    loop invariant k == \\at(k,Pre);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant n == \\at(n,Pre);\n\n    loop invariant 0 <= i <= l + 1;\n\n    loop assigns q, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      q = q+s;\n      i = i+2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int p,int q){\n  int l, i, v, y;\n\n  l=28;\n  i=0;\n  v=-1;\n  y=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+y+y;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (y == 0) && (v == -1) && (i == 0) && (l == 28) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+y+y;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + y@last + y@last. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last; y keeps y@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'p', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int p,int q){\n  int l, i, v, y;\n\n  l=28;\n  i=0;\n  v=-1;\n  y=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == -1 + 2*y*i;\n    loop invariant i <= l;\n    loop invariant l == 28;\n    loop invariant y == 0;\n    loop invariant k == \\at(k, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n    loop invariant 0 <= i <= l;\n    loop invariant v == -1;\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant v == -1 + 2*i*y;\n    loop invariant 0 <= i && i <= l;\n    loop assigns i, v;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      v = v+y+y;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int q){\n  int l, i, v, d, r;\n\n  l=(a%25)+19;\n  i=0;\n  v=k;\n  d=l;\n  r=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      d = d+r;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (r == \\at(a, Pre) % 25 + 19) && (d == \\at(a, Pre) % 25 + 19) && (v == \\at(k, Pre)) && (i == 0) && (l == \\at(a, Pre) % 25 + 19) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      d = d+r;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: d: d@last -> d@last + r@last; i: i@last -> i@last + 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; q keeps q@last; r keeps r@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'd', 'i', 'k', 'l', 'm', 'q', 'r']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int q){\n  int l, i, v, d, r;\n\n  l=(a%25)+19;\n  i=0;\n  v=k;\n  d=l;\n  r=l;\n\n  \n  /*@\n\n\n    loop invariant d - r * i == l;\n\n    loop invariant r == l;\n\n    loop invariant l == (\\at(a, Pre) % 25) + 19;\n\n    loop invariant l == (a % 25) + 19;\n\n    loop invariant i >= 0;\n\n\n    loop invariant d == l + i*r;\n\n    loop invariant d == r*(i+1);\n\n    loop invariant l == \\at(a, Pre) % 25 + 19;\n\n    loop invariant d == l + i * r;\n\n    loop invariant i >= 0 && (l >= 0 ==> i <= l);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant d == l * (i + 1);\n\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && q == \\at(q, Pre);\n\n    loop assigns d, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      d = d+r;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int p){\n  int l, i, v;\n\n  l=p;\n  i=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 0) && (l == \\at(p, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + v@last. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int p){\n  int l, i, v;\n\n  l=p;\n  i=0;\n  v=0;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n\n    loop invariant v == 0;\n\n    loop invariant l == p;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop invariant l == \\at(p, Pre);\n\n    loop invariant (l >= 0) ==> i <= l;\n\n    loop assigns i, v;\n\n  */\n  while (i<l) {\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int p,int q){\n  int l, i, v, g, d;\n\n  l=49;\n  i=l;\n  v=k;\n  g=-4;\n  d=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (d == -2) && (g == -4) && (v == \\at(k, Pre)) && (i == 49) && (l == 49) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + 1. Unchanged: b keeps b@last; d keeps d@last; g keeps g@last; k keeps k@last; l keeps l@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int p,int q){\n  int l, i, v, g, d;\n\n  l=49;\n  i=l;\n  v=k;\n  g=-4;\n  d=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == k + (l - i);\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant l == 49;\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant v + i == k + 49;\n    loop invariant i >= 0;\n    loop invariant i <= 49;\n    loop invariant v >= k;\n    loop invariant v + i == \\at(k, Pre) + 49;\n    loop invariant v - k == l - i;\n    loop invariant i + v == l + k;\n    loop invariant v <= k + l;\n    loop assigns i, v;\n    loop variant i;\n  */\nwhile (i>0) {\n      v = v+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int n){\n  int l, i, v;\n\n  l=77;\n  i=0;\n  v=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      v = v+4;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -5) && (i == 0) && (l == 77) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      v = v+4;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + i@last + 4. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int n){\n  int l, i, v;\n\n  l=77;\n  i=0;\n  v=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v == -5 + i*(i-1)/2 + 4*i;\n    loop invariant l == 77;\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant 0 <= i && i <= l;\n    loop invariant v == -5 + (i*(i+7))/2;\n    loop invariant i*i + 7*i == 2*v + 10;\n    loop invariant 0 <= i;\n    loop invariant 0 <= i <= l;\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+i;\n      v = v+4;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n,int p){\n  int l, i, v, j, a;\n\n  l=17;\n  i=0;\n  v=-1;\n  j=m;\n  a=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+4;\n      a = a+2;\n      v = v+i;\n      i = i+4;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (a == 2) && (j == \\at(m, Pre)) && (v == -1) && (i == 0) && (l == 17) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+4;\n      a = a+2;\n      v = v+i;\n      i = i+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: a: a@last -> a@last + 2; i: i@last -> i@last + 4; v: v@last -> v@last + 4 + i@last. Unchanged: b keeps b@last; j keeps j@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n,int p){\n  int l, i, v, j, a;\n\n  l=17;\n  i=0;\n  v=-1;\n  j=m;\n  a=2;\n\n  \n  /*@\n\n    loop invariant i % 4 == 0;\n\n    loop invariant 2*a == i + 4;\n\n    loop invariant 8*v == i*i + 4*i - 8;\n\n    loop invariant i == 2*(a - 2);\n\n    loop invariant v == (a*(a - 2))/2 - 1;\n\n    loop invariant 0 <= i && i <= l + 3;\n\n    loop invariant a == 2 + i/2;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant v == -1 + 2*(i/4)*((i/4)+1);\n\n    loop invariant l == 17;\n\n\n    loop invariant b == \\at(b, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop assigns i, a, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+4;\n      a = a+2;\n      v = v+i;\n      i = i+4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int m){\n  int l, i, v;\n\n  l=b+14;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v+v;\n      v = v+v;\n      if (v+4<l) {\n          v = v*v+v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 4) && (i == 0) && (l == \\at(b, Pre) + 14) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v+v;\n      v = v+v;\n      if (v+4<l) {\n          v = v*v+v;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last; v@last + v@last + (v@last; v@last + v@last) + 4 >= l@last; i@last < l@last; v@last + v@last + (v@last; v@last + v@last)) || v@last; v@last + v@last + (v@last; v@last + v@last) + 4 < l@last; i@last < l@last; v@last + v@last + (v@last; v@last + v@last; v@last; v@last + v@last + (v@last; v@last + v@last)) + (v@last; v@last + v@last + (v@last; v@last + v@last). Changed: i: i@last -> i@last + 1; v: v@last -> (v@last. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int m){\n  int l, i, v;\n\n  l=b+14;\n  i=0;\n  v=4;\n\n  \n  /*@\n\n    loop invariant l == \\at(b, Pre) + 14;\n\n\n    loop invariant i >= 0;\n\n    loop invariant v >= 4;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant l == b + 14;\n\n\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre);\n\n    loop invariant l <= 0 || i <= l;\n\n    loop invariant v % 2 == 0;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant v >= 0;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v*v+v;\n      v = v+v;\n      if (v+4<l) {\n          v = v*v+v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n,int q){\n  int l, i, v, k, x;\n\n  l=n+18;\n  i=0;\n  v=a;\n  k=i;\n  x=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      k = k+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (x == \\at(n, Pre) + 18) && (k == 0) && (v == \\at(a, Pre)) && (i == 0) && (l == \\at(n, Pre) + 18) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      k = k+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; k: k@last -> k@last + (v@last + 1; v: v@last -> v@last + 1. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; n keeps n@last; q keeps q@last; x keeps x@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n,int q){\n  int l, i, v, k, x;\n\n  l=n+18;\n  i=0;\n  v=a;\n  k=i;\n  x=l;\n\n  \n  /*@\n\n    loop invariant v == a + i;\n\n    loop invariant k == i*a + i*(i+1)/2;\n\n    loop invariant 0 <= i;\n\n    loop invariant (i <= l) || (l < 0);\n\n    loop invariant l == n + 18;\n\n    loop invariant k == i * a + (i * (i + 1)) / 2;\n\n\n    loop invariant a == \\at(a,Pre);\n\n    loop invariant l == \\at(n,Pre) + 18;\n\n\n    loop invariant k == i*(a+1) + i*(i-1)/2;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant l == \\at(n, Pre) + 18;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns v, k, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      k = k+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int p){\n  int l, i, v;\n\n  l=(a%33)+15;\n  i=0;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      v = v%7;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(a, Pre)) && (i == 0) && (l == \\at(a, Pre) % 33 + 15) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      v = v%7;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2 % 7). Changed: i: i@last -> i@last + 1. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int p){\n  int l, i, v;\n\n  l=(a%33)+15;\n  i=0;\n  v=a;\n\n  \n  /*@\n\n    loop invariant 0 <= i;\n\n\n\n    loop invariant l == (\\at(a, Pre) % 33) + 15;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre);\n\n    loop invariant l == \\at(a, Pre) % 33 + 15;\n\n    loop invariant i <= l || l <= 0;\n\n    loop invariant l == (a % 33) + 15;\n\n    loop invariant (i == 0) ==> (v == a);\n\n\n    loop invariant a == \\at(a,Pre) && b == \\at(b,Pre) && m == \\at(m,Pre) && p == \\at(p,Pre);\n\n    loop invariant l == (\\at(a,Pre) % 33) + 15;\n\n\n    loop invariant i >= 0;\n\n    loop invariant l == ((\\at(a, Pre) % 33) + 15);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v*2;\n      v = v%7;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int n){\n  int l, i, v;\n\n  l=33;\n  i=1;\n  v=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      if (i+6<=l+l) {\n          v = v+v;\n      }\n      else {\n          v = v+(-3);\n      }\n      i = i*3;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 5) && (i == 1) && (l == 33) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      if (i+6<=l+l) {\n          v = v+v;\n      }\n      else {\n          v = v+(-3);\n      }\n      i = i*3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 6 > l@last + l@last; i@last < l@last; 3; i@last < l@last; 3). Changed: v: v@last -> v@last + v@last + (v@last + v@last. Unchanged: b keeps b@last; i keeps i@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int n){\n  int l, i, v;\n\n  l=33;\n  i=1;\n  v=5;\n\n  \n  /*@\n\n    loop invariant l == 33;\n\n    loop invariant 1 <= i;\n\n\n    loop invariant i == 1 || i % 3 == 0;\n\n    loop invariant v >= 5;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant i >= 1;\n\n    loop invariant (i < l) ==> (i + 6 <= l + l);\n\n    loop invariant v % 5 == 0;\n\n    loop invariant i > 0;\n\n    loop invariant (i == 1) || (i % 3 == 0);\n\n    loop invariant b == \\at(b,Pre);\n\n    loop invariant k == \\at(k,Pre);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant n == \\at(n,Pre);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+v;\n      if (i+6<=l+l) {\n          v = v+v;\n      }\n      else {\n          v = v+(-3);\n      }\n      i = i*3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 0) && (l == 34) && (q == \\at(q, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last - v@last. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 34;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v == 0;\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant 0 <= i && i <= l;\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && k == \\at(k, Pre) && q == \\at(q, Pre);\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int q){\n  int l, i, v, b, p;\n\n  l=k-1;\n  i=l;\n  v=k;\n  b=-1;\n  p=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      b = b+v;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (p == -5) && (b == -1) && (v == \\at(k, Pre)) && (i == \\at(k, Pre) - 1) && (l == \\at(k, Pre) - 1) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      b = b+v;\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; 2; 2). Changed: b: b@last -> b@last + v@last; i: i@last -> i@last / 2. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int q){\n  int l, i, v, b, p;\n\n  l=k-1;\n  i=l;\n  v=k;\n  b=-1;\n  p=-5;\n\n  \n  /*@\n\n    loop invariant l == k - 1;\n\n    loop invariant i <= l;\n\n    loop invariant v >= k;\n\n    loop invariant b == 2*v - 2*k - 1;\n\n    loop invariant i <= k - 1;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n\n    loop invariant i <= \\at(k,Pre) - 1;\n\n    loop invariant (\\at(k,Pre) > 0) ==> i >= 0;\n\n    loop invariant (\\at(k,Pre) >= 0) ==> v >= \\at(k,Pre);\n\n    loop invariant (\\at(k,Pre) <= 0) ==> v <= \\at(k,Pre);\n\n    loop invariant (\\at(k,Pre) >= 0) ==> b >= -1;\n\n    loop invariant (\\at(k,Pre) <= 0) ==> b <= -1;\n\n    loop assigns v, b, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v*2;\n      b = b+v;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int p,int q){\n  int l, i, v;\n\n  l=q;\n  i=l;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(k, Pre)) && (i == \\at(q, Pre)) && (l == \\at(q, Pre)) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; 2). Changed: i: i@last -> i@last / 2. Unchanged: k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int p,int q){\n  int l, i, v;\n\n  l=q;\n  i=l;\n  v=k;\n\n  \n  /*@\n\n    loop invariant l == \\at(q, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n\n    loop invariant k == \\at(k, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n\n    loop invariant (k == 0) ==> (v == 0);\n\n\n    loop invariant (\\at(q, Pre) >= 0) ==> (0 <= i && i <= \\at(q, Pre));\n\n    loop invariant (\\at(q, Pre) <= 0) ==> (\\at(q, Pre) <= i && i <= 0);\n\n\n    loop invariant i <= \\at(q, Pre);\n\n\n    loop invariant (\\at(k, Pre) <= 0) ==> v * i >= \\at(k, Pre) * \\at(q, Pre);\n\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v*2;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int n){\n  int l, i, v, j;\n\n  l=52;\n  i=0;\n  v=i;\n  j=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+j+j;\n      v = v+1;\n      j = j+2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (j == 2) && (v == 0) && (i == 0) && (l == 52) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+j+j;\n      v = v+1;\n      j = j+2;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; j: j@last -> j@last + 2; v: v@last -> v@last + j@last + j@last + 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'j', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int n){\n  int l, i, v, j;\n\n  l=52;\n  i=0;\n  v=i;\n  j=2;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant 0 <= i;\n\n    loop invariant l == 52;\n\n    loop invariant j == 2 + 2*i;\n\n    loop invariant v == 2*i*i + 3*i;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre);\n\n    loop invariant j == 2*i + 2;\n\n    loop assigns v, j, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+j+j;\n      v = v+1;\n      j = j+2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int p){\n  int l, i, v;\n\n  l=74;\n  i=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      v = v+k;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(k, Pre)) && (i == 0) && (l == 74) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      v = v+k;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + i@last + k@last. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int p){\n  int l, i, v;\n\n  l=74;\n  i=0;\n  v=k;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant l == 74;\n\n    loop invariant v == \\at(k, Pre) * (i + 1) + i * (i - 1) / 2;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant v == \\at(k, Pre) * (1 + i) + i * (i - 1) / 2;\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant v == k*(i+1) + i*(i-1)/2;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+i;\n      v = v+k;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v, b;\n\n  l=12;\n  i=l;\n  v=n;\n  b=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+b+b;\n      v = v+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (b == -1) && (v == \\at(n, Pre)) && (i == 12) && (l == 12) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+b+b;\n      v = v+1;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + b@last + b@last + 1. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v, b;\n\n  l=12;\n  i=l;\n  v=n;\n  b=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= 12;\n    loop invariant i >= 0;\n    loop invariant l == 12;\n    loop invariant b == -1;\n    loop invariant v == n + (12 - i) * (2*b + 1);\n    loop invariant v - i == n - 12;\n    loop invariant a == \\at(a, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant v == n - 12 + i;\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant v == n + i - 12;\n    loop invariant v >= n - 12;\n    loop invariant v <= n;\n    loop invariant i <= l;\n    loop invariant v == n + i - l;\n    loop assigns v, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+b+b;\n      v = v+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int n){\n  int l, i, v, f, c;\n\n  l=(k%7)+12;\n  i=0;\n  v=5;\n  f=i;\n  c=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (c == \\at(k, Pre)) && (f == 0) && (v == 5) && (i == 0) && (l == \\at(k, Pre) % 7 + 12) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2). Changed: i: i@last -> i@last + 1. Unchanged: a keeps a@last; b keeps b@last; c keeps c@last; f keeps f@last; k keeps k@last; l keeps l@last; n keeps n@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int n){\n  int l, i, v, f, c;\n\n  l=(k%7)+12;\n  i=0;\n  v=5;\n  f=i;\n  c=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant l == (\\at(k, Pre) % 7) + 12;\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant 0 <= i <= l;\n    loop invariant 0 <= i && i <= l;\n    loop invariant l == (k % 7) + 12;\n    loop invariant v % 5 == 0;\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v*2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int p){\n  int l, i, v, u, t;\n\n  l=20;\n  i=1;\n  v=-1;\n  u=a;\n  t=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+u+t;\n      v = v+1;\n      i = i*2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (t == \\at(m, Pre)) && (u == \\at(a, Pre)) && (v == -1) && (i == 1) && (l == 20) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+u+t;\n      v = v+1;\n      i = i*2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2). Changed: v: v@last -> v@last + u@last + t@last + 1. Unchanged: a keeps a@last; i keeps i@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last; t keeps t@last; u keeps u@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'p', 't', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int p){\n  int l, i, v, u, t;\n\n  l=20;\n  i=1;\n  v=-1;\n  u=a;\n  t=m;\n\n\n/*@\n\n  loop invariant a == \\at(a, Pre);\n\n  loop invariant k == \\at(k, Pre);\n\n  loop invariant m == \\at(m, Pre);\n\n  loop invariant p == \\at(p, Pre);\n\n  loop invariant u == a;\n\n  loop invariant t == m;\n\n  loop invariant l == 20;\n\n  loop invariant i >= 1;\n\n\n  loop invariant i <= 2 * l;\n\n\n  loop invariant (i == 1) ==> (v == -1);\n\n  loop assigns v, i;\n\n  loop variant l - i;\n\n*/\nwhile (i<l) {\n      v = v+u+t;\n      v = v+1;\n      i = i*2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n,int p){\n  int l, i, v, x;\n\n  l=13;\n  i=1;\n  v=-3;\n  x=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      x = x+v;\n      i = i*2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (x == \\at(b, Pre)) && (v == -3) && (i == 1) && (l == 13) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      x = x+v;\n      i = i*2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2; 2; 2). Changed: x: x@last -> x@last + v@last. Unchanged: a keeps a@last; b keeps b@last; i keeps i@last; l keeps l@last; n keeps n@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'n', 'p', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n,int p){\n  int l, i, v, x;\n\n  l=13;\n  i=1;\n  v=-3;\n  x=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == -3*i;\n    loop invariant x == b - 6*i + 6;\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant v == -3 * i;\n    loop invariant x == b - 6 * i + 6;\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n    loop invariant l == 13;\n    loop invariant i >= 1;\n    loop invariant i <= 2*l;\n    loop invariant x == \\at(b, Pre) - 6 * i + 6;\n    loop invariant x == b - 6 * (i - 1);\n    loop invariant i > 0;\n    loop assigns v, x, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v*2;\n      x = x+v;\n      i = i*2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int q){\n  int l, i, v, g, n;\n\n  l=m-5;\n  i=0;\n  v=l;\n  g=3;\n  n=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (n == \\at(b, Pre)) && (g == 3) && (v == \\at(m, Pre) - 5) && (i == 0) && (l == \\at(m, Pre) - 5) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 3. Unchanged: a keeps a@last; b keeps b@last; g keeps g@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int q){\n  int l, i, v, g, n;\n\n  l=m-5;\n  i=0;\n  v=l;\n  g=3;\n  n=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && m == \\at(m, Pre) && q == \\at(q, Pre);\n    loop invariant l == \\at(m, Pre) - 5;\n    loop invariant v == l + 3*i;\n    loop invariant i >= 0;\n\n    loop invariant l == m - 5;\n    loop invariant v >= l;\n    loop invariant 0 <= i;\n    loop invariant i <= l || l < 0;\n\n    loop invariant a == \\at(a, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+3;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n,int q){\n  int l, i, v, j;\n\n  l=65;\n  i=0;\n  v=k;\n  j=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      j = j+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (j == 8) && (v == \\at(k, Pre)) && (i == 0) && (l == 65) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      j = j+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2; 2). Changed: i: i@last -> i@last + 1; j: j@last -> j@last + v@last. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; n keeps n@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'j', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n,int q){\n  int l, i, v, j;\n\n  l=65;\n  i=0;\n  v=k;\n  j=8;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant l == 65;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant j - 8 == 2*(v - k);\n\n\n    loop invariant 0 <= i <= l;\n\n\n    loop invariant j == 8 - 2*k + 2*v;\n\n    loop assigns i, v, j;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v*2;\n      j = j+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int p){\n  int l, i, v, u;\n\n  l=9;\n  i=l;\n  v=8;\n  u=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      u = u-1;\n      v = v+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      u = u-1;\n      v = v+1;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'p', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int p){\n  int l, i, v, u;\n\n  l=9;\n  i=l;\n  v=8;\n  u=-5;\n\n  \n  /*@\n\n    loop invariant v + 2*i == 26;\n\n    loop invariant u == i - 14;\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v - 2*(l - i) == 8;\n\n    loop invariant u == i - l - 5;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant v == 26 - 2*i;\n\n    loop invariant k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop assigns v, u, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+1;\n      u = u-1;\n      v = v+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int p){\n  int l, i, v, z;\n\n  l=76;\n  i=l;\n  v=-3;\n  z=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (z == \\at(k, Pre)) && (v == -3) && (i == 76) && (l == 76) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last; z keeps z@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int p){\n  int l, i, v, z;\n\n  l=76;\n  i=l;\n  v=-3;\n  z=k;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= 76;\n\n    loop invariant v == 73 - i;\n\n    loop invariant l == 76;\n\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre);\n\n    loop invariant i + v == l - 3;\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant v + i == l - 3;\n\n    loop invariant v + i == 73;\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n,int p){\n  int l, i, v, x, q;\n\n  l=(k%38)+20;\n  i=0;\n  v=k;\n  x=p;\n  q=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      x = x+q;\n      q = q+v;\n      v = v+q;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (q == \\at(k, Pre) % 38 + 20) && (x == \\at(p, Pre)) && (v == \\at(k, Pre)) && (i == 0) && (l == \\at(k, Pre) % 38 + 20) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      x = x+q;\n      q = q+v;\n      v = v+q;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; q: q@last -> q@last + v@last; v: v@last -> v@last + (q@last + v@last; x: x@last -> x@last + q@last. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'p', 'q', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n,int p){\n  int l, i, v, x, q;\n\n  l=(k%38)+20;\n  i=0;\n  v=k;\n  x=p;\n  q=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n\n    loop invariant l == (\\at(k,Pre) % 38) + 20;\n    loop invariant a == \\at(a,Pre);\n    loop invariant k == \\at(k,Pre);\n    loop invariant n == \\at(n,Pre);\n    loop invariant p == \\at(p,Pre);\n    loop invariant l == ((\\at(k, Pre) % 38) + 20);\n    loop invariant k == \\at(k, Pre);\n    loop invariant a == \\at(a, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant v - q - x == k - l - p;\n    loop invariant l == (k % 38) + 20;\n    loop invariant (l < 0) || (i <= l);\n    loop invariant 0 <= i;\n    loop assigns i, x, q, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      x = x+q;\n      q = q+v;\n      v = v+q;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int q){\n  int l, i, v, j;\n\n  l=35;\n  i=l;\n  v=l;\n  j=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+5;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (j == \\at(a, Pre)) && (v == 35) && (i == 35) && (l == 35) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+5;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + 5. Unchanged: a keeps a@last; b keeps b@last; j keeps j@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int q){\n  int l, i, v, j;\n\n  l=35;\n  i=l;\n  v=l;\n  j=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= 35;\n    loop invariant v == 210 - 5*i;\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant l == 35;\n    loop invariant i <= l;\n    loop invariant v == l + 5*(l - i);\n    loop invariant q == \\at(q, Pre);\n    loop invariant v + 5*i == 210;\n    loop assigns i, v;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+5;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=m-10;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (i+3<=n+l) {\n          v = v*v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(m, Pre) - 10) && (i == 0) && (l == \\at(m, Pre) - 10) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (i+3<=n+l) {\n          v = v*v;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 3 > n@last + l@last; i@last < l@last; i@last < l@last; v@last). Changed: i: i@last -> i@last + 1. Unchanged: b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=m-10;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == m - 10;\n    loop invariant (l < 0) || (i <= l);\n    loop invariant i >= 0;\n\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant 0 <= i;\n    loop invariant v == l || v >= 0;\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      if (i+3<=n+l) {\n          v = v*v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=65;\n  i=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      if (v+3<l) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(q, Pre)) && (i == 0) && (l == 65) && (q == \\at(q, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      if (v+3<l) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last + 1 + 3 >= l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 1 - (v@last + 1. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=65;\n  i=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant 0 <= i <= l;\n   loop invariant l == 65;\n   loop invariant v == 0 || v - i == q;\n   loop invariant (q >= 61) ==> (v == q + i);\n   loop invariant 0 <= i && i <= l;\n\n   loop invariant a == \\at(a, Pre);\n   loop invariant b == \\at(b, Pre);\n   loop invariant k == \\at(k, Pre);\n   loop invariant q == \\at(q, Pre);\n   loop invariant 0 <= i;\n   loop invariant i <= l;\n   loop assigns v, i;\n   loop variant l - i;\n */\nwhile (i<l) {\n      v = v+1;\n      if (v+3<l) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int p){\n  int l, i, v, r;\n\n  l=30;\n  i=0;\n  v=-8;\n  r=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      i = i+4;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (r == 0) && (v == -8) && (i == 0) && (l == 30) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      i = i+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 4; v: v@last -> v@last + 1. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; p keeps p@last; r keeps r@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int p){\n  int l, i, v, r;\n\n  l=30;\n  i=0;\n  v=-8;\n  r=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant i == 4*v + 32;\n   loop invariant l == 30;\n   loop invariant i >= 0;\n   loop invariant a == \\at(a, Pre);\n   loop invariant b == \\at(b, Pre);\n   loop invariant m == \\at(m, Pre);\n   loop invariant p == \\at(p, Pre);\n   loop invariant i - 4*v == 32;\n\n   loop invariant 4*(v + 8) == i;\n   loop invariant i % 4 == 0;\n   loop invariant 0 <= i && i <= l + 3;\n   loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre);\n   loop invariant i == 4*(v + 8);\n   loop invariant -8 <= v <= 0;\n   loop invariant 0 <= i;\n   loop assigns i, v;\n   loop variant l - i;\n */\nwhile (i<l) {\n      v = v+1;\n      i = i+4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int p,int q){\n  int l, i, v, s;\n\n  l=29;\n  i=l;\n  v=8;\n  s=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+s+s;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (s == \\at(q, Pre)) && (v == 8) && (i == 29) && (l == 29) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+s+s;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + s@last + s@last. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last; s keeps s@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'p', 'q', 's', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int p,int q){\n  int l, i, v, s;\n\n  l=29;\n  i=l;\n  v=8;\n  s=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant i >= 0;\n   loop invariant i <= l;\n   loop invariant v == 8 + (l - i) * 2 * s;\n   loop invariant s == q;\n   loop invariant l == 29;\n   loop invariant v == 8 + 2*s*(29 - i);\n   loop invariant s == \\at(q, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n   loop invariant i <= 29;\n   loop invariant k == \\at(k, Pre);\n   loop invariant m == \\at(m, Pre);\n   loop invariant p == \\at(p, Pre);\n   loop invariant q == \\at(q, Pre);\n   loop invariant v == 8 + 2*s*(l - i);\n   loop invariant i >= 0 && i <= 29;\n   loop invariant v + 2*s*i == 8 + 58*s;\n   loop assigns i, v;\n */\nwhile (i>0) {\n      v = v+s+s;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int q){\n  int l, i, v;\n\n  l=77;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+l;\n      i = i+5;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(m, Pre)) && (i == 0) && (l == 77) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+l;\n      i = i+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 5; v: v@last -> v@last + l@last. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int q){\n  int l, i, v;\n\n  l=77;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == m + (i/5)*l;\n    loop invariant i % 5 == 0;\n    loop invariant i >= 0;\n    loop invariant l == 77;\n    loop invariant b == \\at(b,Pre);\n    loop invariant k == \\at(k,Pre);\n    loop invariant m == \\at(m,Pre);\n    loop invariant q == \\at(q,Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant v == m + (i/5) * l;\n    loop invariant v == m + l * (i / 5);\n    loop invariant i <= l + 3;\n    loop invariant 5*(v - m) == i*l;\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+l;\n      i = i+5;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int p){\n  int l, i, v;\n\n  l=65;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*v;\n      v = v*v+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 65) && (i == 65) && (l == 65) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*v;\n      v = v*v+v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; v@last; v@last; v@last) + v@last; v@last). Changed: i: i@last -> i@last - 1. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int p){\n  int l, i, v;\n\n  l=65;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= 65;\n    loop invariant l == 65;\n    loop invariant a == \\at(a, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant 0 <= i && i <= l;\n    loop invariant v % 65 == 0 && v >= 65;\n    loop invariant a == \\at(a, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n    loop invariant v >= 1;\n    loop invariant v >= l;\n    loop invariant 0 <= i <= 65;\n    loop assigns v, i;\n  */\nwhile (i>0) {\n      v = v*v;\n      v = v*v+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int n){\n  int l, i, v, e;\n\n  l=16;\n  i=0;\n  v=i;\n  e=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+e;\n      e = e+e;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (e == \\at(m, Pre)) && (v == 0) && (i == 0) && (l == 16) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+e;\n      e = e+e;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: e: e@last -> e@last + e@last; i: i@last -> i@last + 1; v: v@last -> v@last + e@last. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'e', 'i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int n){\n  int l, i, v, e;\n\n  l=16;\n  i=0;\n  v=i;\n  e=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant i <= l;\n    loop invariant e == v + m;\n    loop invariant 0 <= i <= l;\n    loop invariant l == 16;\n    loop invariant e * m >= 0;\n    loop invariant 0 <= i;\n    loop invariant i >= 0;\n    loop assigns v, e, i;\n    loop variant (l - i);\n  */\n  while (i<l) {\n      v = v+e;\n      e = e+e;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int m){\n  int l, i, v, g;\n\n  l=(k%14)+18;\n  i=0;\n  v=l;\n  g=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      g = g+v;\n      v = v+6;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (g == \\at(m, Pre)) && (v == \\at(k, Pre) % 14 + 18) && (i == 0) && (l == \\at(k, Pre) % 14 + 18) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      g = g+v;\n      v = v+6;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: g: g@last -> g@last + (v@last + 1; i: i@last -> i@last + 1; v: v@last -> v@last + 1 + 6. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'g', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int m){\n  int l, i, v, g;\n\n  l=(k%14)+18;\n  i=0;\n  v=l;\n  g=m;\n\n  \n  /*@\n\n    loop invariant v == (\\at(k, Pre) % 14 + 18) + 7 * i;\n\n    loop invariant g == \\at(m, Pre) + i * (\\at(k, Pre) % 14 + 19) + (7 * i * (i - 1)) / 2;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant l == (\\at(k, Pre) % 14 + 18);\n\n    loop invariant k == \\at(k, Pre) && m == \\at(m, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant v == l + 7*i;\n\n    loop invariant g == \\at(m, Pre) + i*(l+1) + 7*i*(i-1)/2;\n\n    loop invariant l == (\\at(k, Pre) % 14) + 18;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant g == m + i*(l + 1) + 7*(i*(i - 1)/2);\n\n    loop invariant g == m + i*(l+1) + 7*i*(i-1)/2;\n\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant g == m + i*(l+1) + 7*(i*(i-1))/2;\n\n    loop invariant l == (k % 14) + 18;\n\n    loop assigns i, v, g;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      g = g+v;\n      v = v+6;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int n){\n  int l, i, v, r;\n\n  l=66;\n  i=l;\n  v=-1;\n  r=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      r = r-1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (r == -5) && (v == -1) && (i == 66) && (l == 66) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      r = r-1;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; r: r@last -> r@last - 1; v: v@last -> v@last + 1. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'n', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int n){\n  int l, i, v, r;\n\n  l=66;\n  i=l;\n  v=-1;\n  r=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant i >= 0;\n   loop invariant v + i == 65;\n   loop invariant r == i - 71;\n   loop invariant b == \\at(b, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre);\n   loop invariant v == 65 - i;\n   loop invariant i <= 66;\n   loop invariant l == 66;\n   loop invariant b == \\at(b, Pre);\n   loop invariant k == \\at(k, Pre);\n   loop invariant m == \\at(m, Pre);\n   loop invariant n == \\at(n, Pre);\n   loop invariant i + v == 65;\n   loop invariant v + r == -6;\n   loop invariant 0 <= i && i <= 66;\n   loop assigns i, v, r;\n   loop variant i;\n */\nwhile (i>0) {\n      v = v+1;\n      r = r-1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int q){\n  int l, i, v, n, z;\n\n  l=(a%23)+16;\n  i=0;\n  v=b;\n  n=i;\n  z=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v+v;\n      v = v%9;\n      n = n*z;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (z == \\at(q, Pre)) && (n == 0) && (v == \\at(b, Pre)) && (i == 0) && (l == \\at(a, Pre) % 23 + 16) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v+v;\n      v = v%9;\n      n = n*z;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last + v@last) % 9; z@last). Changed: i: i@last -> i@last + 1; v: v@last -> (v@last. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last; z keeps z@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'n', 'q', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int q){\n  int l, i, v, n, z;\n\n  l=(a%23)+16;\n  i=0;\n  v=b;\n  n=i;\n  z=q;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant (i <= l) || (l < 0);\n\n    loop invariant n == 0;\n\n    loop invariant l == ((\\at(a,Pre) % 23) + 16);\n\n    loop invariant l == (a % 23) + 16;\n\n\n    loop invariant (i > 0) ==> (0 <= v && v <= 8);\n\n    loop invariant l == (\\at(a, Pre) % 23) + 16;\n\n    loop invariant z == \\at(q, Pre);\n\n\n    loop invariant z == q;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop assigns v, n, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v*v+v;\n      v = v%9;\n      n = n*z;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int p){\n  int l, i, v;\n\n  l=25;\n  i=l;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      if (b<m+4) {\n          v = v+i;\n      }\n      v = m-(-3);\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 25) && (i == 25) && (l == 25) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      if (b<m+4) {\n          v = v+i;\n      }\n      v = m-(-3);\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (b@last < m@last + 4; i@last > 0; i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> m@last - -3. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int p){\n  int l, i, v;\n\n  l=25;\n  i=l;\n  v=l;\n\n  \n  /*@\n\n    loop invariant l == 25;\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant (i == l && v == l) || (i < l && v == m+3);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant i <= 25;\n\n    loop invariant (i < 25) ==> v == m + 3;\n\n    loop invariant m == \\at(m, Pre) && a == \\at(a, Pre) && b == \\at(b, Pre) && p == \\at(p, Pre);\n\n    loop invariant (i == l && v == l) || (i < l && v == m + 3);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant (i == l) ==> v == l;\n\n    loop invariant (i < l) ==> v == m + 3;\n\n    loop invariant a == \\at(a, Pre) && p == \\at(p, Pre);\n\n    loop invariant b == \\at(b, Pre) && m == \\at(m, Pre);\n\n    loop assigns i, v;\n\n  */\n  while (i>0) {\n      if (b<m+4) {\n          v = v+i;\n      }\n      v = m-(-3);\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int n){\n  int l, i, v;\n\n  l=m-2;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(m, Pre)) && (i == 0) && (l == \\at(m, Pre) - 2) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 1 + i@last. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int n){\n  int l, i, v;\n\n  l=m-2;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == m + i*(i+1)/2;\n    loop invariant 0 <= i;\n    loop invariant l == m - 2;\n    loop invariant (l >= 0) ==> (0 <= i && i <= l);\n    loop invariant v == m + (i * (i + 1)) / 2;\n\n    loop invariant b == \\at(b, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = v+1;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=a;\n  i=l;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+i;\n      v = v*2;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(a, Pre)) && (i == \\at(a, Pre)) && (l == \\at(a, Pre)) && (q == \\at(q, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+i;\n      v = v*2;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; 2). Changed: i: i@last -> i@last - 1; v: v@last -> (v@last + i@last. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=a;\n  i=l;\n  v=l;\n\n  \n  /*@\n\n    loop invariant l == \\at(a, Pre);\n\n\n    loop invariant (i == l) ==> v == l;\n\n    loop invariant (i < l) ==> v % 2 == 0;\n\n    loop invariant v >= \\at(a, Pre);\n\n    loop invariant l == a;\n\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && k == \\at(k, Pre) && q == \\at(q, Pre);\n\n    loop invariant l == \\at(a,Pre);\n\n    loop invariant i <= l;\n\n\n    loop invariant v >= \\at(a,Pre);\n\n    loop invariant l - i >= 0;\n\n\n    loop invariant i <= a;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v+i;\n      v = v*2;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int p){\n  int l, i, v, w;\n\n  l=52;\n  i=l;\n  v=5;\n  w=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      w = w+v;\n      w = w+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (w == 3) && (v == 5) && (i == 52) && (l == 52) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      w = w+v;\n      w = w+1;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + 1; w: w@last -> w@last + (v@last + 1) + 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'p', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int p){\n  int l, i, v, w;\n\n  l=52;\n  i=l;\n  v=5;\n  w=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i + v == 57;\n    loop invariant w == 3 + (52 - i) * 7 + (52 - i) * (51 - i) / 2;\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre);\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant l == 52;\n    loop invariant v == 57 - i;\n    loop invariant 2*w == v*v + 3*v - 34;\n    loop invariant v + i == 57;\n    loop invariant 0 <= i <= 52;\n    loop invariant 5 <= v <= 57;\n    loop invariant 3 <= w <= 1693;\n    loop invariant w == (i*i - 117*i + 3386)/2;\n    loop assigns v, w, i;\n  */\n  while (i>0) {\n      v = v+1;\n      w = w+v;\n      w = w+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int q){\n  int l, i, v, g;\n\n  l=31;\n  i=l;\n  v=q;\n  g=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+g;\n      g = g+g;\n      g = g+3;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (g == \\at(k, Pre)) && (v == \\at(q, Pre)) && (i == 31) && (l == 31) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+g;\n      g = g+g;\n      g = g+3;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: g: g@last -> g@last + g@last + 3; i: i@last -> i@last - 1; v: v@last -> v@last + g@last. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'g', 'i', 'k', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int q){\n  int l, i, v, g;\n\n  l=31;\n  i=l;\n  v=q;\n  g=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant -v + g + 3*i == \\at(k, Pre) - \\at(q, Pre) + 93;\n   loop invariant b == \\at(b, Pre);\n   loop invariant k == \\at(k, Pre);\n   loop invariant m == \\at(m, Pre);\n   loop invariant q == \\at(q, Pre);\n   loop invariant 0 <= i;\n   loop invariant i <= 31;\n   loop invariant l == 31;\n   loop invariant i >= 0;\n   loop invariant g - v + 3*i == \\at(k, Pre) - \\at(q, Pre) + 93;\n   loop invariant 0 <= i <= 31;\n   loop invariant k == \\at(k,Pre);\n   loop invariant b == \\at(b,Pre);\n   loop invariant m == \\at(m,Pre);\n   loop invariant q == \\at(q,Pre);\n   loop assigns v, g, i;\n   loop variant i;\n */\nwhile (i>0) {\n      v = v+g;\n      g = g+g;\n      g = g+3;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p,int q){\n  int l, i, v, h;\n\n  l=(a%9)+15;\n  i=0;\n  v=a;\n  h=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      h = h+h;\n      h = h+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (h == 0) && (v == \\at(a, Pre)) && (i == 0) && (l == \\at(a, Pre) % 9 + 15) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      h = h+h;\n      h = h+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: h: h@last -> h@last + h@last + v@last; i: i@last -> i@last + 1. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'h', 'i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p,int q){\n  int l, i, v, h;\n\n  l=(a%9)+15;\n  i=0;\n  v=a;\n  h=i;\n\n  \n  /*@\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant l == (a % 9) + 15;\n\n    loop invariant v == a;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant h * v >= 0;\n\n    loop invariant l == (\\at(a, Pre) % 9) + 15;\n\n    loop invariant i >= 0;\n\n\n    loop invariant (v == 0) ==> (h == 0);\n\n    loop assigns h, i;\n\n  */\n  while (i<l) {\n      h = h+h;\n      h = h+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p,int q){\n  int l, i, v;\n\n  l=11;\n  i=l;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v-q;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 2) && (i == 11) && (l == 11) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v-q;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last - q@last. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p,int q){\n  int l, i, v;\n\n  l=11;\n  i=l;\n  v=2;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= 11;\n\n    loop invariant l == 11;\n\n    loop invariant v == 2 - (11 - i) * q;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant v == 2 - q * (l - i);\n\n    loop invariant v == 2 - (l - i) * q;\n\n    loop invariant i <= 11;\n\n    loop invariant v + (11 - i) * q == 2;\n\n    loop assigns v, i;\n\n  */\n  while (i>0) {\n      v = v-q;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p,int q){\n  int l, i, v, r;\n\n  l=47;\n  i=0;\n  v=8;\n  r=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+2;\n      r = r+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (r == \\at(n, Pre)) && (v == 8) && (i == 0) && (l == 47) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+2;\n      r = r+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; r: r@last -> r@last + (v@last + 2; v: v@last -> v@last + 2. Unchanged: l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'p', 'q', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p,int q){\n  int l, i, v, r;\n\n  l=47;\n  i=0;\n  v=8;\n  r=n;\n\n  \n  /*@\n\n    loop invariant v == 8 + 2*i;\n\n    loop invariant r == n + i*i + 9*i;\n\n    loop invariant i <= l;\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant l == 47;\n\n    loop invariant r == n + i*(i+9);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant r == \\at(n, Pre) + i*i + 9*i;\n\n    loop assigns i, v, r;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+2;\n      r = r+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int p){\n  int l, i, v;\n\n  l=31;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 4) && (i == 0) && (l == 31) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + v@last. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int p){\n  int l, i, v;\n\n  l=31;\n  i=0;\n  v=4;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant a == \\at(a, Pre) &&\n                 k == \\at(k, Pre) &&\n                 m == \\at(m, Pre) &&\n                 p == \\at(p, Pre) &&\n                 l == 31 &&\n                 0 <= i &&\n                 i <= l;\n\n    loop invariant l == 31;\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant v % 4 == 0;\n\n    loop invariant v >= 4;\n\n    loop invariant v % 2 == 0;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int q){\n  int l, i, v, w, n;\n\n  l=k-2;\n  i=0;\n  v=q;\n  w=k;\n  n=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+w+n;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (n == 8) && (w == \\at(k, Pre)) && (v == \\at(q, Pre)) && (i == 0) && (l == \\at(k, Pre) - 2) && (q == \\at(q, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+w+n;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + w@last + n@last. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; n keeps n@last; q keeps q@last; w keeps w@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'n', 'q', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int q){\n  int l, i, v, w, n;\n\n  l=k-2;\n  i=0;\n  v=q;\n  w=k;\n  n=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant l == k - 2;\n    loop invariant w == k;\n    loop invariant n == 8;\n    loop invariant v == q + i*(k + n);\n    loop invariant v == q + i*(k+8);\n    loop invariant i <= l || l < 0;\n    loop invariant v == q + i*(w + n);\n    loop invariant k == \\at(k, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant a == \\at(a, Pre);\n    loop invariant v == \\at(q, Pre) + i*(w + n);\n\n    loop assigns v, i;\n  */\n  while (i<l) {\n      v = v+w+n;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+5;\n      v = v+6;\n      if ((i%3)==0) {\n          v = v+v;\n      }\n      i = i+3;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 34) && (i == 0) && (l == 34) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+5;\n      v = v+6;\n      if ((i%3)==0) {\n          v = v+v;\n      }\n      i = i+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 3 != 0; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 3; v: v@last -> v@last + 5 + 6 + (v@last + 5 + 6. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i % 3 == 0;\n    loop invariant i <= l + 2;\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant v % 2 == 0;\n    loop invariant v >= 34;\n    loop invariant k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n    loop invariant l == 34;\n    loop invariant (i % 3 == 0);\n    loop invariant (i >= 0);\n    loop invariant (v >= 34);\n    loop invariant (k == \\at(k, Pre));\n    loop invariant (m == \\at(m, Pre));\n    loop invariant (n == \\at(n, Pre));\n    loop assigns i, v;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      v = v+5;\n      v = v+6;\n      if ((i%3)==0) {\n          v = v+v;\n      }\n      i = i+3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int n){\n  int l, i, v;\n\n  l=n-2;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 0) && (l == \\at(n, Pre) - 2) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last - v@last + i@last. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int n){\n  int l, i, v;\n\n  l=n-2;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n\n    loop invariant (i == 0) ==> (v == 0);\n    loop invariant (i > 0) ==> (v == i - 1);\n    loop invariant l == n - 2;\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant i >= 0;\n    loop invariant v >= 0;\n    loop invariant v <= i;\n    loop invariant l == \\at(n, Pre) - 2;\n    loop invariant b == \\at(b, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre);\n    loop invariant (i <= l) || (i == 0);\n    loop invariant (b == \\at(b, Pre)) && (k == \\at(k, Pre)) && (m == \\at(m, Pre)) && (n == \\at(n, Pre));\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v-v;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int n){\n  int l, i, v, f, e;\n\n  l=64;\n  i=0;\n  v=n;\n  f=k;\n  e=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+f+e;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (e == 4) && (f == \\at(k, Pre)) && (v == \\at(n, Pre)) && (i == 0) && (l == 64) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+f+e;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + f@last + e@last + 1. Unchanged: a keeps a@last; e keeps e@last; f keeps f@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'e', 'f', 'i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int n){\n  int l, i, v, f, e;\n\n  l=64;\n  i=0;\n  v=n;\n  f=k;\n  e=4;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant v == n + i*(k + 5);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant v == n + i*(f + e + 1);\n\n    loop invariant f == k;\n\n    loop invariant l == 64;\n\n    loop invariant v == n + i*(k+5);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant v == \\at(n, Pre) + i*(k + 5);\n\n    loop invariant e == 4;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+f+e;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p,int q){\n  int l, i, v;\n\n  l=52;\n  i=1;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v;\n      v = v*v+v;\n      i = i*2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -1) && (i == 1) && (l == 52) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v;\n      v = v*v+v;\n      i = i*2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2; v@last; v@last; v@last) + v@last; v@last). Unchanged: b keeps b@last; i keeps i@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p,int q){\n  int l, i, v;\n\n  l=52;\n  i=1;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 52;\n    loop invariant i <= 2 * l;\n    loop invariant v >= -1;\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i > 0;\n\n    loop invariant v <= v*v;\n    loop invariant (i == 1) ==> (v == -1);\n    loop invariant (i != 1) ==> (v >= 0);\n    loop invariant i >= 1;\n    loop invariant v != 0;\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = v*v;\n      v = v*v+v;\n      i = i*2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int n){\n  int l, i, v;\n\n  l=n-7;\n  i=0;\n  v=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%5)==0) {\n          v = v+4;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -3) && (i == 0) && (l == \\at(n, Pre) - 7) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%5)==0) {\n          v = v+4;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 5 != 0; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 4. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int n){\n  int l, i, v;\n\n  l=n-7;\n  i=0;\n  v=-3;\n\n  \n  /*@\n\n\n    loop invariant l == \\at(n,Pre) - 7;\n\n    loop invariant v == -3 + 4 * ((i + 4) / 5);\n\n    loop invariant i >= 0;\n\n    loop invariant l == \\at(n, Pre) - 7;\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant l == n - 7;\n\n\n    loop invariant (i == 0) ==> (v == -3);\n\n    loop invariant ((v + 3) % 4) == 0;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant i <= l || l < 0;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      if ((i%5)==0) {\n          v = v+4;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n,int p){\n  int l, i, v, f, t;\n\n  l=32;\n  i=0;\n  v=a;\n  f=a;\n  t=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v+v;\n      v = v%7;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (t == 1) && (f == \\at(a, Pre)) && (v == \\at(a, Pre)) && (i == 0) && (l == 32) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v+v;\n      v = v%7;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last + v@last) % 7). Changed: i: i@last -> i@last + 1; v: v@last -> (v@last. Unchanged: a keeps a@last; f keeps f@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last; t keeps t@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n,int p){\n  int l, i, v, f, t;\n\n  l=32;\n  i=0;\n  v=a;\n  f=a;\n  t=1;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant (i == 0) ==> (v == a);\n\n    loop invariant (i > 0) ==> (0 <= v && v <= 6);\n\n    loop invariant l == 32;\n\n    loop invariant i <= l;\n\n    loop invariant 0 <= i;\n\n\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant (i > 0) ==> (0 <= v <= 6);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant i >= 0;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v*v+v;\n      v = v%7;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n,int p){\n  int l, i, v;\n\n  l=66;\n  i=0;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(n, Pre)) && (i == 0) && (l == 66) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + v@last + i@last. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n,int p){\n  int l, i, v;\n\n  l=66;\n  i=0;\n  v=n;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant l == 66;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant 0 <= i;\n\n    loop invariant (i == 0) || ((v + i + 1) % 2 == 0);\n\n    loop invariant k == \\at(k, Pre);\n\n\n    loop invariant 0 <= i <= l;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+v;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int p){\n  int l, i, v, a, r;\n\n  l=51;\n  i=l;\n  v=p;\n  a=k;\n  r=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+a;\n      a = a+r;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (r == 51) && (a == \\at(k, Pre)) && (v == \\at(p, Pre)) && (i == 51) && (l == 51) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+a;\n      a = a+r;\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: a: a@last -> a@last + r@last; i: i@last -> i@last / 2; v: v@last -> v@last + a@last. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last; r keeps r@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'n', 'p', 'r', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int p){\n  int l, i, v, a, r;\n\n  l=51;\n  i=l;\n  v=p;\n  a=k;\n  r=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant k == \\at(k, Pre) && p == \\at(p, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre);\n   loop invariant (a - k) % r == 0;\n   loop invariant v == p + ((a - k) / r) * k + r * ((a - k) / r) * (((a - k) / r) - 1) / 2;\n   loop invariant i >= 0;\n   loop invariant i <= 51;\n   loop invariant a >= k;\n   loop invariant k == \\at(k, Pre);\n   loop invariant m == \\at(m, Pre);\n   loop invariant n == \\at(n, Pre);\n   loop invariant p == \\at(p, Pre);\n   loop invariant l == 51;\n   loop invariant v == p + ((a - k)/r)*k + r * ((a - k)/r) * (((a - k)/r) - 1) / 2;\n   loop invariant r == l;\n   loop invariant i <= l;\n   loop invariant k == \\at(k,Pre);\n   loop invariant m == \\at(m,Pre);\n   loop invariant p == \\at(p,Pre);\n   loop invariant (a - k) % 51 == 0;\n   loop assigns v, a, i;\n */\nwhile (i>0) {\n      v = v+a;\n      a = a+r;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n,int p){\n  int l, i, v, g;\n\n  l=80;\n  i=0;\n  v=b;\n  g=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      g = g*g;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (g == -3) && (v == \\at(b, Pre)) && (i == 0) && (l == 80) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      g = g*g;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; g@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + i@last. Unchanged: b keeps b@last; g keeps g@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'g', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n,int p){\n  int l, i, v, g;\n\n  l=80;\n  i=0;\n  v=b;\n  g=-3;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant v == \\at(b, Pre) + i*(i-1)/2;\n\n    loop invariant (i == 0) ==> (g == -3);\n\n    loop invariant (i > 0) ==> (g >= 0);\n\n    loop invariant l == 80;\n\n    loop invariant i <= l;\n\n    loop invariant v == b + i*(i-1)/2;\n\n    loop invariant (b == \\at(b, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre));\n\n    loop invariant v == b + (i*(i-1))/2;\n\n    loop invariant (i > 0) ==> (g > 0);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop assigns v, g, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+i;\n      g = g*g;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n,int q){\n  int l, i, v;\n\n  l=(q%6)+9;\n  i=0;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(n, Pre)) && (i == 0) && (l == \\at(q, Pre) % 6 + 9) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + v@last + 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n,int q){\n  int l, i, v;\n\n  l=(q%6)+9;\n  i=0;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == (q % 6) + 9;\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant (n == -1) ==> (v == -1);\n\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i >= 0;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant (i == 0) ==> (v == n);\n    loop invariant i <= 14;\n    loop invariant (i > 0) ==> (v % 2 != 0);\n    loop assigns v, i;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      v = v+v;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int n){\n  int l, i, v;\n\n  l=n;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(n, Pre)) && (i == 0) && (l == \\at(n, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last). Changed: i: i@last -> i@last + 1. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int n){\n  int l, i, v;\n\n  l=n;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == \\at(n,Pre);\n    loop invariant 0 <= i;\n\n    loop invariant v >= l;\n    loop invariant (i == 0) ==> (v == l);\n    loop invariant l == n;\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant i == 0 ==> v == n;\n    loop invariant a == \\at(a, Pre) &&\n                   b == \\at(b, Pre) &&\n                   m == \\at(m, Pre) &&\n                   n == \\at(n, Pre);\n    loop invariant (i <= l) || (l < 0);\n    loop invariant m == \\at(m, Pre);\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v*v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int q){\n  int l, i, v;\n\n  l=26;\n  i=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      i = i+2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(q, Pre)) && (i == 0) && (l == 26) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      i = i+2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 2; v: v@last -> v@last + i@last. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int q){\n  int l, i, v;\n\n  l=26;\n  i=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == \\at(q,Pre) + i*(i-2)/4;\n    loop invariant i % 2 == 0;\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant k == \\at(k,Pre);\n    loop invariant l == 26;\n    loop invariant v == q + (i/2) * ((i/2) - 1);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i >= 0;\n    loop invariant i >= 0 && i <= l;\n    loop invariant v == \\at(q, Pre) + (i/2) * ((i/2) - 1);\n    loop assigns v, i;\n  */\n  while (i<l) {\n      v = v+i;\n      i = i+2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n,int p){\n  int l, i, v, g;\n\n  l=13;\n  i=l;\n  v=0;\n  g=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      g = g+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (g == \\at(p, Pre)) && (v == 0) && (i == 13) && (l == 13) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      g = g+v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; 2; 2). Changed: g: g@last -> g@last + v@last; i: i@last -> i@last - 1. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'g', 'i', 'k', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n,int p){\n  int l, i, v, g;\n\n  l=13;\n  i=l;\n  v=0;\n  g=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 0;\n    loop invariant g == \\at(p, Pre);\n    loop invariant 0 <= i <= 13;\n    loop invariant i >= 0;\n    loop invariant i <= 13;\n    loop invariant l == 13;\n    loop invariant g == p;\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant 0 <= i && i <= 13;\n    loop assigns v, g, i;\n  */\n  while (i>0) {\n      v = v*2;\n      g = g+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int p){\n  int l, i, v, c, g;\n\n  l=49;\n  i=0;\n  v=k;\n  c=3;\n  g=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      c = c+v;\n      c = c+3;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (g == 49) && (c == 3) && (v == \\at(k, Pre)) && (i == 0) && (l == 49) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      c = c+v;\n      c = c+3;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: c: c@last -> c@last + (v@last + 1) + 3; i: i@last -> i@last + 1; v: v@last -> v@last + 1. Unchanged: b keeps b@last; g keeps g@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'i', 'k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int p){\n  int l, i, v, c, g;\n\n  l=49;\n  i=0;\n  v=k;\n  c=3;\n  g=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == k + i;\n    loop invariant c == 3 + i*(k+4) + i*(i-1)/2;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant k == \\at(k, Pre);\n    loop invariant c == 3 + i*(k + 3) + i*(i + 1)/2;\n    loop invariant l == 49;\n    loop invariant c == 3 + i*(k + 4) + i*(i - 1)/2;\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant 0 <= i <= l;\n    loop assigns v, c, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      c = c+v;\n      c = c+3;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int p){\n  int l, i, v, d, j;\n\n  l=24;\n  i=l;\n  v=i;\n  d=i;\n  j=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+i;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (j == \\at(m, Pre)) && (d == 24) && (v == 24) && (i == 24) && (l == 24) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+i;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + i@last. Unchanged: d keeps d@last; j keeps j@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int p){\n  int l, i, v, d, j;\n\n  l=24;\n  i=l;\n  v=i;\n  d=i;\n  j=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == l + l*(l - i) - ((l - i)*(l - i - 1))/2;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v >= l;\n    loop invariant i <= 24;\n    loop invariant l == 24;\n    loop invariant v == 24 + (24 - i) * (25 + i) / 2;\n    loop invariant v == 24 + (24 - i) * 24 - ((24 - i) * (23 - i)) / 2;\n    loop invariant v >= 24;\n    loop invariant v <= 324;\n    loop invariant v >= i;\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop assigns v, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+i;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p,int q){\n  int l, i, v;\n\n  l=65;\n  i=l;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v-v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 2) && (i == 65) && (l == 65) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v-v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last - v@last. Unchanged: b keeps b@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p,int q){\n  int l, i, v;\n\n  l=65;\n  i=l;\n  v=2;\n\n  /* >>> LOOP INVARIANTS <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= 65;\n    loop invariant (i == 65) ==> (v == 2);\n    loop invariant l == 65 && b == \\at(b, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n    loop invariant (i == l) ==> (v == 2);\n    loop invariant i <= l;\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant l == 65;\n    loop invariant v == 2 || v == 0;\n    loop assigns i, v;\n  */\n  while (i>0) {\n      v = v-v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n,int q){\n  int l, i, v;\n\n  l=45;\n  i=0;\n  v=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      if (i<l+5) {\n          v = v+v;\n      }\n      else {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -4) && (i == 0) && (l == 45) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      if (i<l+5) {\n          v = v+v;\n      }\n      else {\n          v = v+1;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n,int q){\n  int l, i, v;\n\n  l=45;\n  i=0;\n  v=-4;\n\n  \n  /*@\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v <= -2*i - 4;\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant (v + 2) % 2 == 0;\n\n    loop invariant v <= -2;\n\n    loop invariant b == \\at(b, Pre) && k == \\at(k, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n\n    loop invariant v <= -4 - 2*i;\n\n    loop invariant l == 45;\n\n    loop invariant v <= -4;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      if (i<l+5) {\n          v = v+v;\n      }\n      else {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n,int p){\n  int l, i, v, g;\n\n  l=54;\n  i=l;\n  v=-2;\n  g=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (g == \\at(n, Pre)) && (v == -2) && (i == 54) && (l == 54) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; 2). Changed: i: i@last -> i@last - 1. Unchanged: a keeps a@last; g keeps g@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n,int p){\n  int l, i, v, g;\n\n  l=54;\n  i=l;\n  v=-2;\n  g=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant a == \\at(a, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant i >= 0;\n    loop invariant v % 2 == 0;\n    loop invariant i <= l;\n    loop invariant l == 54;\n    loop invariant v <= -2;\n    loop invariant v < 0;\n    loop invariant i <= 54;\n    loop assigns v, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v*2;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int n){\n  int l, i, v;\n\n  l=57;\n  i=0;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      v = v*v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(b, Pre)) && (i == 0) && (l == 57) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      v = v*v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2; v@last; 2). Changed: i: i@last -> i@last + 1. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; n keeps n@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int n){\n  int l, i, v;\n\n  l=57;\n  i=0;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant l == 57;\n    loop invariant 0 <= i && i <= l;\n    loop invariant (i == 0) ==> (v == b);\n    loop invariant (i > 0) ==> (v >= 0);\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant 0 <= i <= l;\n    loop invariant i == 0 ==> v == \\at(b, Pre);\n    loop invariant i > 0 ==> v >= 0;\n    loop invariant 0 <= i;\n    loop invariant i == 0 ==> v == b;\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = v*2;\n      v = v*v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int p){\n  int l, i, v, o;\n\n  l=59;\n  i=0;\n  v=-3;\n  o=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      o = o+v;\n      if (o+6<l) {\n          o = o+i;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (o == 59) && (v == -3) && (i == 0) && (l == 59) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      o = o+v;\n      if (o+6<l) {\n          o = o+i;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (o@last + (v@last + 1) + 6 >= l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; o: o@last -> o@last + (v@last + 1) + i@last; v: v@last -> v@last + 1. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'o', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int p){\n  int l, i, v, o;\n\n  l=59;\n  i=0;\n  v=-3;\n  o=l;\n\n  \n  /*@\n\n    loop invariant (a == \\at(a, Pre) && b == \\at(b, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre));\n\n    loop invariant v == i - 3;\n\n    loop invariant i <= l;\n\n    loop invariant o >= 56;\n\n    loop invariant i >= 0 && i <= l;\n\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre);\n\n    loop invariant o == l + i*(i+1)/2 - 3*i;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant o >= 59 + (i*i - 7*i)/2;\n\n\n    loop invariant p == \\at(p, Pre) && a == \\at(a, Pre) && b == \\at(b, Pre) && m == \\at(m, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop assigns v, o, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      o = o+v;\n      if (o+6<l) {\n          o = o+i;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n,int q){\n  int l, i, v;\n\n  l=k;\n  i=0;\n  v=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -2) && (i == 0) && (l == \\at(k, Pre)) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      v = v-v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + i@last - (v@last + i@last. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n,int q){\n  int l, i, v;\n\n  l=k;\n  i=0;\n  v=-2;\n\n  \n  /*@\n\n    loop invariant l == \\at(k, Pre);\n\n    loop invariant i >= 0;\n\n\n    loop invariant (i > 0) ==> (v == 0);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant l == k;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant (i <= l) || (l <= 0);\n\n    loop assigns v, i;\n\n  */\n  while (i<l) {\n      v = v+i;\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int p,int q){\n  int l, i, v;\n\n  l=71;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%9)==0) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 0) && (l == 71) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%9)==0) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 9 != 0; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last - v@last. Unchanged: k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int p,int q){\n  int l, i, v;\n\n  l=71;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 0;\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant 0 <= i <= l;\n    loop invariant 0 <= i && i <= l;\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      if ((i%9)==0) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p,int q){\n  int l, i, v, y;\n\n  l=54;\n  i=0;\n  v=l;\n  y=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      y = y+4;\n      v = v+y;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (y == \\at(p, Pre)) && (v == 54) && (i == 0) && (l == 54) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      y = y+4;\n      v = v+y;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 3 + (y@last + 4; y: y@last -> y@last + 4. Unchanged: b keeps b@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'p', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p,int q){\n  int l, i, v, y;\n\n  l=54;\n  i=0;\n  v=l;\n  y=p;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant y == p + 4*i;\n\n    loop invariant v == 54 + i*p + 2*i*i + 5*i;\n\n    loop invariant v == l + i*p + 2*i*i + 5*i;\n\n    loop invariant b == \\at(b, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n\n    loop invariant 0 <= i;\n\n    loop invariant v == 54 + p*i + 2*i*i + 5*i;\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant l == 54;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n\n    loop assigns v, y, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+3;\n      y = y+4;\n      v = v+y;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int q){\n  int l, i, v;\n\n  l=(m%40)+14;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(m, Pre)) && (i == 0) && (l == \\at(m, Pre) % 40 + 14) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + v@last. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int q){\n  int l, i, v;\n\n  l=(m%40)+14;\n  i=0;\n  v=m;\n\n  \n  /*@\n\n    loop invariant 0 <= i;\n\n\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant l == (m % 40) + 14;\n\n    loop invariant (i > 0) ==> (v % 2 == 0);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant l == (\\at(m,Pre) % 40) + 14;\n\n    loop invariant a == \\at(a,Pre);\n\n    loop invariant (l >= 0) ==> (i <= l);\n\n    loop invariant (i == 0) ==> (v == \\at(m, Pre));\n\n    loop invariant n == \\at(n,Pre);\n\n    loop invariant q == \\at(q,Pre);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n,int q){\n  int l, i, v, w;\n\n  l=16;\n  i=0;\n  v=n;\n  w=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+w+w;\n      v = v+1;\n      i = i+4;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (w == 16) && (v == \\at(n, Pre)) && (i == 0) && (l == 16) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+w+w;\n      v = v+1;\n      i = i+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 4; v: v@last -> v@last + w@last + w@last + 1. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; n keeps n@last; q keeps q@last; w keeps w@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'n', 'q', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n,int q){\n  int l, i, v, w;\n\n  l=16;\n  i=0;\n  v=n;\n  w=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant i <= l;\n    loop invariant i % 4 == 0;\n    loop invariant v == \\at(n, Pre) + (i/4) * 33;\n    loop invariant v == n + 33 * (i/4);\n    loop invariant l == 16;\n    loop invariant w == l;\n    loop invariant q == \\at(q, Pre);\n    loop invariant 4*(v - \\at(n, Pre)) == i*(2*w + 1);\n    loop invariant i >= 0;\n    loop invariant v >= \\at(n, Pre);\n    loop invariant v == n + (i/4) * (2*w + 1);\n    loop invariant v == n + 33*(i/4);\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+w+w;\n      v = v+1;\n      i = i+4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=18;\n  i=0;\n  v=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (l<b+2) {\n          v = v+4;\n      }\n      v = v-v;\n      if ((i%9)==0) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(p, Pre)) && (i == 0) && (l == 18) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (l<b+2) {\n          v = v+4;\n      }\n      v = v-v;\n      if ((i%9)==0) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 9 != 0; l@last < b@last + 2; i@last < l@last; l@last >= b@last + 2; i@last < l@last; l@last >= b@last + 2; i@last < l@last; l@last < b@last + 2; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 4 - (v@last + 4) - (v@last + 4 - (v@last + 4. Unchanged: b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=18;\n  i=0;\n  v=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant l == 18;\n    loop invariant (i == 0) ==> (v == p);\n    loop invariant (i > 0) ==> (v == 0);\n    loop invariant p == \\at(p, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant (i >= 1) ==> (v == 0);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant 0 <= i <= l;\n    loop invariant v == 0 || v == p;\n    loop invariant i == 0 ==> v == p;\n    loop invariant 0 <= i && i <= l;\n    loop invariant i > 0 ==> v == 0;\n    loop invariant b == \\at(b, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      if (l<b+2) {\n          v = v+4;\n      }\n      v = v-v;\n      if ((i%9)==0) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int n){\n  int l, i, v, m, r;\n\n  l=47;\n  i=l;\n  v=i;\n  m=a;\n  r=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      m = m+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (r == \\at(b, Pre)) && (m == \\at(a, Pre)) && (v == 47) && (i == 47) && (l == 47) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      m = m+v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; m: m@last -> m@last + (v@last + 1; v: v@last -> v@last + 1. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; n keeps n@last; r keeps r@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int n){\n  int l, i, v, m, r;\n\n  l=47;\n  i=l;\n  v=i;\n  m=a;\n  r=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant i >= 0;\n    loop invariant i <= 47;\n    loop invariant v == 94 - i;\n    loop invariant m == a + (47 - i) * 47 + ((47 - i) * (48 - i)) / 2;\n    loop invariant i + v == 94;\n    loop invariant m == a + (v - 47)*(v + 48)/2;\n    loop invariant v >= 47;\n    loop invariant m == a + 47*(47 - i) + ((47 - i) * (48 - i)) / 2;\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant m == a + (47 - i) * 47 + (47 - i) * (48 - i) / 2;\n    loop invariant m == a + v*(v+1)/2 - 1128;\n    loop assigns v, m, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+1;\n      m = m+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int p,int q){\n  int l, i, v;\n\n  l=b+18;\n  i=0;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 2) && (i == 0) && (l == \\at(b, Pre) + 18) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 1 + (v@last + 1. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int p,int q){\n  int l, i, v;\n\n  l=b+18;\n  i=0;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant v >= 2*i + 2;\n    loop invariant v % 2 == 0;\n    loop invariant l == \\at(b,Pre) + 18;\n\n    loop invariant b == \\at(b,Pre) && k == \\at(k,Pre) && p == \\at(p,Pre) && q == \\at(q,Pre);\n    loop invariant 0 <= i;\n    loop invariant i <= l || l <= 0;\n    loop invariant l == b + 18;\n    loop invariant i >= 0;\n\n    loop invariant v % 4 == 2;\n    loop assigns v, i;\n  */\nwhile (i<l) {\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int p,int q){\n  int l, i, v, x, n;\n\n  l=77;\n  i=l;\n  v=-2;\n  x=b;\n  n=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+x+n;\n      v = v+1;\n      x = x+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (n == 77) && (x == \\at(b, Pre)) && (v == -2) && (i == 77) && (l == 77) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+x+n;\n      v = v+1;\n      x = x+1;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + x@last + n@last + 1; x: x@last -> x@last + 1. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'n', 'p', 'q', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int p,int q){\n  int l, i, v, x, n;\n\n  l=77;\n  i=l;\n  v=-2;\n  x=b;\n  n=l;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i + x == b + 77;\n\n    loop invariant v == -2 + (77 - i) * (b + 78) + ((77 - i) * (76 - i)) / 2;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant x == b + (l - i);\n\n    loop invariant v == -2 + (l - i) * (b + n + 1) + ((l - i) * (l - i - 1)) / 2;\n\n    loop invariant n == l;\n\n    loop invariant i <= l;\n\n    loop invariant l == 77;\n\n    loop invariant n == 77;\n\n    loop invariant x == b + 77 - i;\n\n    loop invariant 0 <= i <= 77;\n\n    loop invariant x >= b;\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant x + i == b + l;\n\n    loop invariant b <= x <= b + l;\n\n    loop invariant v == -2 + (l - i)*(b + n + 1) + ((l - i)*(l - i - 1))/2;\n\n    loop assigns v, x, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+x+n;\n      v = v+1;\n      x = x+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int q){\n  int l, i, v, c;\n\n  l=17;\n  i=l;\n  v=m;\n  c=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      c = c-1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (c == -4) && (v == \\at(m, Pre)) && (i == 17) && (l == 17) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      c = c-1;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: c: c@last -> c@last - 1; i: i@last -> i@last - 1; v: v@last -> v@last + 1. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'i', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int q){\n  int l, i, v, c;\n\n  l=17;\n  i=l;\n  v=m;\n  c=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i && i <= 17;\n    loop invariant c == i - 21;\n    loop invariant v == m + 17 - i;\n    loop invariant a == \\at(a, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant a == \\at(a, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant l == 17;\n    loop invariant v == \\at(m, Pre) + (l - i);\n    loop invariant c == -4 - (l - i);\n    loop invariant i <= 17;\n    loop invariant v + i == m + 17;\n    loop invariant q == \\at(q, Pre);\n    loop invariant i + v == 17 + m;\n    loop invariant i + v == 17 + \\at(m, Pre);\n    loop invariant 0 <= i;\n    loop invariant v >= \\at(m, Pre);\n    loop invariant c <= -4;\n    loop assigns v, c, i;\n  */\n  while (i>0) {\n      v = v+1;\n      c = c-1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int p,int q){\n  int l, i, v, h;\n\n  l=a+20;\n  i=0;\n  v=3;\n  h=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      h = h+h;\n      h = h+v;\n      i = i+3;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (h == 0) && (v == 3) && (i == 0) && (l == \\at(a, Pre) + 20) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      h = h+h;\n      h = h+v;\n      i = i+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: h: h@last -> h@last + h@last + v@last; i: i@last -> i@last + 3. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; p keeps p@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'h', 'i', 'k', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int p,int q){\n  int l, i, v, h;\n\n  l=a+20;\n  i=0;\n  v=3;\n  h=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == a + 20;\n    loop invariant v == 3;\n    loop invariant i % 3 == 0;\n    loop invariant i >= 0;\n    loop invariant h >= i;\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant l == \\at(a,Pre) + 20;\n\n    loop invariant h % 3 == 0;\n    loop invariant a == \\at(a,Pre);\n    loop invariant h >= 0;\n\n    loop assigns h, i;\n  */\n  while (i<l) {\n      h = h+h;\n      h = h+v;\n      i = i+3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int q){\n  int l, i, v;\n\n  l=77;\n  i=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      v = v+v;\n      if (i+6<=i+l) {\n          v = v%9;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(k, Pre)) && (i == 0) && (l == 77) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      v = v+v;\n      if (i+6<=i+l) {\n          v = v%9;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 6 > i@last + l@last; i@last < l@last; 2 + v@last; 2) || i@last + 6 <= i@last + l@last; i@last < l@last; 2 + v@last; 2) % 9). Changed: i: i@last -> i@last + 1; v: v@last -> (v@last. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int q){\n  int l, i, v;\n\n  l=77;\n  i=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant 0 <= i <= l;\n   loop invariant l == 77;\n   loop invariant b == \\at(b, Pre);\n   loop invariant k == \\at(k, Pre);\n   loop invariant m == \\at(m, Pre);\n   loop invariant q == \\at(q, Pre);\n\n   loop invariant (i == 0) ==> (v == k);\n\n   loop assigns i, v;\n   loop variant l - i;\n */\nwhile (i<l) {\n      v = v*2;\n      v = v+v;\n      if (i+6<=i+l) {\n          v = v%9;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n,int q){\n  int l, i, v;\n\n  l=a+18;\n  i=0;\n  v=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      v = v*v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -6) && (i == 0) && (l == \\at(a, Pre) + 18) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      v = v*v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2; v@last; 2). Changed: i: i@last -> i@last + 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; n keeps n@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n,int q){\n  int l, i, v;\n\n  l=a+18;\n  i=0;\n  v=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant (a == \\at(a, Pre) && k == \\at(k, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre));\n    loop invariant (l < 0) || (i <= l);\n    loop invariant (i == 0) ==> (v == -6);\n    loop invariant (i > 0) ==> (v >= 0);\n    loop invariant l == a + 18;\n    loop invariant i >= 0;\n    loop invariant v >= -6;\n    loop invariant (i > 0) ==> (v > 0);\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n    loop invariant (i > 0) ==> (v > -6);\n\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant (i >= 2) ==> (v >= 0);\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v*2;\n      v = v*v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int p){\n  int l, i, v;\n\n  l=a-3;\n  i=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = i-3;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 0) && (l == \\at(a, Pre) - 3) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = i-3;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> i@last - 3. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int p){\n  int l, i, v;\n\n  l=a-3;\n  i=0;\n  v=0;\n\n  \n  /*@\n\n    loop invariant l == a - 3;\n\n    loop invariant (i == 0 && v == 0) || (i > 0 && v == i - 4);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant (i == 0) ==> (v == 0);\n\n    loop invariant (i > 0) ==> (v == i - 4);\n\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre);\n\n    loop invariant 0 <= i;\n\n\n    loop invariant v >= i - 4;\n\n    loop invariant l == \\at(a, Pre) - 3;\n\n    loop invariant v <= i;\n\n    loop invariant i >= 0;\n\n    loop invariant (i == 0 && v == 0) || (i - v == 4);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = i-3;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int p){\n  int l, i, v;\n\n  l=k+11;\n  i=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(k, Pre)) && (i == 0) && (l == \\at(k, Pre) + 11) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last + i@last). Changed: i: i@last -> i@last + 1. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int p){\n  int l, i, v;\n\n  l=k+11;\n  i=0;\n  v=k;\n\n  \n  /*@\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant l == k + 11;\n\n\n    loop invariant v >= k;\n\n    loop invariant k == \\at(k,Pre);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant n == \\at(n,Pre);\n\n    loop invariant p == \\at(p,Pre);\n\n\n    loop invariant 0 <= i;\n\n    loop invariant (l >= 0) ==> (i <= l);\n\n    loop invariant (i == 0) ==> (v == k);\n\n    loop invariant i >= 0;\n\n    loop invariant (k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre));\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v*v;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n,int p){\n  int l, i, v;\n\n  l=54;\n  i=0;\n  v=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v+v;\n      v = v*v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 3) && (i == 0) && (l == 54) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v+v;\n      v = v*v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last + v@last; v@last; v@last + v@last). Changed: i: i@last -> i@last + 1; v: v@last -> (v@last. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n,int p){\n  int l, i, v;\n\n  l=54;\n  i=0;\n  v=3;\n\n  \n  /*@\n\n    loop invariant l == 54;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant v >= 3;\n\n    loop invariant i <= 54;\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant v > 0;\n\n    loop invariant (i == 0) ==> (v == 3);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v*v+v;\n      v = v*v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int p){\n  int l, i, v;\n\n  l=33;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      v = v+1;\n      i = i+3;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 33) && (i == 0) && (l == 33) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      v = v+1;\n      i = i+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 3; v: v@last -> v@last + v@last + 1. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int p){\n  int l, i, v;\n\n  l=33;\n  i=0;\n  v=l;\n\n  \n  /*@\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant i % 3 == 0;\n\n    loop invariant v % 2 == 1;\n\n    loop invariant i <= l;\n\n    loop invariant v >= 33;\n\n\n    loop invariant l == 33;\n\n    loop invariant v >= l;\n\n    loop invariant a == \\at(a, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop invariant (v + 1) % 34 == 0;\n\n    loop invariant 0 <= i;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+v;\n      v = v+1;\n      i = i+3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int n){\n  int l, i, v;\n\n  l=(m%14)+14;\n  i=l;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v%4;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 4) && (i == \\at(m, Pre) % 14 + 14) && (l == \\at(m, Pre) % 14 + 14) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v%4;\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last / 2; v: v@last -> v@last % 4. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int n){\n  int l, i, v;\n\n  l=(m%14)+14;\n  i=l;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre);\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v == 0 || v == 4;\n    loop invariant l == (\\at(m,Pre) % 14) + 14;\n    loop invariant a == \\at(a,Pre);\n    loop invariant k == \\at(k,Pre);\n    loop invariant m == \\at(m,Pre);\n    loop invariant n == \\at(n,Pre);\n    loop invariant 0 <= i;\n    loop invariant i <= (\\at(m,Pre) % 14) + 14;\n    loop invariant v >= 0;\n    loop invariant v <= 4;\n    loop invariant l == (m % 14) + 14;\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant l == (\\at(m, Pre) % 14) + 14;\n    loop assigns i, v;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v%4;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=n-7;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+6<l) {\n          v = v+v;\n      }\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 4) && (i == 0) && (l == \\at(n, Pre) - 7) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+6<l) {\n          v = v+v;\n      }\n      v = v+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last + 6 < l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + i@last. Unchanged: b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=n-7;\n  i=0;\n  v=4;\n\n  \n  /*@\n\n    loop invariant l == n - 7;\n\n    loop invariant 0 <= i;\n\n\n    loop invariant 4 <= v;\n\n    loop invariant v >= 4 + i*(i-1)/2;\n\n    loop invariant l == \\at(n,Pre) - 7;\n\n\n    loop invariant n == \\at(n,Pre);\n\n    loop invariant b == \\at(b,Pre);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant p == \\at(p,Pre);\n\n    loop invariant v >= 4;\n\n    loop invariant v - i >= 3;\n\n    loop invariant v >= i;\n\n    loop invariant l == \\at(n,Pre) - 7 && i >= 0 && v >= 4 &&\n                   b == \\at(b,Pre) && m == \\at(m,Pre) && n == \\at(n,Pre) && p == \\at(p,Pre);\n\n    loop assigns i, v;\n\n  */\n  while (i<l) {\n      if (v+6<l) {\n          v = v+v;\n      }\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int p){\n  int l, i, v, o;\n\n  l=22;\n  i=l;\n  v=k;\n  o=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      o = o+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (o == \\at(k, Pre)) && (v == \\at(k, Pre)) && (i == 22) && (l == 22) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      o = o+v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; 2; 2). Changed: i: i@last -> i@last - 1; o: o@last -> o@last + v@last. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'o', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int p){\n  int l, i, v, o;\n\n  l=22;\n  i=l;\n  v=k;\n  o=k;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= 22;\n\n    loop invariant b == \\at(b,Pre) && k == \\at(k,Pre) && m == \\at(m,Pre) && p == \\at(p,Pre);\n\n    loop invariant l == 22;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant o == 2*v - k;\n\n    loop invariant 0 <= i <= 22;\n\n    loop assigns i, v, o;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v*2;\n      o = o+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v;\n\n  l=40;\n  i=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+5<l) {\n          v = v+i;\n      }\n      else {\n          v = v-v;\n      }\n      if (v+5<l) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(q, Pre)) && (i == 0) && (l == 40) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+5<l) {\n          v = v+i;\n      }\n      else {\n          v = v-v;\n      }\n      if (v+5<l) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last - v@last + 5 >= l@last; v@last + 5 >= l@last; i@last < l@last; v@last + 5 < l@last; i@last < l@last; v@last + 5 < l@last; i@last < l@last; v@last + 5 >= l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last - v@last - (v@last - v@last. Unchanged: a keeps a@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v;\n\n  l=40;\n  i=0;\n  v=q;\n\n  \n  /*@\n\n    loop invariant l == 40;\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant (i == 0) ==> (v == \\at(q, Pre));\n\n\n    loop invariant q == \\at(q,Pre);\n\n    loop invariant a == \\at(a,Pre);\n\n    loop invariant n == \\at(n,Pre);\n\n    loop invariant p == \\at(p,Pre);\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant (i > 0) ==> (v >= 0);\n\n    loop invariant (i == 0) ==> (v == q);\n\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      if (v+5<l) {\n          v = v+i;\n      }\n      else {\n          v = v-v;\n      }\n      if (v+5<l) {\n          v = v-v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int p,int q){\n  int l, i, v, y;\n\n  l=23;\n  i=l;\n  v=a;\n  y=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+y+y;\n      v = v+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (y == \\at(k, Pre)) && (v == \\at(a, Pre)) && (i == 23) && (l == 23) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+y+y;\n      v = v+1;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + y@last + y@last + 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; p keeps p@last; q keeps q@last; y keeps y@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'p', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int p,int q){\n  int l, i, v, y;\n\n  l=23;\n  i=l;\n  v=a;\n  y=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == a + (l - i) * (2*y + 1);\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant y == k;\n    loop invariant l == 23;\n    loop invariant i <= 23;\n    loop invariant v == a + (23 - i) * (2*y + 1);\n    loop invariant y == \\at(k, Pre);\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant v == \\at(a,Pre) + (l - i) * (2 * \\at(k,Pre) + 1);\n    loop assigns i, v;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+y+y;\n      v = v+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v, u;\n\n  l=p;\n  i=0;\n  v=6;\n  u=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (i<l/2) {\n          v = v+u;\n      }\n      else {\n          v = v+1;\n      }\n      v = v+1;\n      u = u-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (i<l/2) {\n          v = v+u;\n      }\n      else {\n          v = v+1;\n      }\n      v = v+1;\n      u = u-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v, u;\n\n  l=p;\n  i=0;\n  v=6;\n  u=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n\n    loop invariant l == p;\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant u <= 4;\n    loop invariant i == 0;\n    loop invariant p == \\at(p,Pre);\n\n    loop invariant (i >= l/2) ==> v + 2*u == 14;\n    loop invariant l == \\at(p, Pre);\n    loop invariant (l > 0) ==> (i < l);\n\n    loop assigns v, u;\n  */\n  while (i<l) {\n      if (i<l/2) {\n          v = v+u;\n      }\n      else {\n          v = v+1;\n      }\n      v = v+1;\n      u = u-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n,int p){\n  int l, i, v;\n\n  l=n+15;\n  i=0;\n  v=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      v = v+i;\n      i = i+4;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 6) && (i == 0) && (l == \\at(n, Pre) + 15) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      v = v+i;\n      i = i+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 4; v: v@last -> v@last + v@last + i@last. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n,int p){\n  int l, i, v;\n\n  l=n+15;\n  i=0;\n  v=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == n + 15;\n    loop invariant i % 4 == 0;\n\n    loop invariant v >= i;\n    loop invariant v % 2 == 0;\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n    loop invariant l == \\at(n, Pre) + 15;\n    loop invariant i >= 0;\n    loop invariant a == \\at(a, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant v >= 6;\n    loop invariant b == \\at(b, Pre);\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant v >= i + 6;\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+v;\n      v = v+i;\n      i = i+4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int q){\n  int l, i, v, o;\n\n  l=(b%12)+15;\n  i=0;\n  v=a;\n  o=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+5;\n      o = o+4;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (o == \\at(b, Pre) % 12 + 15) && (v == \\at(a, Pre)) && (i == 0) && (l == \\at(b, Pre) % 12 + 15) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+5;\n      o = o+4;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; o: o@last -> o@last + 4; v: v@last -> v@last + 5. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'o', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int q){\n  int l, i, v, o;\n\n  l=(b%12)+15;\n  i=0;\n  v=a;\n  o=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == a + 5*i;\n    loop invariant o == l + 4*i;\n    loop invariant i <= l;\n    loop invariant l == ((\\at(b,Pre) % 12) + 15);\n    loop invariant a == \\at(a,Pre);\n    loop invariant b == \\at(b,Pre);\n    loop invariant m == \\at(m,Pre);\n    loop invariant q == \\at(q,Pre);\n    loop invariant 0 <= i <= l;\n    loop invariant l == (b % 12) + 15;\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant 0 <= i;\n    loop invariant v == \\at(a, Pre) + 5*i;\n    loop invariant l == ((\\at(b, Pre) % 12) + 15);\n    loop invariant (a == \\at(a, Pre) && b == \\at(b, Pre) && m == \\at(m, Pre) && q == \\at(q, Pre));\n    loop invariant i >= 0;\n    loop invariant m == \\at(m, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns v, o, i;\n  */\n  while (i<l) {\n      v = v+5;\n      o = o+4;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int p){\n  int l, i, v, u, y;\n\n  l=52;\n  i=l;\n  v=p;\n  u=l;\n  y=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      u = u-1;\n      u = u+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (y == -1) && (u == 52) && (v == \\at(p, Pre)) && (i == 52) && (l == 52) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      u = u-1;\n      u = u+1;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'p', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int p){\n  int l, i, v, u, y;\n\n  l=52;\n  i=l;\n  v=p;\n  u=l;\n  y=-1;\n\n  /*>>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v + i == p + 52;\n    loop invariant 0 <= i <= 52;\n    loop invariant p <= v <= p + 52;\n    loop invariant u == 52;\n    loop invariant l == 52;\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant i <= l;\n    loop invariant v - p == l - i;\n    loop invariant i >= 0;\n    loop invariant v == p + (l - i);\n    loop invariant u == l;\n    loop invariant (k == \\at(k, Pre));\n    loop invariant (m == \\at(m, Pre));\n    loop invariant (p == \\at(p, Pre));\n    loop invariant (n == \\at(n, Pre));\n    loop invariant ((i + v) == (\\at(p, Pre) + 52));\n    loop invariant (u == 52);\n    loop assigns v, u, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+1;\n      u = u-1;\n      u = u+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int q){\n  int l, i, v;\n\n  l=55;\n  i=0;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      v = v+1;\n      i = i+5;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(n, Pre)) && (i == 0) && (l == 55) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      v = v+1;\n      i = i+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 5; v: v@last -> v@last + i@last + 1. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int q){\n  int l, i, v;\n\n  l=55;\n  i=0;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 10*(v - \\at(n, Pre)) == i*(i - 3);\n    loop invariant i <= l;\n    loop invariant i % 5 == 0;\n    loop invariant i >= 0;\n    loop invariant 0 <= i <= l;\n    loop invariant v == n + (i*i - 3*i)/10;\n    loop invariant n == \\at(n, Pre) && a == \\at(a, Pre) && m == \\at(m, Pre) && q == \\at(q, Pre);\n\n    loop invariant a == \\at(a, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant 0 <= i;\n    loop invariant v - n == (i*i - 3*i) / 10;\n    loop invariant v >= n;\n    loop invariant l == 55;\n    loop assigns v, i;\n  */\n  while (i<l) {\n      v = v+i;\n      v = v+1;\n      i = i+5;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p,int q){\n  int l, i, v;\n\n  l=23;\n  i=0;\n  v=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      v = l%9;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 3) && (i == 0) && (l == 23) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      v = l%9;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p,int q){\n  int l, i, v;\n\n  l=23;\n  i=0;\n  v=3;\n\n  \n  /*@\n\n    loop invariant l == 23;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant (i == 0) ==> (v == 3);\n\n    loop invariant (i > 0) ==> (v == (l % 9));\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant v >= 0;\n\n    loop invariant v <= l % 9;\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant (i > 0) ==> (v == l % 9);\n\n    loop invariant i <= l;\n\n    loop invariant 0 <= i;\n\n    loop invariant v == 3 || v == l % 9;\n\n    loop invariant i >= 0;\n\n    loop invariant ((i == 0 && v == 3) || (i > 0 && v == l % 9));\n\n    loop assigns v, i;\n\n  */\n  while (i<l) {\n      v = v+i;\n      v = l%9;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int n){\n  int l, i, v;\n\n  l=44;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      if ((i%8)==0) {\n          v = v+i;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 44) && (i == 44) && (l == 44) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      if ((i%8)==0) {\n          v = v+i;\n      }\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 8 != 0; i@last > 0; i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + i@last. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int n){\n  int l, i, v;\n\n  l=44;\n  i=l;\n  v=i;\n\n  \n  /*@\n\n    loop invariant l == 44;\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant (i >= 40) ==> (v == 44);\n\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre);\n\n    loop invariant i <= 44;\n\n    loop invariant v % 8 == 4;\n\n    loop invariant v >= 44;\n\n\n    loop invariant 0 <= i && i <= 44;\n\n\n    loop assigns v, i;\n\n  */\nwhile (i>0) {\n      if ((i%8)==0) {\n          v = v+i;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n,int q){\n  int l, i, v, g, f;\n\n  l=75;\n  i=l;\n  v=k;\n  g=n;\n  f=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      if (v+6<=l) {\n          v = v+6;\n      }\n      else {\n          v = l;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (f == -8) && (g == \\at(n, Pre)) && (v == \\at(k, Pre)) && (i == 75) && (l == 75) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      if (v+6<=l) {\n          v = v+6;\n      }\n      else {\n          v = l;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last + 6 <= l@last; i@last > 0; i@last > 0). Changed: v: v@last -> l@last. Unchanged: b keeps b@last; f keeps f@last; g keeps g@last; i keeps i@last; k keeps k@last; l keeps l@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n,int q){\n  int l, i, v, g, f;\n\n  l=75;\n  i=l;\n  v=k;\n  g=n;\n  f=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i == 75;\n    loop invariant l == 75;\n    loop invariant (v <= k) || (v <= l);\n    loop invariant i > 0;\n    loop invariant v <= l || v == k;\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant b == \\at(b, Pre) && k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre) && q == \\at(q, Pre);\n\n    loop invariant i <= 75;\n    loop assigns v;\n  */\n  while (i>0) {\n      if (v+6<=l) {\n          v = v+6;\n      }\n      else {\n          v = l;\n      }\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p,int q){\n  int l, i, v, u;\n\n  l=56;\n  i=0;\n  v=1;\n  u=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+u+u;\n      v = v+1;\n      i = i+4;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (u == \\at(q, Pre)) && (v == 1) && (i == 0) && (l == 56) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+u+u;\n      v = v+1;\n      i = i+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 4; v: v@last -> v@last + u@last + u@last + 1. Unchanged: b keeps b@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last; u keeps u@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'p', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p,int q){\n  int l, i, v, u;\n\n  l=56;\n  i=0;\n  v=1;\n  u=q;\n\n  \n  /*@\n\n    loop invariant l == 56;\n\n    loop invariant i % 4 == 0;\n\n    loop invariant i <= l;\n\n    loop invariant v == 1 + (i / 4) * (2 * u + 1);\n\n    loop invariant u == q;\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant v == 1 + (i/4) * (2*u + 1);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant 4*(v - 1) == i*(2*u + 1);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop assigns i, v;\n\n  */\n  while (i<l) {\n      v = v+u+u;\n      v = v+1;\n      i = i+4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int p){\n  int l, i, v, k;\n\n  l=41;\n  i=l;\n  v=a;\n  k=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      k = k+k;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (k == \\at(m, Pre)) && (v == \\at(a, Pre)) && (i == 41) && (l == 41) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      k = k+k;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; k: k@last -> k@last + k@last. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'm', 'p']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int p){\n  int l, i, v, k;\n\n  l=41;\n  i=l;\n  v=a;\n  k=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n\n    loop invariant i >= 0;\n    loop invariant i <= 41;\n    loop invariant a == \\at(a, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant m * k >= 0;\n    loop invariant (m == 0) ==> (k == 0);\n    loop invariant b == \\at(b, Pre);\n    loop invariant l == 41;\n\n    loop assigns i, k;\n    loop variant i;\n  */\n  while (i>0) {\n      k = k+k;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int n){\n  int l, i, v;\n\n  l=42;\n  i=l;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      if (i+2<=n+l) {\n          v = v+1;\n      }\n      if ((i%7)==0) {\n          v = v-v;\n      }\n      else {\n          v = v-v;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(m, Pre)) && (i == 42) && (l == 42) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      if (i+2<=n+l) {\n          v = v+1;\n      }\n      if ((i%7)==0) {\n          v = v-v;\n      }\n      else {\n          v = v-v;\n      }\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 7 != 0; i@last + 2 <= n@last + l@last; i@last > 0; i@last + 2 > n@last + l@last; i@last > 0; i@last + 2 <= n@last + l@last; i@last > 0; i@last + 2 > n@last + l@last; i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last - v@last. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int n){\n  int l, i, v;\n\n  l=42;\n  i=l;\n  v=m;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= 42;\n\n    loop invariant l == 42;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant (i == l) ==> (v == \\at(m, Pre));\n\n    loop invariant (i != l) ==> (v == 0);\n\n    loop invariant a == \\at(a,Pre) && k == \\at(k,Pre) && m == \\at(m,Pre) && n == \\at(n,Pre);\n\n    loop invariant i <= l;\n\n    loop invariant (i == l) ==> (v == m);\n\n    loop invariant (i < l) ==> (v == 0);\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      if (i+2<=n+l) {\n          v = v+1;\n      }\n      if ((i%7)==0) {\n          v = v-v;\n      }\n      else {\n          v = v-v;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int p){\n  int l, i, v;\n\n  l=p;\n  i=0;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(n, Pre)) && (i == 0) && (l == \\at(p, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      v = v-v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + v@last - (v@last + v@last. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int p){\n  int l, i, v;\n\n  l=p;\n  i=0;\n  v=n;\n\n  \n  /*@\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant (i == 0) ==> (v == n);\n\n    loop invariant (i >= 1) ==> (v == 0);\n\n    loop invariant l == p;\n\n    loop invariant i >= 0;\n\n\n    loop invariant (i > 0) ==> (v == 0);\n\n    loop invariant k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop invariant (i == 0) ==> (v == \\at(n, Pre));\n\n    loop invariant l == \\at(p, Pre);\n\n\n    loop invariant i >= 0 && (l <= 0 || i <= l);\n\n    loop assigns i, v;\n\n  */\n  while (i<l) {\n      v = v+v;\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int q){\n  int l, i, v, z;\n\n  l=43;\n  i=0;\n  v=l;\n  z=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+z+z;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (z == 0) && (v == 43) && (i == 0) && (l == 43) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+z+z;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + z@last + z@last + 1. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last; z keeps z@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'q', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int q){\n  int l, i, v, z;\n\n  l=43;\n  i=0;\n  v=l;\n  z=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 43;\n    loop invariant z == 0;\n    loop invariant v == l + i;\n    loop invariant i <= l;\n    loop invariant (k == \\at(k, Pre)) && (m == \\at(m, Pre)) && (n == \\at(n, Pre)) && (q == \\at(q, Pre));\n    loop invariant 0 <= i && i <= l;\n    loop invariant v == 43 + i;\n    loop invariant k == \\at(k,Pre);\n    loop invariant m == \\at(m,Pre);\n    loop invariant n == \\at(n,Pre);\n    loop invariant q == \\at(q,Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i >= 0;\n    loop invariant v == 43 + i*(2*z + 1);\n    loop invariant k == \\at(k,Pre) && m == \\at(m,Pre) && n == \\at(n,Pre) && q == \\at(q,Pre);\n    loop invariant k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+z+z;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n,int p){\n  int l, i, v;\n\n  l=58;\n  i=l;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*v+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -1) && (i == 58) && (l == 58) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*v+v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; v@last + v@last). Changed: i: i@last -> i@last - 1. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n,int p){\n  int l, i, v;\n\n  l=58;\n  i=l;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant l == 58;\n    loop invariant i >= 0;\n    loop invariant i <= 58;\n    loop invariant v == -1 || v == 0;\n    loop invariant (v == -1) ==> (i == 58);\n    loop invariant b == \\at(b, Pre) && k == \\at(k, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n    loop invariant i <= l;\n    loop invariant (v == -1) || (v == 0);\n    loop invariant b == \\at(b, Pre) && k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre) && p == \\at(p, Pre);\n    loop invariant 0 <= i && i <= 58;\n    loop assigns i, v;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v*v+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int q){\n  int l, i, v;\n\n  l=52;\n  i=0;\n  v=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      v = v+4;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 1) && (i == 0) && (l == 52) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      v = v+4;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 1 + 4. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int q){\n  int l, i, v;\n\n  l=52;\n  i=0;\n  v=1;\n\n  \n  /*@\n\n    loop invariant v == 1 + 5*i;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant l == 52;\n\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && q == \\at(q, Pre);\n\n    loop invariant v == 1 + 5 * i;\n\n    loop invariant 0 <= i;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      v = v+4;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int q){\n  int l, i, v, y;\n\n  l=17;\n  i=0;\n  v=-8;\n  y=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v+v;\n      v = v%3;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (y == 4) && (v == -8) && (i == 0) && (l == 17) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v+v;\n      v = v%3;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last + v@last) % 3). Changed: i: i@last -> i@last + 1; v: v@last -> (v@last. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; q keeps q@last; y keeps y@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int q){\n  int l, i, v, y;\n\n  l=17;\n  i=0;\n  v=-8;\n  y=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant i <= l;\n   loop invariant 0 <= i;\n   loop invariant (i == 0) ==> (v == -8);\n   loop invariant (i > 0) ==> (v >= 0 && v <= 2);\n   loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && m == \\at(m, Pre) && q == \\at(q, Pre);\n   loop invariant l == 17;\n   loop invariant a == \\at(a, Pre);\n   loop invariant b == \\at(b, Pre);\n   loop invariant m == \\at(m, Pre);\n   loop invariant q == \\at(q, Pre);\n   loop invariant (v == -8) || (v == 0) || (v == 2);\n   loop invariant i >= 0;\n   loop assigns i, v;\n */\nwhile (i<l) {\n      v = v*v+v;\n      v = v%3;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p,int q){\n  int l, i, v;\n\n  l=(a%12)+20;\n  i=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%5)==0) {\n          v = v*v;\n      }\n      else {\n          v = v+i;\n      }\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 0) && (l == \\at(a, Pre) % 12 + 20) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%5)==0) {\n          v = v*v;\n      }\n      else {\n          v = v+i;\n      }\n      v = v+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last + v@last; v@last) || i@last % 5 != 0; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + i@last + (v@last + i@last. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p,int q){\n  int l, i, v;\n\n  l=(a%12)+20;\n  i=0;\n  v=0;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant v >= 0;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant v % 2 == 0;\n\n    loop invariant l == (a % 12) + 20;\n\n    loop invariant l == (\\at(a,Pre) % 12) + 20;\n\n    loop invariant 0 <= i;\n\n    loop invariant a == \\at(a,Pre);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant p == \\at(p,Pre);\n\n    loop invariant q == \\at(q,Pre);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant (v % 2) == 0;\n\n    loop invariant l == (\\at(a, Pre) % 12) + 20;\n\n    loop assigns i, v;\n\n  */\n  while (i<l) {\n      if ((i%5)==0) {\n          v = v*v;\n      }\n      else {\n          v = v+i;\n      }\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int p){\n  int l, i, v;\n\n  l=b;\n  i=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%8)==0) {\n          v = v+i;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(k, Pre)) && (i == 0) && (l == \\at(b, Pre)) && (p == \\at(p, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%8)==0) {\n          v = v+i;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 8 != 0; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + i@last. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int p){\n  int l, i, v;\n\n  l=b;\n  i=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i;\n    loop invariant (l <= 0) || (i <= l);\n    loop invariant v >= \\at(k, Pre);\n\n    loop invariant l == \\at(b, Pre);\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant l == b;\n    loop invariant v >= k;\n    loop invariant (v - k) % 8 == 0;\n\n    loop invariant l == \\at(b,Pre);\n\n    loop invariant a == \\at(a,Pre);\n    loop invariant b == \\at(b,Pre);\n    loop invariant k == \\at(k,Pre);\n    loop invariant p == \\at(p,Pre);\n    loop assigns i, v;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      if ((i%8)==0) {\n          v = v+i;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n,int p){\n  int l, i, v, u;\n\n  l=41;\n  i=0;\n  v=m;\n  u=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      u = u+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      u = u+1;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'n', 'p', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n,int p){\n  int l, i, v, u;\n\n  l=41;\n  i=0;\n  v=m;\n  u=6;\n\n/* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant i <= l;\n  loop invariant v == m + 3*i;\n  loop invariant u == 6 + i;\n  loop invariant i >= 0;\n  loop invariant l == 41;\n  loop invariant 0 <= i <= l;\n  loop invariant b == \\at(b, Pre);\n  loop invariant m == \\at(m, Pre);\n  loop invariant n == \\at(n, Pre);\n  loop invariant p == \\at(p, Pre);\n  loop invariant 0 <= i;\n  loop assigns i, v, u;\n  loop variant l - i;\n*/\nwhile (i<l) {\n      v = v+3;\n      u = u+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int p){\n  int l, i, v, d, z;\n\n  l=(p%11)+10;\n  i=0;\n  v=a;\n  d=a;\n  z=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      z = z+1;\n      if (i+2<=n+l) {\n          z = z+3;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (z == \\at(m, Pre)) && (d == \\at(a, Pre)) && (v == \\at(a, Pre)) && (i == 0) && (l == \\at(p, Pre) % 11 + 10) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      z = z+1;\n      if (i+2<=n+l) {\n          z = z+3;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 2 > n@last + l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 3; z: z@last -> z@last + 1 + 3. Unchanged: a keeps a@last; d keeps d@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'p', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int p){\n  int l, i, v, d, z;\n\n  l=(p%11)+10;\n  i=0;\n  v=a;\n  d=a;\n  z=m;\n\n  /* >>> LOOP INVARIANTS TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v == a + 3*i;\n    loop invariant z >= m + i;\n    loop invariant z <= m + 4*i;\n    loop invariant l == p % 11 + 10;\n    loop invariant (i <= n + l - 1) ==> (z == m + 4*i);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant l == (p%11) + 10;\n    loop invariant v == \\at(a, Pre) + 3*i;\n    loop invariant z - \\at(m, Pre) - i >= 0;\n    loop invariant (z - \\at(m, Pre) - i) % 3 == 0;\n    loop invariant z - \\at(m, Pre) - i <= 3*i;\n    loop invariant 0 <= i;\n    loop invariant a == \\at(a, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant l == (\\at(p,Pre) % 11) + 10;\n    loop assigns i, v, z;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      v = v+3;\n      z = z+1;\n      if (i+2<=n+l) {\n          z = z+3;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int p,int q){\n  int l, i, v, h, g;\n\n  l=35;\n  i=l;\n  v=0;\n  h=-6;\n  g=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      h = h+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (g == \\at(p, Pre)) && (h == -6) && (v == 0) && (i == 35) && (l == 35) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      h = h+v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; 2; 2). Changed: h: h@last -> h@last + v@last; i: i@last -> i@last - 1. Unchanged: g keeps g@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['h', 'i', 'k', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int p,int q){\n  int l, i, v, h, g;\n\n  l=35;\n  i=l;\n  v=0;\n  h=-6;\n  g=p;\n\n  \n  /*@\n\n    loop invariant v == 0;\n\n    loop invariant h == -6;\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= 35;\n\n    loop invariant l == 35;\n\n    loop invariant (i >= 0) && (i <= l);\n\n    loop invariant (k == \\at(k, Pre)) && (n == \\at(n, Pre)) && (p == \\at(p, Pre)) && (q == \\at(q, Pre));\n\n    loop invariant i >= 0;\n\n    loop invariant (k == \\at(k, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre));\n\n    loop invariant i >= 0 && i <= 35;\n\n    loop invariant p == \\at(p, Pre) && k == \\at(k, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n\n    loop invariant 0 <= i <= 35;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns v, h, i;\n\n  */\n  while (i>0) {\n      v = v*2;\n      h = h+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(m, Pre)) && (i == 0) && (l == 34) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 3 + 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int q){\n  int l, i, v;\n\n  l=34;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == m + 4*i;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant a == \\at(a, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant 0 <= i && i <= l;\n    loop invariant k == \\at(k, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant v == \\at(m,Pre) + 4*i;\n    loop invariant a == \\at(a,Pre);\n    loop invariant k == \\at(k,Pre);\n    loop invariant q == \\at(q,Pre);\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && q == \\at(q, Pre);\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+3;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int n){\n  int l, i, v;\n\n  l=(a%20)+19;\n  i=1;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      v = v*v;\n      i = i*3;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 1) && (i == 1) && (l == \\at(a, Pre) % 20 + 19) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      v = v*v;\n      i = i*3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 3; v@last + v@last). Changed: v: v@last -> (v@last + v@last. Unchanged: a keeps a@last; b keeps b@last; i keeps i@last; k keeps k@last; l keeps l@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int n){\n  int l, i, v;\n\n  l=(a%20)+19;\n  i=1;\n  v=i;\n\n  \n  /*@\n\n    loop invariant l == (\\at(a,Pre) % 20) + 19;\n\n    loop invariant i >= 1;\n\n    loop invariant v >= 1;\n\n    loop invariant v >= i;\n\n    loop invariant l == (\\at(a, Pre) % 20) + 19;\n\n\n    loop invariant v > 0;\n\n    loop invariant l == (a % 20) + 19;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n\n    loop invariant v % 4 == 0 || v == 1;\n\n    loop assigns i, v;\n\n  */\n  while (i<l) {\n      v = v+v;\n      v = v*v;\n      i = i*3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int n){\n  int l, i, v, f, t;\n\n  l=42;\n  i=0;\n  v=1;\n  f=k;\n  t=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v+v;\n      v = v%6;\n      if (v+2<l) {\n          v = v%6;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (t == \\at(a, Pre)) && (f == \\at(k, Pre)) && (v == 1) && (i == 0) && (l == 42) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v+v;\n      v = v%6;\n      if (v+2<l) {\n          v = v%6;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last; v@last + v@last) % 6 + 2 >= l@last; i@last < l@last; v@last + v@last) % 6; v@last + v@last) % 6 + 2 < l@last; i@last < l@last; v@last + v@last) % 6 % 6). Changed: i: i@last -> i@last + 1; v: v@last -> (v@last. Unchanged: a keeps a@last; b keeps b@last; f keeps f@last; k keeps k@last; l keeps l@last; n keeps n@last; t keeps t@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int n){\n  int l, i, v, f, t;\n\n  l=42;\n  i=0;\n  v=1;\n  f=k;\n  t=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 42;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant 0 <= v <= 5;\n    loop invariant (i == 0) ==> (v == 1);\n    loop invariant 0 <= v && v <= 5;\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant 0 <= i <= l;\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = v*v+v;\n      v = v%6;\n      if (v+2<l) {\n          v = v%6;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v;\n\n  l=36;\n  i=0;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      if (p<a+5) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(a, Pre)) && (i == 0) && (l == 36) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      if (p<a+5) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (p@last >= a@last + 5; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + v@last + 1. Unchanged: a keeps a@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v;\n\n  l=36;\n  i=0;\n  v=a;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant 0 <= i;\n\n    loop invariant l == 36;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant 0 <= i && i <= l;\n\n\n    loop invariant (i > 0 && !(p < a + 5)) ==> (v % 2 == 0);\n\n    loop invariant (i == 0) ==> (v == a);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n        v = v+v;\n        if (p<a+5) {\n            v = v+1;\n        }\n        i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int n){\n  int l, i, v, p;\n\n  l=29;\n  i=l;\n  v=n;\n  p=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+5;\n      p = p+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (p == \\at(a, Pre)) && (v == \\at(n, Pre)) && (i == 29) && (l == 29) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+5;\n      p = p+v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; p: p@last -> p@last + (v@last + 5; v: v@last -> v@last + 5. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int n){\n  int l, i, v, p;\n\n  l=29;\n  i=l;\n  v=n;\n  p=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i <= l;\n    loop invariant v == n + 5 * (l - i);\n    loop invariant p == a + (l - i) * n + 5 * (l - i) * (l - i + 1) / 2;\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant l == 29;\n    loop invariant a == \\at(a, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant v == n + 145 - 5*i;\n    loop invariant p == a + (29 - i)*n + 5*(29 - i)*(30 - i)/2;\n    loop invariant 0 <= i && i <= 29;\n    loop invariant v == n + 5*(l - i);\n    loop invariant p == a + (l - i) * (n + 5) + 5*(l - i)*(l - i - 1)/2;\n    loop invariant 0 <= i && i <= l;\n    loop invariant v == \\at(n, Pre) + 5*(l - i);\n    loop invariant p == \\at(a, Pre) + (l - i)*\\at(n, Pre) + 5*(l - i)*(l - i + 1)/2;\n    loop invariant a == \\at(a, Pre) && n == \\at(n, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre);\n    loop assigns v, p, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+5;\n      p = p+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v, y, z;\n\n  l=13;\n  i=0;\n  v=l;\n  y=a;\n  z=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (z == 6) && (y == \\at(a, Pre)) && (v == 13) && (i == 0) && (l == 13) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + i@last. Unchanged: a keeps a@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last; y keeps y@last; z keeps z@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v, y, z;\n\n  l=13;\n  i=0;\n  v=l;\n  y=a;\n  z=6;\n\n  \n  /*@\n\n    loop invariant v == l + i*(i - 1)/2;\n\n    loop invariant i <= l;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant v == 13 + i*(i-1)/2;\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant v == l + i*(i-1)/2;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant l == 13;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=a+10;\n  i=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 0) && (l == \\at(a, Pre) + 10) && (q == \\at(q, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 1 + i@last. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int q){\n  int l, i, v;\n\n  l=a+10;\n  i=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == i*(i+1)/2;\n\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant l == \\at(a,Pre) + 10;\n    loop invariant a == \\at(a,Pre);\n    loop invariant b == \\at(b,Pre);\n    loop invariant k == \\at(k,Pre);\n    loop invariant q == \\at(q,Pre);\n\n    loop invariant 0 <= i;\n    loop invariant l == a + 10;\n    loop invariant (l < 0) || (i <= l);\n    loop invariant l == \\at(a, Pre) + 10;\n    loop invariant i >= 0;\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v;\n\n  l=p;\n  i=0;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(n, Pre)) && (i == 0) && (l == \\at(p, Pre)) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 1 + (v@last + 1. Unchanged: a keeps a@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v;\n\n  l=p;\n  i=0;\n  v=n;\n\n  \n  /*@\n\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant (i > 0) ==> (v % 2 == 0);\n\n    loop invariant 0 <= i;\n\n\n    loop invariant l == p;\n\n    loop invariant i >= 0;\n\n    loop invariant l < 0 || (0 <= i && i <= l);\n\n    loop invariant i == 0 ==> v == \\at(n, Pre);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+1;\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=p+13;\n  i=0;\n  v=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+4;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 6) && (i == 0) && (l == \\at(p, Pre) + 13) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+4;\n      v = v+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 4 + (v@last + 4. Unchanged: b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=p+13;\n  i=0;\n  v=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant (i <= l) || (l < 0);\n    loop invariant l == p + 13;\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant v >= 6;\n\n    loop invariant (v + 8) % 14 == 0;\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant (v % 2) == 0;\n    loop invariant (i == 0) ==> (v == 6);\n    loop assigns i, v;\n  */\nwhile (i<l) {\n      v = v+4;\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int p){\n  int l, i, v;\n\n  l=(a%34)+5;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%8)==0) {\n          v = v+i;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(m, Pre)) && (i == 0) && (l == \\at(a, Pre) % 34 + 5) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%8)==0) {\n          v = v+i;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 8 != 0; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + i@last. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int p){\n  int l, i, v;\n\n  l=(a%34)+5;\n  i=0;\n  v=m;\n\n  \n  /*@\n\n    loop invariant l == (a % 34) + 5;\n\n    loop invariant 0 <= i;\n\n\n    loop invariant (v - m) % 8 == 0;\n\n    loop invariant v >= m;\n\n\n    loop invariant (l < 0) || (i <= l);\n\n    loop invariant (i == 0) ==> (v == m);\n\n    loop invariant a == \\at(a,Pre) && k == \\at(k,Pre) && m == \\at(m,Pre) && p == \\at(p,Pre);\n\n    loop invariant l == (\\at(a,Pre) % 34) + 5;\n\n    loop invariant v == \\at(m,Pre) + 4 * (((i - 1) / 8) * (((i - 1) / 8) + 1));\n\n    loop invariant i >= 0;\n\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      if ((i%8)==0) {\n          v = v+i;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p,int q){\n  int l, i, v;\n\n  l=57;\n  i=l;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      if (v+1<l) {\n          v = v*v;\n      }\n      v = v%9;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 57) && (i == 57) && (l == 57) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      if (v+1<l) {\n          v = v*v;\n      }\n      v = v%9;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last; 2 + 1 < l@last; i@last > 0; 2; v@last; 2) % 9) || v@last; 2 + 1 >= l@last; i@last > 0; 2 % 9). Changed: i: i@last -> i@last - 1. Unchanged: l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p,int q){\n  int l, i, v;\n\n  l=57;\n  i=l;\n  v=l;\n\n  \n  /*@\n\n    loop invariant l == 57;\n\n    loop invariant 0 <= i <= 57;\n\n    loop invariant 0 <= v <= 57;\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant (v == 57) || (v == 6) || (v == 0);\n\n    loop invariant 0 <= i;\n\n    loop invariant v >= 0;\n\n    loop invariant 0 <= i && i <= 57;\n\n    loop invariant i <= 57;\n\n    loop invariant m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v*2;\n      if (v+1<l) {\n          v = v*v;\n      }\n      v = v%9;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int p){\n  int l, i, v;\n\n  l=54;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      if (i+5<=l+l) {\n          v = v-v;\n      }\n      else {\n          v = v+1;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 54) && (i == 54) && (l == 54) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      if (i+5<=l+l) {\n          v = v-v;\n      }\n      else {\n          v = v+1;\n      }\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 5 > l@last + l@last; i@last > 0; i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last - v@last. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int p){\n  int l, i, v;\n\n  l=54;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant l == 54;\n   loop invariant i <= l;\n   loop invariant i >= 0;\n   loop invariant (i == l) ==> (v == 54);\n   loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre);\n   loop invariant a == \\at(a, Pre);\n   loop invariant b == \\at(b, Pre);\n   loop invariant m == \\at(m, Pre);\n   loop invariant p == \\at(p, Pre);\n   loop invariant 0 <= i;\n   loop invariant v >= 0;\n   loop invariant v <= i;\n   loop invariant (i >= 0 && i <= l);\n   loop invariant (a == \\at(a, Pre) && b == \\at(b, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre));\n   loop assigns v, i;\n */\nwhile (i>0) {\n      if (i+5<=l+l) {\n          v = v-v;\n      }\n      else {\n          v = v+1;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int p,int q){\n  int l, i, v, n;\n\n  l=61;\n  i=0;\n  v=-2;\n  n=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      n = n+n;\n      n = n+v;\n      i = i+3;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (n == 3) && (v == -2) && (i == 0) && (l == 61) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      n = n+n;\n      n = n+v;\n      i = i+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 3; n: n@last -> n@last + n@last + v@last. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int p,int q){\n  int l, i, v, n;\n\n  l=61;\n  i=0;\n  v=-2;\n  n=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i % 3 == 0;\n    loop invariant i >= 0;\n    loop invariant n >= 3;\n    loop invariant k == \\at(k, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i <= l + 2;\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant (i >= 3) ==> (n % 2 == 0);\n    loop invariant l == 61;\n    loop invariant v == -2;\n    loop assigns i, n;\n  */\n  while (i<l) {\n      n = n+n;\n      n = n+v;\n      i = i+3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int p,int q){\n  int l, i, v;\n\n  l=q;\n  i=l;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*v;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(q, Pre)) && (i == \\at(q, Pre)) && (l == \\at(q, Pre)) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*v;\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; v@last). Changed: i: i@last -> i@last / 2. Unchanged: k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int p,int q){\n  int l, i, v;\n\n  l=q;\n  i=l;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant k == \\at(k, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n\n   loop invariant l == q;\n   loop invariant i <= l;\n   loop invariant i <= \\at(q, Pre);\n   loop invariant v >= \\at(q, Pre);\n   loop invariant v >= i;\n   loop invariant k == \\at(k, Pre);\n   loop invariant n == \\at(n, Pre);\n   loop invariant p == \\at(p, Pre);\n   loop invariant q == \\at(q, Pre);\n   loop invariant (i > 0) ==> (v > 0);\n   loop assigns i, v;\n   loop variant i;\n */\nwhile (i>0) {\n      v = v*v;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int p){\n  int l, i, v, u, o;\n\n  l=77;\n  i=1;\n  v=l;\n  u=i;\n  o=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v+v;\n      v = v%5;\n      i = i*2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (o == \\at(p, Pre)) && (u == 1) && (v == 77) && (i == 1) && (l == 77) && (p == \\at(p, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v+v;\n      v = v%5;\n      i = i*2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2; v@last + v@last) % 5). Changed: v: v@last -> (v@last. Unchanged: a keeps a@last; b keeps b@last; i keeps i@last; k keeps k@last; l keeps l@last; o keeps o@last; p keeps p@last; u keeps u@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int p){\n  int l, i, v, u, o;\n\n  l=77;\n  i=1;\n  v=l;\n  u=i;\n  o=p;\n\n  \n  /*@\n\n\n    loop invariant v == 77 || v == 1 || v == 2;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant l == 77;\n\n    loop invariant i <= 2*l;\n\n    loop invariant 1 <= i;\n\n    loop invariant i > 0;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant v <= l;\n\n    loop assigns i, v;\n\n  */\n  while (i<l) {\n      v = v*v+v;\n      v = v%5;\n      i = i*2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int p){\n  int l, i, v;\n\n  l=72;\n  i=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -1) && (i == 0) && (l == 72) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + i@last. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int p){\n  int l, i, v;\n\n  l=72;\n  i=0;\n  v=-1;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant v == -1 + i*(i-1)/2;\n\n    loop invariant l == 72;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant v == -1 + i*(i - 1)/2;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int p){\n  int l, i, v;\n\n  l=55;\n  i=0;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      v = v*v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(n, Pre)) && (i == 0) && (l == 55) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      v = v*v+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last + i@last) + (v@last + i@last). Changed: i: i@last -> i@last + 1; v: v@last -> (v@last + i@last. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int p){\n  int l, i, v;\n\n  l=55;\n  i=0;\n  v=n;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant l == 55;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant (i > 0) ==> (v >= 0);\n\n    loop invariant v >= \\at(n, Pre);\n\n    loop invariant (i == 0) ==> (v == \\at(n, Pre));\n\n    loop invariant a == \\at(a, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop invariant (i == 0) ==> (v == n);\n\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant n == \\at(n,Pre);\n\n    loop invariant a == \\at(a,Pre);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+i;\n      v = v*v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int p){\n  int l, i, v, z;\n\n  l=76;\n  i=l;\n  v=-3;\n  z=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      z = z-1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (z == \\at(k, Pre)) && (v == -3) && (i == 76) && (l == 76) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      z = z-1;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + 1; z: z@last -> z@last - 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'p', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int p){\n  int l, i, v, z;\n\n  l=76;\n  i=l;\n  v=-3;\n  z=k;\n\n  \n  /*@\n\n    loop invariant v + z == \\at(k, Pre) - 3;\n\n    loop invariant i + v == 73;\n\n    loop invariant i >= 0;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant z - i == k - 76;\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant i <= 76;\n\n    loop invariant v == 73 - i;\n\n    loop invariant z == i + k - 76;\n\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre);\n\n    loop invariant a == \\at(a, Pre) &&\n                   k == \\at(k, Pre) &&\n                   m == \\at(m, Pre) &&\n                   p == \\at(p, Pre) &&\n                   v + i == l - 3 &&\n                   z == k - l + i &&\n                   i >= 0 &&\n                   i <= l;\n\n    loop invariant z == k - 76 + i;\n\n    loop invariant l == 76;\n\n    loop assigns v, z, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+1;\n      z = z-1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p,int q){\n  int l, i, v, o;\n\n  l=53;\n  i=l;\n  v=i;\n  o=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+5;\n      o = o+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (o == -5) && (v == 53) && (i == 53) && (l == 53) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+5;\n      o = o+v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; o: o@last -> o@last + (v@last + 5; v: v@last -> v@last + 5. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'o', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p,int q){\n  int l, i, v, o;\n\n  l=53;\n  i=l;\n  v=i;\n  o=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= 53;\n    loop invariant v == 318 - 5*i;\n    loop invariant 2*o == 19918 - 641*i + 5*i*i;\n    loop invariant a == \\at(a, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n    loop invariant o >= -5;\n    loop invariant a == \\at(a, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant v + 5*i == 318;\n    loop invariant l == 53;\n    loop invariant i <= l;\n    loop assigns v, o, i;\n  */\n  while (i>0) {\n      v = v+5;\n      o = o+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int p){\n  int l, i, v, u;\n\n  l=9;\n  i=l;\n  v=8;\n  u=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      u = u-1;\n      v = v+1;\n      v = v+i;\n      if ((i%9)==0) {\n          u = u+4;\n      }\n      else {\n          v = u-v;\n      }\n      if (i+2<=i+l) {\n          v = m+i;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      u = u-1;\n      v = v+1;\n      v = v+i;\n      if ((i%9)==0) {\n          u = u+4;\n      }\n      else {\n          v = u-v;\n      }\n      if (i+2<=i+l) {\n          v = m+i;\n      }\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'p', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int p){\n  int l, i, v, u;\n\n  l=9;\n  i=l;\n  v=8;\n  u=-5;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant l == 9;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant 0 <= i && i <= l;\n\n\n    loop invariant (i == l && v == 8 && u == -5) || (v == m + i + 1);\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant ((i == l && v == 8) || (i < l && v == m + i + 1));\n\n    loop assigns i, v, u;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+1;\n      u = u-1;\n      v = v+1;\n      v = v+i;\n      if ((i%9)==0) {\n          u = u+4;\n      }\n      else {\n          v = u-v;\n      }\n      if (i+2<=i+l) {\n          v = m+i;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int p){\n  int l, i, v, h, y;\n\n  l=64;\n  i=0;\n  v=k;\n  h=-2;\n  y=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      h = h+y;\n      y = y+v;\n      h = h+i;\n      h = h+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (y == \\at(m, Pre)) && (h == -2) && (v == \\at(k, Pre)) && (i == 0) && (l == 64) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      h = h+y;\n      y = y+v;\n      h = h+i;\n      h = h+1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: h: h@last -> h@last + y@last + i@last + 1; i: i@last -> i@last + 1; y: y@last -> y@last + v@last. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'h', 'i', 'k', 'l', 'm', 'p', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int p){\n  int l, i, v, h, y;\n\n  l=64;\n  i=0;\n  v=k;\n  h=-2;\n  y=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant y == m + i * k;\n\n    loop invariant b == \\at(b, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant v == k;\n    loop invariant l == 64;\n    loop invariant h == -2 + i * m + i + (k + 1) * i * (i - 1) / 2;\n    loop invariant 0 <= i && i <= l;\n    loop invariant y == m + v*i;\n    loop invariant h == -2 + i*(m+1) + (v+1)*i*(i-1)/2;\n    loop invariant 0 <= i;\n    loop invariant y == m + i * v;\n    loop invariant h == -2 + i * m + (((v+1) * i * (i - 1)) / 2) + i;\n    loop invariant y == \\at(m, Pre) + i * v;\n\n    loop invariant v == \\at(k, Pre);\n    loop assigns h, y, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      h = h+y;\n      y = y+v;\n      h = h+i;\n      h = h+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int m){\n  int l, i, v, w;\n\n  l=79;\n  i=0;\n  v=i;\n  w=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      w = w+w;\n      w = w+v;\n      if (v+3<l) {\n          w = w+1;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (w == \\at(b, Pre)) && (v == 0) && (i == 0) && (l == 79) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      w = w+w;\n      w = w+v;\n      if (v+3<l) {\n          w = w+1;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last + 3 >= l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; w: w@last -> w@last + w@last + v@last + 1. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'm', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int m){\n  int l, i, v, w;\n\n  l=79;\n  i=0;\n  v=i;\n  w=b;\n\n  \n  /*@\n\n    loop invariant v == 0;\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant l == 79;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre);\n\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant (i == 0) ==> (w == b);\n\n    loop invariant (i > 0) ==> (w % 2 != 0);\n\n    loop assigns w, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      w = w+w;\n      w = w+v;\n      if (v+3<l) {\n          w = w+1;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int p,int q){\n  int l, i, v, j, e;\n\n  l=10;\n  i=0;\n  v=i;\n  j=q;\n  e=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+j+e;\n      v = v+1;\n      if ((i%5)==0) {\n          v = v+1;\n      }\n      e = e+i;\n      j = j+6;\n      e = e+1;\n      j = j+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (e == \\at(a, Pre)) && (j == \\at(q, Pre)) && (v == 0) && (i == 0) && (l == 10) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+j+e;\n      v = v+1;\n      if ((i%5)==0) {\n          v = v+1;\n      }\n      e = e+i;\n      j = j+6;\n      e = e+1;\n      j = j+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 5 != 0; i@last < l@last; i@last < l@last). Changed: e: e@last -> e@last + i@last + 1; i: i@last -> i@last + 1; j: j@last -> j@last + 6 + i@last; v: v@last -> v@last + j@last + e@last + 1 + 1. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'e', 'i', 'j', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int p,int q){\n  int l, i, v, j, e;\n\n  l=10;\n  i=0;\n  v=i;\n  j=q;\n  e=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant e == a + i*(i+1)/2;\n    loop invariant j == q + 6*i + i*(i-1)/2;\n\n    loop invariant a == \\at(a, Pre);\n    loop invariant 0 <= i && i <= l;\n    loop invariant e == \\at(a, Pre) + i*(i+1)/2;\n    loop invariant j == \\at(q, Pre) + 6*i + i*(i-1)/2;\n    loop invariant a == \\at(a, Pre) && q == \\at(q, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant l == 10;\n    loop invariant j == \\at(q, Pre) + i*(i+11)/2;\n\n    loop invariant (i == 0) ==> (v == 0 && e == a && j == q);\n    loop invariant b == \\at(b, Pre);\n    loop assigns v, e, j, i;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      v = v+j+e;\n      v = v+1;\n      if ((i%5)==0) {\n          v = v+1;\n      }\n      e = e+i;\n      j = j+6;\n      e = e+1;\n      j = j+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int p,int q){\n  int l, i, v;\n\n  l=11;\n  i=l;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v-v;\n      if ((i%3)==0) {\n          v = v-i;\n      }\n      v = v%3;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 2) && (i == 11) && (l == 11) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v-v;\n      if ((i%3)==0) {\n          v = v-i;\n      }\n      v = v%3;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> (v@last - v@last) % 3. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int p,int q){\n  int l, i, v;\n\n  l=11;\n  i=l;\n  v=2;\n\n  \n  /*@\n\n    loop invariant l == 11;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant (a == \\at(a, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre));\n\n    loop invariant v == 0 || v == 2;\n\n    loop invariant i <= l;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant 0 <= v && v <= 2;\n\n    loop invariant a == \\at(a, Pre) && m == \\at(m, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n\n    loop invariant (i < l) ==> (v == 0);\n\n    loop invariant 0 <= i && i <= 11;\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v-v;\n      if ((i%3)==0) {\n          v = v-i;\n      }\n      v = v%3;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int n){\n  int l, i, v;\n\n  l=11;\n  i=l;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      v = v+i;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 11) && (i == 11) && (l == 11) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      v = v+i;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + 1 + i@last. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int n){\n  int l, i, v;\n\n  l=11;\n  i=l;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == l + (l - i)*(l + 1) - ((l - i)*(l - i - 1))/2;\n    loop invariant 0 <= i <= l;\n    loop invariant a == \\at(a,Pre);\n    loop invariant k == \\at(k,Pre);\n    loop invariant m == \\at(m,Pre);\n    loop invariant n == \\at(n,Pre);\n    loop invariant 2*v + i*i + 3*i == 176;\n    loop invariant i >= 0;\n    loop invariant i <= 11;\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant 2*v == 176 - 3*i - i*i;\n    loop invariant v >= 11;\n    loop invariant v >= i;\n    loop assigns v, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+1;\n      v = v+i;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int p,int q){\n  int l, i, v;\n\n  l=63;\n  i=0;\n  v=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%7)==0) {\n          v = v+i;\n      }\n      else {\n          v = v+1;\n      }\n      v = v+v;\n      i = i+2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(p, Pre)) && (i == 0) && (l == 63) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%7)==0) {\n          v = v+i;\n      }\n      else {\n          v = v+1;\n      }\n      v = v+v;\n      i = i+2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 2; v: v@last -> v@last + 1 + (v@last + 1. Unchanged: k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int p,int q){\n  int l, i, v;\n\n  l=63;\n  i=0;\n  v=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n\n   loop invariant i % 2 == 0;\n   loop invariant l == 63;\n   loop invariant k == \\at(k, Pre);\n   loop invariant p == \\at(p, Pre);\n   loop invariant q == \\at(q, Pre);\n   loop invariant 0 <= i;\n   loop invariant p == \\at(p, Pre) && k == \\at(k, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n   loop invariant (i == 0) ==> (v == p);\n   loop invariant n == \\at(n, Pre);\n   loop invariant i <= l + 1;\n   loop invariant (i != 0) ==> (v % 2 == 0);\n   loop invariant (i % 2) == 0;\n   loop invariant (i > 0) ==> (v % 2 == 0);\n   loop assigns i, v;\n */\nwhile (i<l) {\n      if ((i%7)==0) {\n          v = v+i;\n      }\n      else {\n          v = v+1;\n      }\n      v = v+v;\n      i = i+2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n,int p){\n  int l, i, v, g;\n\n  l=80;\n  i=0;\n  v=b;\n  g=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+g+g;\n      v = v+1;\n      g = n-5;\n      v = v+g;\n      if (g+1<l) {\n          g = g+v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (g == -3) && (v == \\at(b, Pre)) && (i == 0) && (l == 80) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+g+g;\n      v = v+1;\n      g = n-5;\n      v = v+g;\n      if (g+1<l) {\n          g = g+v;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (n@last - 5 + 1 >= l@last; i@last < l@last; i@last < l@last). Changed: g: g@last -> n@last - 5 + (v@last + g@last + g@last + 1 + (n@last - 5; i: i@last -> i@last + 1; v: v@last -> v@last + g@last + g@last + 1 + (n@last - 5. Unchanged: b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'g', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n,int p){\n  int l, i, v, g;\n\n  l=80;\n  i=0;\n  v=b;\n  g=-3;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant 0 <= i;\n\n    loop invariant l == 80;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant n == \\at(n,Pre);\n\n    loop invariant b == \\at(b,Pre);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant p == \\at(p,Pre);\n\n    loop invariant (i == 0) ==> (v == b);\n\n    loop invariant (i == 0) ==> (g == -3);\n\n    loop assigns v, g, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+g+g;\n      v = v+1;\n      g = n-5;\n      v = v+g;\n      if (g+1<l) {\n          g = g+v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int n){\n  int l, i, v;\n\n  l=16;\n  i=l;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+3;\n      v = v+6;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 4) && (i == 16) && (l == 16) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+3;\n      v = v+6;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + 3 + 6. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int n){\n  int l, i, v;\n\n  l=16;\n  i=l;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 16;\n    loop invariant v == 4 + 9*(l - i);\n    loop invariant 0 <= i <= l;\n    loop invariant v <= 4 + 9*l;\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant i >= 0;\n    loop invariant b == \\at(b, Pre) && k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre);\n    loop invariant i <= 16;\n    loop invariant v + 9 * i == 4 + 9 * 16;\n    loop invariant 0 <= i && i <= 16;\n    loop assigns v, i;\n  */\n  while (i>0) {\n      v = v+3;\n      v = v+6;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p,int q){\n  int l, i, v;\n\n  l=b+12;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 4) && (i == 0) && (l == \\at(b, Pre) + 12) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 1 + i@last. Unchanged: b keeps b@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p,int q){\n  int l, i, v;\n\n  l=b+12;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == b + 12;\n    loop invariant v == 4 + i*(i+1)/2;\n    loop invariant 0 <= i;\n\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i >= 0;\n    loop invariant v == 4 + i + i * (i - 1) / 2;\n    loop invariant b == \\at(b,Pre);\n    loop invariant m == \\at(m,Pre);\n    loop invariant p == \\at(p,Pre);\n    loop invariant q == \\at(q,Pre);\n    loop invariant l == \\at(b,Pre) + 12;\n    loop invariant (l < 0) || (i <= l);\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = v+1;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n,int p){\n  int l, i, v, g;\n\n  l=54;\n  i=0;\n  v=-2;\n  g=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      g = g-1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (g == \\at(n, Pre)) && (v == -2) && (i == 0) && (l == 54) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      g = g-1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: g: g@last -> g@last - 1; i: i@last -> i@last + 1; v: v@last -> v@last + 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'g', 'i', 'k', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n,int p){\n  int l, i, v, g;\n\n  l=54;\n  i=0;\n  v=-2;\n  g=n;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant v == i - 2;\n\n    loop invariant g == n - i;\n\n    loop invariant l == 54;\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant v == -2 + i;\n\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop assigns v, g, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      g = g-1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n,int p){\n  int l, i, v;\n\n  l=37;\n  i=l;\n  v=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v-v;\n      v = v+v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 6) && (i == 37) && (l == 37) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v-v;\n      v = v+v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last - v@last + (v@last - v@last. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n,int p){\n  int l, i, v;\n\n  l=37;\n  i=l;\n  v=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 37;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant (i == l) ==> (v == 6);\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant v == 6 || v == 0;\n    loop invariant i <= 37;\n    loop invariant (i == 37) ==> (v == 6);\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n    loop invariant 0 <= i && i <= l;\n\n    loop assigns i, v;\n    loop variant i;\n  */\nwhile (i>0) {\n      v = v-v;\n      v = v+v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v, g, m;\n\n  l=48;\n  i=l;\n  v=-1;\n  g=i;\n  m=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      g = g+m;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (m == 48) && (g == 48) && (v == -1) && (i == 48) && (l == 48) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      g = g+m;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: g: g@last -> g@last + m@last; i: i@last -> i@last - 1. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'g', 'i', 'l', 'm', 'n', 'p', 'q']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v, g, m;\n\n  l=48;\n  i=l;\n  v=-1;\n  g=i;\n  m=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant (g + m*i) == (l*(m+1));\n    loop invariant 0 <= i <= l;\n    loop invariant m == l;\n    loop invariant g - m*(l - i) == l;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant a == \\at(a, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i <= 48;\n    loop invariant g == 2352 - 48*i;\n    loop invariant l == 48;\n    loop invariant m == 48;\n    loop invariant g == l + m*(l - i);\n    loop assigns g, i;\n  */\n  while (i>0) {\n      g = g+m;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p,int q){\n  int l, i, v, o;\n\n  l=79;\n  i=l;\n  v=q;\n  o=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      o = o+v;\n      o = 1;\n      v = o-v;\n      v = v+1;\n      o = o+i;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (o == 3) && (v == \\at(q, Pre)) && (i == 79) && (l == 79) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      o = o+v;\n      o = 1;\n      v = o-v;\n      v = v+1;\n      o = o+i;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; o: o@last -> 1 + i@last; v: v@last -> 1 - (v@last + 1) + 1. Unchanged: l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'o', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p,int q){\n  int l, i, v, o;\n\n  l=79;\n  i=l;\n  v=q;\n  o=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant ((i == 79 && o == 3 && v == q) || (o - i == 2));\n    loop invariant i >= 0;\n    loop invariant l == 79;\n    loop invariant q == \\at(q, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant 0 <= i && i <= 79;\n    loop invariant ((79 - i) % 2 == 0) <==> (v == \\at(q, Pre));\n    loop invariant (i < 79) ==> o == i + 2;\n    loop invariant m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n    loop invariant o >= 1;\n    loop invariant o <= i + 3;\n    loop invariant i < 79 ==> o == i + 2;\n    loop invariant (i == 79 && o == 3) || (o - i == 2);\n    loop invariant (i % 2 == 1) ==> (v == \\at(q, Pre));\n    loop invariant (i % 2 == 0) ==> (v == 1 - \\at(q, Pre));\n    loop assigns v, o, i;\n  */\n  while (i>0) {\n      v = v+1;\n      o = o+v;\n      o = 1;\n      v = o-v;\n      v = v+1;\n      o = o+i;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v;\n\n  l=32;\n  i=l;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v-v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 32) && (l == 32) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v-v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last - v@last. Unchanged: a keeps a@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v;\n\n  l=32;\n  i=l;\n  v=0;\n\n  \n  /*@\n\n    loop invariant v == 0;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant l == 32;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant i <= 32;\n\n    loop invariant i <= l;\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant a == \\at(a, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v-v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n,int p){\n  int l, i, v, q, s;\n\n  l=69;\n  i=0;\n  v=l;\n  q=p;\n  s=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      q = q+s;\n      s = s+v;\n      v = v+i;\n      s = l;\n      q = q+1;\n      q = q+s;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (s == \\at(n, Pre)) && (q == \\at(p, Pre)) && (v == 69) && (i == 0) && (l == 69) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      q = q+s;\n      s = s+v;\n      v = v+i;\n      s = l;\n      q = q+1;\n      q = q+s;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; q: q@last -> q@last + s@last + 1 + l@last; s: s@last -> l@last; v: v@last -> v@last + i@last. Unchanged: b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'n', 'p', 'q', 's', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n,int p){\n  int l, i, v, q, s;\n\n  l=69;\n  i=0;\n  v=l;\n  q=p;\n  s=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i && i <= l;\n    loop invariant v == l + i*(i-1)/2;\n    loop invariant (i == 0) ==> (q == p);\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant l == 69;\n    loop invariant 0 <= i <= l;\n    loop invariant (i == 0) ==> (s == n);\n    loop invariant (i > 0) ==> (s == l);\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v == 69 + i*(i-1)/2;\n    loop assigns q, s, v, i;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      q = q+s;\n      s = s+v;\n      v = v+i;\n      s = l;\n      q = q+1;\n      q = q+s;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int p){\n  int l, i, v, u, q;\n\n  l=a+7;\n  i=0;\n  v=a;\n  u=3;\n  q=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      u = u+v;\n      q = q+u;\n      v = v+q;\n      u = q-u;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      u = u+v;\n      q = q+u;\n      v = v+q;\n      u = q-u;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'p', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int p){\n  int l, i, v, u, q;\n\n  l=a+7;\n  i=0;\n  v=a;\n  u=3;\n  q=5;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n\n    loop invariant l == a + 7;\n\n    loop invariant a == \\at(a, Pre);\n\n\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant (l < 0) || (i <= l);\n\n    loop invariant (i == 0) ==> (v == a && u == 3 && q == 5);\n\n    loop invariant a == \\at(a,Pre);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant n == \\at(n,Pre);\n\n    loop invariant p == \\at(p,Pre);\n\n    loop invariant a == \\at(a, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop assigns i, v, u, q;\n\n  */\n  while (i<l) {\n      v = v+1;\n      u = u+v;\n      q = q+u;\n      v = v+q;\n      u = q-u;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int q){\n  int l, i, v, d;\n\n  l=q;\n  i=0;\n  v=-2;\n  d=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      d = d+d;\n      d = d+v;\n      v = v+2;\n      v = v+d;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (d == 0) && (v == -2) && (i == 0) && (l == \\at(q, Pre)) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      d = d+d;\n      d = d+v;\n      v = v+2;\n      v = v+d;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: d: d@last -> d@last + d@last + v@last; i: i@last -> i@last + 1; v: v@last -> v@last + 2 + (d@last + d@last + v@last. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'd', 'i', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int q){\n  int l, i, v, d;\n\n  l=q;\n  i=0;\n  v=-2;\n  d=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant d <= 0;\n   loop invariant v <= -2;\n   loop invariant d + v <= -2;\n   loop invariant 0 <= i;\n   loop invariant l == \\at(q, Pre);\n   loop invariant i >= 0;\n   loop invariant i <= l || l < 0;\n   loop invariant d >= v;\n   loop invariant l == q;\n\n   loop invariant q == \\at(q, Pre);\n   loop invariant a == \\at(a, Pre);\n   loop invariant b == \\at(b, Pre);\n   loop invariant m == \\at(m, Pre);\n   loop invariant d % 2 == 0;\n   loop invariant v % 2 == 0;\n   loop assigns d, v, i;\n   loop variant l - i;\n */\nwhile (i<l) {\n      d = d+d;\n      d = d+v;\n      v = v+2;\n      v = v+d;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p,int q){\n  int l, i, v, y;\n\n  l=54;\n  i=0;\n  v=l;\n  y=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      y = y+4;\n      if (i+2<=b+l) {\n          v = v+i;\n      }\n      else {\n          v = y-v;\n      }\n      v = n;\n      y = y+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (y == \\at(p, Pre)) && (v == 54) && (i == 0) && (l == 54) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      y = y+4;\n      if (i+2<=b+l) {\n          v = v+i;\n      }\n      else {\n          v = y-v;\n      }\n      v = n;\n      y = y+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 2 > b@last + l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> n@last; y: y@last -> y@last + 4 + n@last. Unchanged: b keeps b@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'p', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p,int q){\n  int l, i, v, y;\n\n  l=54;\n  i=0;\n  v=l;\n  y=p;\n\n  \n  /*@\n\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l;\n\n    loop invariant l == 54;\n\n    loop invariant (i > 0) ==> (v == n);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant y == p + i * (n + 4);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant y == p + i*(4 + n);\n\n    loop invariant (i == 0) ==> (v == 54);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant y == \\at(p,Pre) + i*(n + 4);\n\n    loop invariant b == \\at(b,Pre);\n\n    loop invariant n == \\at(n,Pre);\n\n    loop invariant p == \\at(p,Pre);\n\n    loop invariant q == \\at(q,Pre);\n\n    loop assigns v, y, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+3;\n      y = y+4;\n      if (i+2<=b+l) {\n          v = v+i;\n      }\n      else {\n          v = y-v;\n      }\n      v = n;\n      y = y+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n,int q){\n  int l, i, v, w;\n\n  l=16;\n  i=0;\n  v=n;\n  w=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+w+w;\n      v = v+1;\n      if (w+6<l) {\n          w = w+1;\n      }\n      i = i+4;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (w == 16) && (v == \\at(n, Pre)) && (i == 0) && (l == 16) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+w+w;\n      v = v+1;\n      if (w+6<l) {\n          w = w+1;\n      }\n      i = i+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (w@last + 6 >= l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 4; v: v@last -> v@last + w@last + w@last + 1; w: w@last -> w@last + 1. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'n', 'q', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n,int q){\n  int l, i, v, w;\n\n  l=16;\n  i=0;\n  v=n;\n  w=l;\n\n  \n  /*@\n\n    loop invariant l == 16;\n\n    loop invariant 0 <= i && i <= l && i % 4 == 0;\n\n    loop invariant 16 <= w && w <= l;\n\n    loop invariant v >= \\at(n, Pre) + 33*(i/4);\n\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n\n    loop invariant w == l;\n\n    loop invariant i % 4 == 0;\n\n    loop invariant v == n + 33 * (i / 4);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant w == 16;\n\n    loop invariant v >= n;\n\n    loop invariant v == n + (i/4) * (2*w + 1);\n\n    loop invariant v == n + (i/4) * (2*l + 1);\n\n    loop assigns i, v, w;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      v = v+w+w;\n      v = v+1;\n      if (w+6<l) {\n          w = w+1;\n      }\n      i = i+4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int m){\n  int l, i, v;\n\n  l=a+20;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v-v;\n      if (v+3<l) {\n          v = v+v;\n      }\n      else {\n          v = v+v;\n      }\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(a, Pre) + 20) && (i == \\at(a, Pre) + 20) && (l == \\at(a, Pre) + 20) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v-v;\n      if (v+3<l) {\n          v = v+v;\n      }\n      else {\n          v = v+v;\n      }\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last - v@last + 3 >= l@last; i@last > 0; i@last > 0). Changed: i: i@last -> i@last / 2; v: v@last -> v@last - v@last + (v@last - v@last. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int m){\n  int l, i, v;\n\n  l=a+20;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == a + 20;\n\n    loop invariant i <= l;\n    loop invariant v == 0 || v == i;\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant v <= i;\n\n    loop invariant v <= l;\n    loop invariant i <= a + 20;\n    loop assigns v, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v-v;\n      if (v+3<l) {\n          v = v+v;\n      }\n      else {\n          v = v+v;\n      }\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int n){\n  int l, i, v, g, x;\n\n  l=30;\n  i=l;\n  v=l;\n  g=6;\n  x=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+3;\n      x = x+2;\n      if (i+5<=v+l) {\n          x = g-x;\n      }\n      v = v+3;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (x == 30) && (g == 6) && (v == 30) && (i == 30) && (l == 30) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+3;\n      x = x+2;\n      if (i+5<=v+l) {\n          x = g-x;\n      }\n      v = v+3;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 5 <= v@last + 3 + l@last; i@last > 0; i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + 3 + 3; x: x@last -> x@last + 2. Unchanged: a keeps a@last; b keeps b@last; g keeps g@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'g', 'i', 'l', 'm', 'n', 'v', 'x']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int n){\n  int l, i, v, g, x;\n\n  l=30;\n  i=l;\n  v=l;\n  g=6;\n  x=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= 30;\n    loop invariant v == 210 - 6*i;\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant 0 <= i && i <= l;\n    loop invariant x % 2 == l % 2;\n\n    loop invariant g == 6;\n    loop invariant l == 30;\n    loop invariant v + 6*i == 210;\n    loop invariant i <= l;\n    loop assigns v, x, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+3;\n      x = x+2;\n      if (i+5<=v+l) {\n          x = g-x;\n      }\n      v = v+3;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=27;\n  i=l;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v-v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(b, Pre)) && (i == 27) && (l == 27) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v-v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last - v@last. Unchanged: b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=27;\n  i=l;\n  v=b;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant l == 27;\n\n    loop invariant (v == 0) || (i == 27);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant i <= 27;\n\n    loop invariant i < 27 ==> v == 0;\n\n    loop invariant i <= l;\n\n\n    loop invariant (i == l) ==> (v == b);\n\n    loop invariant (i < l) ==> (v == 0);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant (i == 27) ==> (v == \\at(b, Pre));\n\n    loop invariant (i < 27) ==> (v == 0);\n\n    loop invariant v == \\at(b, Pre) || v == 0;\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\nwhile (i>0) {\n      v = v-v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p,int q){\n  int l, i, v;\n\n  l=p-6;\n  i=0;\n  v=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+1<l) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 1) && (i == 0) && (l == \\at(p, Pre) - 6) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+1<l) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last + 1 >= l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + v@last. Unchanged: l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p,int q){\n  int l, i, v;\n\n  l=p-6;\n  i=0;\n  v=1;\n\n  \n  /*@\n\n    loop invariant l == \\at(p, Pre) - 6;\n\n\n    loop invariant v >= 1;\n\n    loop invariant i >= 0;\n\n    loop invariant l == p - 6;\n\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant 0 <= i;\n\n\n    loop invariant (l <= 1) ==> (v == 1);\n\n    loop invariant (l < 0) || (i <= l);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      if (v+1<l) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n,int p){\n  int l, i, v, f, t;\n\n  l=68;\n  i=0;\n  v=3;\n  f=8;\n  t=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      f = f+v;\n      f = f+i;\n      t = v-t;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (t == \\at(p, Pre)) && (f == 8) && (v == 3) && (i == 0) && (l == 68) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      f = f+v;\n      f = f+i;\n      t = v-t;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: f: f@last -> f@last + (v@last + 1) + i@last; i: i@last -> i@last + 1; t: t@last -> v@last + 1 - t@last; v: v@last -> v@last + 1. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'f', 'i', 'l', 'n', 'p', 't', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n,int p){\n  int l, i, v, f, t;\n\n  l=68;\n  i=0;\n  v=3;\n  f=8;\n  t=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 3 + i;\n    loop invariant f == i*i + 3*i + 8;\n    loop invariant (i % 2 == 0) ==> (t == p + i/2);\n    loop invariant (i % 2 == 1) ==> (t == 4 - p + i/2);\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant 0 <= i <= l;\n    loop invariant v == i + 3;\n    loop invariant f == 8 + i*i + 3*i;\n    loop invariant p == \\at(p, Pre);\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant (i % 2 == 1) ==> (t == i/2 + 4 - \\at(p, Pre));\n    loop invariant l == 68;\n    loop invariant (i % 2 != 0) ==> (t == -p + 4 + i/2);\n    loop assigns v, f, t, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      f = f+v;\n      f = f+i;\n      t = v-t;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int p,int q){\n  int l, i, v, c;\n\n  l=80;\n  i=0;\n  v=l;\n  c=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      c = c+3;\n      c = c+1;\n      i = i+4;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (c == \\at(k, Pre)) && (v == 80) && (i == 0) && (l == 80) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      c = c+3;\n      c = c+1;\n      i = i+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: c: c@last -> c@last + 3 + 1; i: i@last -> i@last + 4; v: v@last -> v@last + 3. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'c', 'i', 'k', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int p,int q){\n  int l, i, v, c;\n\n  l=80;\n  i=0;\n  v=l;\n  c=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant i % 4 == 0;\n    loop invariant c - i == k;\n    loop invariant 4*v - 3*i == 4*l;\n    loop invariant l == 80;\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant 0 <= i <= l;\n    loop invariant c == k + i;\n    loop invariant v == l + 3 * (i/4);\n    loop invariant b == \\at(b, Pre) && k == \\at(k, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n    loop invariant c - k == i;\n    loop invariant 4*(v - 80) == 3*i;\n    loop invariant v == 80 + 3 * (i / 4);\n    loop invariant c == k + 4 * (i / 4);\n    loop invariant k == \\at(k, Pre) && b == \\at(b, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n    loop assigns v, c, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+3;\n      c = c+3;\n      c = c+1;\n      i = i+4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int q){\n  int l, i, v, c;\n\n  l=17;\n  i=l;\n  v=m;\n  c=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      c = c-1;\n      if (i+6<=l+l) {\n          v = v+4;\n      }\n      c = c+6;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (c == -4) && (v == \\at(m, Pre)) && (i == 17) && (l == 17) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      c = c-1;\n      if (i+6<=l+l) {\n          v = v+4;\n      }\n      c = c+6;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 6 <= l@last + l@last; i@last > 0; i@last > 0). Changed: c: c@last -> c@last - 1 + 6; i: i@last -> i@last - 1; v: v@last -> v@last + 1. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'c', 'i', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int q){\n  int l, i, v, c;\n\n  l=17;\n  i=l;\n  v=m;\n  c=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= 17;\n    loop invariant c == 81 - 5*i;\n    loop invariant v == \\at(m,Pre) + 5*(17 - i);\n    loop invariant a == \\at(a,Pre) && m == \\at(m,Pre) && n == \\at(n,Pre) && q == \\at(q,Pre);\n    loop invariant v == \\at(m, Pre) + 85 - 5*i;\n    loop invariant l == 17;\n    loop invariant a == \\at(a, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n    loop invariant v == m + 5*(17 - i);\n    loop invariant a == \\at(a,Pre);\n    loop invariant m == \\at(m,Pre);\n    loop invariant n == \\at(n,Pre);\n    loop invariant q == \\at(q,Pre);\n    loop invariant v == m + 85 - 5*i;\n    loop invariant i <= l;\n    loop invariant v - c == m + 4;\n    loop assigns v, c, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+1;\n      c = c-1;\n      if (i+6<=l+l) {\n          v = v+4;\n      }\n      c = c+6;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int p){\n  int l, i, v;\n\n  l=45;\n  i=0;\n  v=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%2)==0) {\n          v = v+4;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -2) && (i == 0) && (l == 45) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%2)==0) {\n          v = v+4;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 2 != 0; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 4. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int p){\n  int l, i, v;\n\n  l=45;\n  i=0;\n  v=-2;\n\n  \n  /*@\n\n    loop invariant v == -2 + 4 * ((i + 1) / 2);\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant l == 45;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop assigns v, i;\n\n  */\n  while (i<l) {\n      if ((i%2)==0) {\n          v = v+4;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int p,int q){\n  int l, i, v, a;\n\n  l=(k%12)+15;\n  i=0;\n  v=p;\n  a=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+a+a;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (a == \\at(q, Pre)) && (v == \\at(p, Pre)) && (i == 0) && (l == \\at(k, Pre) % 12 + 15) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+a+a;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + a@last + a@last. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int p,int q){\n  int l, i, v, a;\n\n  l=(k%12)+15;\n  i=0;\n  v=p;\n  a=q;\n\n  /*>>> LOOP INVARIANT TO FILL <<<*/\n    /*@\n    loop invariant i <= l;\n    loop invariant l == (k % 12) + 15;\n    loop invariant v == p + 2*a*i;\n    loop invariant a == q;\n    loop invariant i >= 0;\n    loop invariant k == \\at(k, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant l == (k%12) + 15;\n    loop invariant 0 <= i && i <= l;\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = v+a+a;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int q){\n  int l, i, v, u, e;\n\n  l=14;\n  i=l;\n  v=i;\n  u=a;\n  e=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      u = u+v;\n      u = u+m;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (e == \\at(n, Pre)) && (u == \\at(a, Pre)) && (v == 14) && (i == 14) && (l == 14) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      u = u+v;\n      u = u+m;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; u: u@last -> u@last + (v@last + 1) + m@last; v: v@last -> v@last + 1. Unchanged: a keeps a@last; e keeps e@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int q){\n  int l, i, v, u, e;\n\n  l=14;\n  i=l;\n  v=i;\n  u=a;\n  e=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 28 - i;\n    loop invariant u == a + (14 - i) * (14 + m) + (14 - i) * ((14 - i) + 1) / 2;\n    loop invariant i >= 0;\n    loop invariant i <= 14;\n    loop invariant a == \\at(a, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant u == a + (14 - i) * (14 + m) + ((14 - i) * (15 - i)) / 2;\n    loop invariant n == \\at(n, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i + v == 28;\n\n    loop invariant u == a + (l - i) * (l + 1 + m) + ((l - i) * (l - i - 1)) / 2;\n    loop invariant i <= l;\n    loop invariant v + i == 28;\n    loop invariant u == a + (14 - i) * m + 14 * (14 - i) + ((14 - i) * (15 - i)) / 2;\n    loop assigns v, u, i;\n  */\n  while (i>0) {\n      v = v+1;\n      u = u+v;\n      u = u+m;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n,int p){\n  int l, i, v, t;\n\n  l=a+11;\n  i=0;\n  v=i;\n  t=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v!=0&&t!=0) {\n      if (v>t) {\n          v = v-t;\n      }\n      else {\n          t = t-v;\n      }\n      v = v+1;\n      t = t-1;\n      t = v-t;\n      v = v+i;\n      t = l;\n      v = v+5;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (t == \\at(b, Pre)) && (v == 0) && (i == 0) && (l == \\at(a, Pre) + 11) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (v!=0&&t!=0) {\n      if (v>t) {\n          v = v-t;\n      }\n      else {\n          t = t-v;\n      }\n      v = v+1;\n      t = t-1;\n      t = v-t;\n      v = v+i;\n      t = l;\n      v = v+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last > t@last; t@last != 0; v@last != 0; t@last != 0; v@last != 0). Changed: t: t@last -> l@last; v: v@last -> v@last + 1 + i@last + 5. Unchanged: a keeps a@last; b keeps b@last; i keeps i@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'n', 'p', 't', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n,int p){\n  int l, i, v, t;\n\n  l=a+11;\n  i=0;\n  v=i;\n  t=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a,Pre);\n    loop invariant b == \\at(b,Pre);\n    loop invariant n == \\at(n,Pre);\n    loop invariant p == \\at(p,Pre);\n    loop invariant l == a + 11;\n    loop invariant v >= 0;\n    loop invariant i == 0;\n    loop invariant t == \\at(b,Pre) || t == l;\n    loop invariant (\\at(b,Pre) ==> v == 0);\n    loop invariant v == 0 || t == l;\n    loop invariant l == \\at(a, Pre) + 11;\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop assigns v, t;\n  */\nwhile (v!=0&&t!=0) {\n      if (v>t) {\n          v = v-t;\n      }\n      else {\n          t = t-v;\n      }\n      v = v+1;\n      t = t-1;\n      t = v-t;\n      v = v+i;\n      t = l;\n      v = v+5;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n,int p){\n  int l, i, v;\n\n  l=67;\n  i=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = n;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 0) && (l == 67) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = n;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> n@last. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n,int p){\n  int l, i, v;\n\n  l=67;\n  i=0;\n  v=0;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant (i == 0) ==> (v == 0);\n\n    loop invariant (i > 0) ==> (v == n);\n\n    loop invariant l == 67;\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant 0 <= i;\n\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop invariant i == 0 ==> v == 0;\n\n    loop invariant i > 0 ==> v == n;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop assigns v, i;\n\n  */\n  while (i<l) {\n      v = n;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int p){\n  int l, i, v;\n\n  l=m+10;\n  i=0;\n  v=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (i+4<=m+l) {\n          v = v+1;\n      }\n      v = v-v;\n      if (l<i+1) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -2) && (i == 0) && (l == \\at(m, Pre) + 10) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (i+4<=m+l) {\n          v = v+1;\n      }\n      v = v-v;\n      if (l<i+1) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (l@last >= i@last + 1; i@last + 4 <= m@last + l@last; i@last < l@last; i@last + 4 > m@last + l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last - v@last. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int p){\n  int l, i, v;\n\n  l=m+10;\n  i=0;\n  v=-2;\n\n  \n  /*@\n\n    loop invariant l == m + 10;\n\n    loop invariant (l <= 0) || (i <= l);\n\n    loop invariant (i == 0) ==> (v == -2);\n\n\n    loop invariant v == -2 <==> i == 0;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant (v == -2) ==> (i == 0);\n\n    loop invariant v <= 0;\n\n    loop invariant k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\nwhile (i<l) {\n      if (i+4<=m+l) {\n          v = v+1;\n      }\n      v = v-v;\n      if (l<i+1) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int p){\n  int l, i, v;\n\n  l=a-3;\n  i=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = i-3;\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 0) && (l == \\at(a, Pre) - 3) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = i-3;\n      v = v+1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> i@last - 3 + 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int p){\n  int l, i, v;\n\n  l=a-3;\n  i=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v <= i;\n    loop invariant v >= i - 4;\n    loop invariant i >= 0;\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant l == a - 3;\n    loop invariant i - 3 <= v <= i;\n\n    loop invariant (i == 0) ==> (v == 0);\n    loop invariant (i > 0) ==> (v == i - 3);\n    loop invariant (i == 0 && v == 0) || (i >= 1 && v == i - 3);\n    loop invariant ((i == 0 && v == 0) || (v == i - 3));\n    loop assigns i, v;\n    loop variant (l - i);\n  */\n  while (i<l) {\n      v = i-3;\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int p){\n  int l, i, v;\n\n  l=k+11;\n  i=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      v = v+1;\n      if ((i%2)==0) {\n          v = v+2;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(k, Pre)) && (i == 0) && (l == \\at(k, Pre) + 11) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      v = v+1;\n      if ((i%2)==0) {\n          v = v+2;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 2 != 0; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + v@last + 1 + 2. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int p){\n  int l, i, v;\n\n  l=k+11;\n  i=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == k + 11;\n    loop invariant 0 <= i;\n\n\n    loop invariant (l < 0) || (i <= l);\n\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant l == \\at(k, Pre) + 11;\n    loop invariant i >= 0;\n    loop invariant (i == 0) ==> (v == \\at(k, Pre));\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = v+v;\n      v = v+1;\n      if ((i%2)==0) {\n          v = v+2;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int q){\n  int l, i, v;\n\n  l=23;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      v = v+v;\n      if (i+7<=a+l) {\n          v = i;\n      }\n      i = i+4;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 23) && (i == 0) && (l == 23) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      v = v+v;\n      if (i+7<=a+l) {\n          v = i;\n      }\n      i = i+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 7 > a@last + l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 4; v: v@last -> i@last. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int q){\n  int l, i, v;\n\n  l=23;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 23;\n    loop invariant i % 4 == 0;\n    loop invariant 0 <= i;\n\n    loop invariant v >= 0;\n    loop invariant v <= l;\n    loop invariant 0 <= v && v <= l;\n    loop invariant a == \\at(a, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i <= l + 1;\n    loop invariant i <= l + 3;\n    loop invariant 0 <= v <= l;\n    loop invariant a == \\at(a, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n    loop invariant (i == 0) ==> (v == l);\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v-v;\n      v = v+v;\n      if (i+7<=a+l) {\n          v = i;\n      }\n      i = i+4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int n,int p){\n  int l, i, v, q;\n\n  l=30;\n  i=0;\n  v=i;\n  q=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+3;\n      q = q+2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (q == -4) && (v == 0) && (i == 0) && (l == 30) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+3;\n      q = q+2;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; q: q@last -> q@last + 2; v: v@last -> v@last + 3. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int n,int p){\n  int l, i, v, q;\n\n  l=30;\n  i=0;\n  v=i;\n  q=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 3*i;\n    loop invariant q == -4 + 2*i;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant l == 30;\n    loop invariant n == \\at(n, Pre);\n    loop assigns i, v, q;\n  */\n  while (i<l) {\n      v = v+3;\n      q = q+2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int m,int n){\n  int l, i, v;\n\n  l=(m%14)+14;\n  i=l;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+2;\n      v = m+(-4);\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 4) && (i == \\at(m, Pre) % 14 + 14) && (l == \\at(m, Pre) % 14 + 14) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+2;\n      v = m+(-4);\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last / 2; v: v@last -> m@last + -4. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int m,int n){\n  int l, i, v;\n\n  l=(m%14)+14;\n  i=l;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a,Pre);\n    loop invariant k == \\at(k,Pre);\n    loop invariant m == \\at(m,Pre);\n    loop invariant n == \\at(n,Pre);\n    loop invariant l == (\\at(m,Pre) % 14) + 14;\n    loop invariant v == 4 || v == m - 4;\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant i >= 0;\n    loop invariant i <= l;\n\n    loop invariant l == (m % 14) + 14;\n    loop invariant n == \\at(n, Pre);\n    loop invariant 0 <= i <= l;\n    loop invariant (v == 4) || (v == m - 4);\n    loop assigns i, v;\n    loop variant i;\n  */\nwhile (i>0) {\n      v = v+2;\n      v = m+(-4);\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v;\n\n  l=a+17;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 4) && (i == 0) && (l == \\at(a, Pre) + 17) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last - v@last + i@last. Unchanged: a keeps a@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v;\n\n  l=a+17;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant ((i == 0 && v == 4) ||\n                    (i > 0 && v == i - 1 && i <= l));\n\n    loop invariant l == a + 17;\n    loop invariant i >= 0;\n    loop invariant v >= 0;\n    loop invariant v <= i + 4;\n    loop invariant (i == 0) ==> (v == 4);\n    loop invariant (i > 0) ==> (v == i - 1);\n\n    loop invariant l == \\at(a, Pre) + 17;\n    loop invariant 0 <= i;\n    loop invariant a == \\at(a, Pre);\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v-v;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=n-7;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+6<l) {\n          v = v+v;\n      }\n      v = v+i;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 4) && (i == 0) && (l == \\at(n, Pre) - 7) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+6<l) {\n          v = v+v;\n      }\n      v = v+i;\n      v = v+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last + 6 >= l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + v@last + i@last + (v@last + v@last + i@last. Unchanged: b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=n-7;\n  i=0;\n  v=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == n - 7;\n    loop invariant i >= 0;\n    loop invariant v % 2 == 0;\n    loop invariant v >= 4;\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant 0 <= i;\n    loop invariant v >= i;\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant l == \\at(n,Pre) - 7;\n    loop invariant b == \\at(b,Pre);\n    loop invariant n == \\at(n,Pre);\n    loop invariant p == \\at(p,Pre);\n    loop invariant v >= 2*i + 4;\n    loop invariant m == \\at(m,Pre);\n    loop assigns i, v;\n  */\nwhile (i<l) {\n      if (v+6<l) {\n          v = v+v;\n      }\n      v = v+i;\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int q){\n  int l, i, v;\n\n  l=q;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = 8;\n      if (i<v+4) {\n          v = v-v;\n      }\n      else {\n          v = v+i;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(m, Pre)) && (i == 0) && (l == \\at(q, Pre)) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = 8;\n      if (i<v+4) {\n          v = v-v;\n      }\n      else {\n          v = v+i;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last >= 8 + 4; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> 8 - 8. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int q){\n  int l, i, v;\n\n  l=q;\n  i=0;\n  v=m;\n\n  \n  /*@\n\n    loop invariant l == q;\n\n    loop invariant 0 <= i;\n\n    loop invariant i <= l || l < 0;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant l == \\at(q, Pre);\n\n    loop invariant i >= 0;\n\n\n    loop invariant (i == 0) ==> v == \\at(m, Pre);\n\n    loop invariant (i != 0) ==> ( ((i - 1) < 12) ==> v == 0 ) && ( ((i - 1) >= 12) ==> v == (i - 1) + 8 );\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = 8;\n      if (i<v+4) {\n          v = v-v;\n      }\n      else {\n          v = v+i;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int p,int q){\n  int l, i, v, y;\n\n  l=23;\n  i=l;\n  v=a;\n  y=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+y+y;\n      v = v+1;\n      y = y+1;\n      if ((i%7)==0) {\n          v = v+1;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (y == \\at(k, Pre)) && (v == \\at(a, Pre)) && (i == 23) && (l == 23) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+y+y;\n      v = v+1;\n      y = y+1;\n      if ((i%7)==0) {\n          v = v+1;\n      }\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 7 != 0; i@last > 0; i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + y@last + y@last + 1 + 1; y: y@last -> y@last + 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'p', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int p,int q){\n  int l, i, v, y;\n\n  l=23;\n  i=l;\n  v=a;\n  y=k;\n\n  /*>>> LOOP INVARIANT TO FILL <<<*/\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant y == k + (23 - i);\n    loop invariant v == a + 2*k*(23 - i) + (23 - i)*(23 - i) + (27 - i)/7;\n    loop invariant i >= 0;\n    loop invariant i <= 23;\n    loop invariant 0 <= i && i <= 23;\n    loop invariant y >= k;\n    loop invariant i + y == k + 23;\n\n    loop invariant a == \\at(a,Pre);\n    loop invariant k == \\at(k,Pre);\n    loop invariant p == \\at(p,Pre);\n    loop invariant q == \\at(q,Pre);\n    loop assigns v, i, y;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+y+y;\n      v = v+1;\n      y = y+1;\n      if ((i%7)==0) {\n          v = v+1;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int q){\n  int l, i, v, o;\n\n  l=(b%12)+15;\n  i=0;\n  v=a;\n  o=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+5;\n      o = o+4;\n      o = o+1;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (o == \\at(b, Pre) % 12 + 15) && (v == \\at(a, Pre)) && (i == 0) && (l == \\at(b, Pre) % 12 + 15) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+5;\n      o = o+4;\n      o = o+1;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; o: o@last -> o@last + 4 + 1; v: v@last -> v@last + 5 + i@last. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'o', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int q){\n  int l, i, v, o;\n\n  l=(b%12)+15;\n  i=0;\n  v=a;\n  o=l;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant l == (\\at(b, Pre) % 12) + 15;\n\n    loop invariant o == l + 5*i;\n\n    loop invariant v == a + 5*i + i*(i-1)/2;\n\n    loop invariant l == (b % 12) + 15;\n\n    loop invariant i <= l;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant v == a + 5*i + (i * (i - 1)) / 2;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant l == (\\at(b,Pre) % 12) + 15;\n\n    loop invariant a == \\at(a,Pre);\n\n    loop invariant b == \\at(b,Pre);\n\n    loop assigns v, o, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+5;\n      o = o+4;\n      o = o+1;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int p){\n  int l, i, v, f, j;\n\n  l=(m%6)+16;\n  i=0;\n  v=6;\n  f=n;\n  j=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+f+j;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (j == \\at(n, Pre)) && (f == \\at(n, Pre)) && (v == 6) && (i == 0) && (l == \\at(m, Pre) % 6 + 16) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+f+j;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + f@last + j@last. Unchanged: a keeps a@last; f keeps f@last; j keeps j@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'f', 'i', 'j', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int p){\n  int l, i, v, f, j;\n\n  l=(m%6)+16;\n  i=0;\n  v=6;\n  f=n;\n  j=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i <= l;\n    loop invariant v == 6 + i * (f + j);\n    loop invariant l == (m % 6) + 16;\n    loop invariant j == n;\n    loop invariant n == \\at(n, Pre);\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v == 6 + i*(f + j);\n    loop invariant l == (\\at(m, Pre) % 6) + 16;\n    loop invariant a == \\at(a, Pre);\n    loop invariant 0 <= i;\n    loop invariant f == n;\n    loop invariant m == \\at(m, Pre);\n    loop invariant v == 6 + (f + j) * i;\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = v+f+j;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int p,int q){\n  int l, i, v, u;\n\n  l=56;\n  i=0;\n  v=1;\n  u=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+u+u;\n      v = v+1;\n      u = u+1;\n      i = i+4;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (u == \\at(q, Pre)) && (v == 1) && (i == 0) && (l == 56) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+u+u;\n      v = v+1;\n      u = u+1;\n      i = i+4;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'p', 'q', 'u', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int p,int q){\n  int l, i, v, u;\n\n  l=56;\n  i=0;\n  v=1;\n  u=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 56;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant i % 4 == 0;\n    loop invariant u == \\at(q, Pre) + i/4;\n    loop invariant v == (i/4)*(i/4) + 2*\\at(q,Pre)*(i/4) + 1;\n    loop invariant 4*u - i == 4*\\at(q,Pre);\n    loop invariant 16*v == i*i + 8*\\at(q,Pre)*i + 16;\n    loop invariant b == \\at(b,Pre);\n    loop invariant m == \\at(m,Pre);\n    loop invariant p == \\at(p,Pre);\n    loop invariant 0 <= i;\n    loop invariant v == (i/4)*(i/4) + 2*\\at(q, Pre)*(i/4) + 1;\n    loop invariant u == \\at(q,Pre) + i/4;\n    loop invariant v == (i/4)*(i/4) + 2 * \\at(q,Pre) * (i/4) + 1;\n    loop invariant q == \\at(q,Pre);\n    loop invariant u == \\at(q,Pre) + (i/4);\n    loop assigns v, u, i;\n  */\n  while (i<l) {\n      v = v+u+u;\n      v = v+1;\n      u = u+1;\n      i = i+4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n,int p){\n  int l, i, v;\n\n  l=a+13;\n  i=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%5)==0) {\n          v = v+5;\n      }\n      else {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(k, Pre)) && (i == 0) && (l == \\at(a, Pre) + 13) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%5)==0) {\n          v = v+5;\n      }\n      else {\n          v = v+1;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 5 != 0; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 5. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n,int p){\n  int l, i, v;\n\n  l=a+13;\n  i=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == k + i + 4 * ((i + 4) / 5);\n    loop invariant l == a + 13;\n    loop invariant i >= 0;\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant 0 <= i && (l < 0 || i <= l);\n    loop invariant v >= k;\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant 0 <= i;\n\n    loop invariant k + i <= v;\n    loop invariant v <= k + 5*i;\n    loop assigns i, v;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      if ((i%5)==0) {\n          v = v+5;\n      }\n      else {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n,int p){\n  int l, i, v;\n\n  l=58;\n  i=0;\n  v=-1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -1) && (i == 0) && (l == 58) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      v = v-v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 1 - (v@last + 1. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n,int p){\n  int l, i, v;\n\n  l=58;\n  i=0;\n  v=-1;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant (i == 0) ==> (v == -1);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant l == 58;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant (i == 0 ==> v == -1) && (i > 0 ==> v == 0) && (i <= l);\n\n    loop invariant ((i == 0 && v == -1) || (i > 0 && v == 0));\n\n    loop invariant (i == 0 && v == -1) || (i > 0 && v == 0);\n\n    loop invariant i >= 0;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int p,int q){\n  int l, i, v, s;\n\n  l=k;\n  i=l;\n  v=n;\n  s=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+s+s;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (s == \\at(p, Pre)) && (v == \\at(n, Pre)) && (i == \\at(k, Pre)) && (l == \\at(k, Pre)) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+s+s;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + s@last + s@last. Unchanged: k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last; s keeps s@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'n', 'p', 'q', 's', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int p,int q){\n  int l, i, v, s;\n\n  l=k;\n  i=l;\n  v=n;\n  s=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == \\at(n, Pre) + 2 * s * (\\at(k, Pre) - i);\n\n    loop invariant i <= \\at(k, Pre);\n    loop invariant l == k;\n    loop invariant s == \\at(p, Pre);\n    loop invariant v == \\at(n, Pre) + 2 * \\at(p, Pre) * (\\at(k, Pre) - i);\n    loop invariant v == n + 2*s*(k - i);\n    loop invariant i <= k;\n    loop invariant s == p;\n    loop invariant k - i >= 0;\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant v == n + 2 * p * (k - i);\n    loop assigns v, i;\n  */\n  while (i>0) {\n      v = v+s+s;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int p,int q){\n  int l, i, v, t, z;\n\n  l=72;\n  i=0;\n  v=i;\n  t=b;\n  z=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      z = z+3;\n      if (v+4<l) {\n          v = t-v;\n      }\n      else {\n          v = v-p;\n      }\n      v = p-p;\n      if (i+2<=i+l) {\n          t = v-t;\n      }\n      else {\n          z = z+v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (z == \\at(b, Pre)) && (t == \\at(b, Pre)) && (v == 0) && (i == 0) && (l == 72) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      z = z+3;\n      if (v+4<l) {\n          v = t-v;\n      }\n      else {\n          v = v-p;\n      }\n      v = p-p;\n      if (i+2<=i+l) {\n          t = v-t;\n      }\n      else {\n          z = z+v;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 2 > i@last + l@last; v@last + 1 + 4 >= l@last; i@last < l@last; v@last + 1 + 4 < l@last; i@last < l@last; v@last + 1 + 4 >= l@last; i@last < l@last; v@last + 1 + 4 < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; t: t@last -> p@last - p@last - t@last; v: v@last -> p@last - p@last; z: z@last -> z@last + 3. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'p', 'q', 't', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int p,int q){\n  int l, i, v, t, z;\n\n  l=72;\n  i=0;\n  v=i;\n  t=b;\n  z=b;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant z == b + 3*i;\n\n    loop invariant v == 0;\n\n    loop invariant (i % 2 == 0) ==> t == b;\n\n    loop invariant (i % 2 != 0) ==> t == -b;\n\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n\n    loop invariant z == \\at(b, Pre) + 3*i;\n\n    loop invariant t*t == \\at(b, Pre) * \\at(b, Pre);\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant l == 72;\n\n    loop invariant i >= 0;\n\n    loop invariant (i % 2 == 0) ==> t == \\at(b, Pre);\n\n    loop invariant (i % 2 == 1) ==> t == - \\at(b, Pre);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant (i % 2 == 1) ==> t == -b;\n\n    loop invariant z == \\at(b,Pre) + 3*i;\n\n    loop invariant t*t == \\at(b,Pre) * \\at(b,Pre);\n\n    loop invariant a == \\at(a,Pre) && b == \\at(b,Pre) && p == \\at(p,Pre) && q == \\at(q,Pre);\n\n    loop assigns i, v, z, t;\n\n  */\n  while (i<l) {\n      v = v+1;\n      z = z+3;\n      if (v+4<l) {\n          v = t-v;\n      }\n      else {\n          v = v-p;\n      }\n      v = p-p;\n      if (i+2<=i+l) {\n          t = v-t;\n      }\n      else {\n          z = z+v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int q){\n  int l, i, v, y;\n\n  l=17;\n  i=0;\n  v=-8;\n  y=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+y+y;\n      v = v+1;\n      y = y+1;\n      y = y-q;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (y == 4) && (v == -8) && (i == 0) && (l == 17) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+y+y;\n      v = v+1;\n      y = y+1;\n      y = y-q;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + y@last + y@last + 1; y: y@last -> y@last + 1 - q@last. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int q){\n  int l, i, v, y;\n\n  l=17;\n  i=0;\n  v=-8;\n  y=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant y == 4 + i*(1 - q);\n    loop invariant v == -8 + 9*i + (1 - q)*i*(i-1);\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant 0 <= i;\n    loop invariant v == -8 + 9*i + (1 - q)*i*(i - 1);\n    loop invariant l == 17;\n    loop invariant q == \\at(q, Pre);\n    loop invariant y == 4 + i * (1 - q);\n    loop invariant v == -8 + 9 * i + (1 - q) * i * (i - 1);\n    loop invariant y - (1 - q) * i == 4;\n    loop assigns i, v, y;\n  */\n  while (i<l) {\n      v = v+y+y;\n      v = v+1;\n      y = y+1;\n      y = y-q;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int m,int q){\n  int l, i, v;\n\n  l=(m%10)+13;\n  i=0;\n  v=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      v = v-v;\n      if (m<m+4) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -5) && (i == 0) && (l == \\at(m, Pre) % 10 + 13) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      v = v-v;\n      if (m<m+4) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (m@last < m@last + 4; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + i@last - (v@last + i@last) + 1. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int m,int q){\n  int l, i, v;\n\n  l=(m%10)+13;\n  i=0;\n  v=-5;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant (i == 0) ==> (v == -5);\n\n    loop invariant 0 <= i && i <= l && (i == 0 ==> v == -5) && (i > 0 ==> v == 1) && m == \\at(m, Pre) && b == \\at(b, Pre) && k == \\at(k, Pre) && q == \\at(q, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant v >= -5;\n\n    loop invariant v <= 1;\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant l == ((\\at(m, Pre)) % 10) + 13;\n\n    loop invariant i == 0 ==> v == -5;\n\n    loop invariant l == (\\at(m,Pre) % 10) + 13;\n\n    loop invariant b == \\at(b,Pre);\n\n    loop invariant k == \\at(k,Pre);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant q == \\at(q,Pre);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+i;\n      v = v-v;\n      if (m<m+4) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p,int q){\n  int l, i, v, s;\n\n  l=42;\n  i=0;\n  v=p;\n  s=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+2;\n      s = s+v;\n      s = s+s;\n      v = v+s;\n      if (i+2<=n+l) {\n          s = s+i;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (s == \\at(p, Pre)) && (v == \\at(p, Pre)) && (i == 0) && (l == 42) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+2;\n      s = s+v;\n      s = s+s;\n      v = v+s;\n      if (i+2<=n+l) {\n          s = s+i;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 2 > n@last + l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; s: s@last -> s@last + (v@last + 2) + (s@last + (v@last + 2)) + i@last; v: v@last -> v@last + 2 + (s@last + (v@last + 2) + (s@last + (v@last + 2. Unchanged: b keeps b@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'p', 'q', 's', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p,int q){\n  int l, i, v, s;\n\n  l=42;\n  i=0;\n  v=p;\n  s=p;\n\n  /*>>> LOOP INVARIANT TO FILL <<<*/\n    /*@\n    loop invariant 0 <= i <= l;\n    loop invariant (i == 0) ==> (v == p && s == p);\n\n    loop invariant l == 42;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant p == \\at(p,Pre);\n    loop invariant n == \\at(n,Pre);\n    loop invariant b == \\at(b,Pre);\n    loop invariant q == \\at(q,Pre);\n    loop invariant 0 <= i && i <= l;\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop assigns i, v, s;\n  */\n  while (i<l) {\n      v = v+2;\n      s = s+v;\n      s = s+s;\n      v = v+s;\n      if (i+2<=n+l) {\n          s = s+i;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m,int n,int q){\n  int l, i, v;\n\n  l=n;\n  i=l;\n  v=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      if (i<q+4) {\n          v = v+v;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 6) && (i == \\at(n, Pre)) && (l == \\at(n, Pre)) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      if (i<q+4) {\n          v = v+v;\n      }\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last >= q@last + 4; i@last > 0; i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + v@last. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m,int n,int q){\n  int l, i, v;\n\n  l=n;\n  i=l;\n  v=6;\n\n  \n  /*@\n\n\n    loop invariant i <= n;\n\n    loop invariant l == n;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant v >= 6;\n\n    loop invariant v % 6 == 0;\n\n    loop invariant (i > q+3) ==> (v == 6);\n\n    loop invariant v > 0;\n\n\n    loop invariant (i >= q+4) ==> (v == 6);\n\n    loop assigns v, i;\n\n  */\n  while (i>0) {\n      if (i<q+4) {\n          v = v+v;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n,int q){\n  int l, i, v, b;\n\n  l=70;\n  i=l;\n  v=1;\n  b=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+1;\n      b = b+1;\n      v = v+1;\n      b = b+v;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (b == 0) && (v == 1) && (i == 70) && (l == 70) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+1;\n      b = b+1;\n      v = v+1;\n      b = b+v;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: b: b@last -> b@last + 1 + (v@last + 1 + 1; v: v@last -> v@last + 1 + 1. Unchanged: a keeps a@last; i keeps i@last; k keeps k@last; l keeps l@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n,int q){\n  int l, i, v, b;\n\n  l=70;\n  i=l;\n  v=1;\n  b=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 4*b == v*v + 4*v - 5;\n    loop invariant i >= 0;\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i == 70;\n    loop invariant i == l;\n    loop invariant l == 70;\n    loop invariant (v - 1) % 2 == 0;\n    loop invariant v >= 1;\n    loop invariant ((v - 1) % 2) == 0;\n    loop invariant b >= 0;\n    loop invariant b == ((v - 1)/2) * ((v - 1)/2 + 3);\n    loop invariant i <= 70;\n    loop assigns v, b;\n  */\n  while (i>0) {\n      v = v+1;\n      b = b+1;\n      v = v+1;\n      b = b+v;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int m){\n  int l, i, v, f;\n\n  l=m+23;\n  i=0;\n  v=6;\n  f=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+5;\n      f = f+1;\n      if (i+3<=l+l) {\n          v = v+3;\n      }\n      f = f+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (f == \\at(k, Pre)) && (v == 6) && (i == 0) && (l == \\at(m, Pre) + 23) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+5;\n      f = f+1;\n      if (i+3<=l+l) {\n          v = v+3;\n      }\n      f = f+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 3 <= l@last + l@last; i@last < l@last; i@last < l@last). Changed: f: f@last -> f@last + 1 + i@last; i: i@last -> i@last + 1; v: v@last -> v@last + 5. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'f', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int m){\n  int l, i, v, f;\n\n  l=m+23;\n  i=0;\n  v=6;\n  f=k;\n\n  \n  /*@\n\n\n    loop invariant l == m + 23;\n\n    loop invariant 6 + 5*i <= v;\n\n    loop invariant v <= 6 + 8*i;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant f == k + i*(i+1)/2;\n\n    loop invariant l == \\at(m, Pre) + 23;\n\n    loop invariant 0 <= i;\n\n    loop invariant v >= 6 + 5*i;\n\n    loop invariant f == k + i + i*(i-1)/2;\n\n\n    loop invariant (i <= 2*l - 2) ==> (v == 6 + 8*i);\n\n    loop assigns v, f, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+5;\n      f = f+1;\n      if (i+3<=l+l) {\n          v = v+3;\n      }\n      f = f+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n,int p,int q){\n  int l, i, v, h, g;\n\n  l=35;\n  i=0;\n  v=0;\n  h=-6;\n  g=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+h+g;\n      v = v+1;\n      h = h+1;\n      v = v+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (g == \\at(p, Pre)) && (h == -6) && (v == 0) && (i == 0) && (l == 35) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+h+g;\n      v = v+1;\n      h = h+1;\n      v = v+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: h: h@last -> h@last + 1; i: i@last -> i@last + 1; v: v@last -> v@last + h@last + g@last + 1 + i@last. Unchanged: g keeps g@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['g', 'h', 'i', 'k', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n,int p,int q){\n  int l, i, v, h, g;\n\n  l=35;\n  i=0;\n  v=0;\n  h=-6;\n  g=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant h == i - 6;\n   loop invariant v == i * (g + i - 6);\n   loop invariant i <= l;\n   loop invariant i >= 0;\n   loop invariant l == 35;\n   loop invariant k == \\at(k,Pre);\n   loop invariant n == \\at(n,Pre);\n   loop invariant p == \\at(p,Pre);\n   loop invariant q == \\at(q,Pre);\n   loop invariant h == -6 + i;\n   loop invariant g == p;\n   loop invariant k == \\at(k, Pre);\n   loop invariant n == \\at(n, Pre);\n   loop invariant p == \\at(p, Pre);\n   loop invariant q == \\at(q, Pre);\n   loop invariant v == i*i + i*(p - 6);\n   loop invariant v == (h + 6) * (g + h);\n   loop assigns v, h, i;\n */\nwhile (i<l) {\n      v = v+h+g;\n      v = v+1;\n      h = h+1;\n      v = v+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int p){\n  int l, i, v;\n\n  l=40;\n  i=0;\n  v=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      if ((i%8)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+2;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(b, Pre)) && (i == 0) && (l == 40) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      if ((i%8)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+2;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 8 != 0; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 1 - (v@last + 1. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int p){\n  int l, i, v;\n\n  l=40;\n  i=0;\n  v=b;\n\n  \n  /*@\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant (i == 0) ==> (v == b);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant l == 40;\n\n\n\n    loop invariant a == \\at(a,Pre);\n\n    loop invariant b == \\at(b,Pre);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant p == \\at(p,Pre);\n\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+1;\n      if ((i%8)==0) {\n          v = v-v;\n      }\n      else {\n          v = v+2;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int p){\n  int l, i, v, s, r;\n\n  l=(p%7)+8;\n  i=0;\n  v=-8;\n  s=3;\n  r=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      s = s+1;\n      v = v+1;\n      s = s+v;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (r == \\at(p, Pre)) && (s == 3) && (v == -8) && (i == 0) && (l == \\at(p, Pre) % 7 + 8) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      s = s+1;\n      v = v+1;\n      s = s+v;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: s: s@last -> s@last + 1 + (v@last + 1 + 1; v: v@last -> v@last + 1 + 1. Unchanged: a keeps a@last; b keeps b@last; i keeps i@last; l keeps l@last; m keeps m@last; p keeps p@last; r keeps r@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'p', 's', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int p){\n  int l, i, v, s, r;\n\n  l=(p%7)+8;\n  i=0;\n  v=-8;\n  s=3;\n  r=p;\n\n  \n  /*@\n\n    loop invariant i == 0;\n\n    loop invariant l == (p % 7) + 8;\n\n    loop invariant v >= -8;\n\n    loop invariant v % 2 == 0;\n\n    loop invariant 4*s == v*v + 4*v - 20;\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant 0 <= i;\n\n    loop invariant l == (\\at(p, Pre) % 7) + 8;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant s == (v*v)/4 + v - 5;\n\n    loop assigns v, s;\n\n  */\n  while (i<l) {\n      v = v+1;\n      s = s+1;\n      v = v+1;\n      s = s+v;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int p){\n  int l, i, v, c;\n\n  l=25;\n  i=0;\n  v=8;\n  c=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+c+c;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (c == \\at(a, Pre)) && (v == 8) && (i == 0) && (l == 25) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+c+c;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + c@last + c@last. Unchanged: a keeps a@last; b keeps b@last; c keeps c@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'c', 'i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int p){\n  int l, i, v, c;\n\n  l=25;\n  i=0;\n  v=8;\n  c=a;\n\n  \n  /*@\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant v == 8 + 2*i*c;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant 0 <= i;\n\n    loop invariant v == 8 + 2 * a * i;\n\n    loop invariant c == a;\n\n    loop invariant l == 25;\n\n    loop invariant i >= 0;\n\n    loop invariant v == 8 + 2*c*i;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+c+c;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n,int p){\n  int l, i, v;\n\n  l=11;\n  i=l;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+i;\n      v = v+1;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(a, Pre)) && (i == 11) && (l == 11) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+i;\n      v = v+1;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + i@last + 1. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n,int p){\n  int l, i, v;\n\n  l=11;\n  i=l;\n  v=a;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= 11;\n\n    loop invariant v == a + (11 - i) * 12 - ((11 - i) * (10 - i)) / 2;\n\n    loop invariant 0 <= i <= 11;\n\n    loop invariant i*i + 3*i + 2*(v - a) == 154;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant v <= a + 77;\n\n    loop invariant 2*v == 2*a + (l - i) * (i + l + 3);\n\n    loop invariant i <= l;\n\n    loop invariant v == \\at(a, Pre) + 77 - i*(i+3)/2;\n\n    loop invariant 0 <= i && i <= 11;\n\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre) && l == 11;\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+i;\n      v = v+1;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n,int q){\n  int l, i, v, w, j;\n\n  l=11;\n  i=l;\n  v=l;\n  w=n;\n  j=b;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      w = w+j;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (j == \\at(b, Pre)) && (w == \\at(n, Pre)) && (v == 11) && (i == 11) && (l == 11) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      w = w+j;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; w: w@last -> w@last + j@last. Unchanged: b keeps b@last; j keeps j@last; l keeps l@last; m keeps m@last; n keeps n@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'j', 'l', 'm', 'n', 'q', 'w']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n,int q){\n  int l, i, v, w, j;\n\n  l=11;\n  i=l;\n  v=l;\n  w=n;\n  j=b;\n\n  \n  /*@\n\n    loop invariant w == n + (l - i) * j;\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i <= 11;\n\n    loop invariant w == n + (11 - i) * j;\n\n    loop invariant l == 11;\n\n    loop invariant j == b;\n\n    loop invariant w == n + (11 - i) * b;\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant w == n + (l - i) * b;\n\n    loop assigns w, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      w = w+j;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v, y, z;\n\n  l=13;\n  i=0;\n  v=l;\n  y=a;\n  z=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+4;\n      y = y+v;\n      z = z+y;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (z == 6) && (y == \\at(a, Pre)) && (v == 13) && (i == 0) && (l == 13) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+4;\n      y = y+v;\n      z = z+y;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 4; y: y@last -> y@last + (v@last + 4; z: z@last -> z@last + (y@last + (v@last + 4. Unchanged: a keeps a@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'p', 'q', 'v', 'y', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v, y, z;\n\n  l=13;\n  i=0;\n  v=l;\n  y=a;\n  z=6;\n\n  \n  /*@\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant v == 13 + 4*i;\n\n    loop invariant y == a + 2*i*i + 15*i;\n\n    loop invariant z == 6 + a*i + (i*(i+1)*(2*i+1))/3 + (15*i*(i+1))/2;\n\n    loop invariant l == 13;\n\n    loop invariant v == l + 4*i;\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant z == 6 + a*i + i*(i+1)*(2*i+1)/3 + 15*i*(i+1)/2;\n\n    loop invariant y == a + i*l + 2*i*(i+1);\n\n    loop invariant z == 6 + i*a + (l * i * (i+1))/2 + (2 * i * (i+1) * (i+2))/3;\n\n    loop assigns v, y, z, i;\n\n  */\n  while (i<l) {\n      v = v+4;\n      y = y+v;\n      z = z+y;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int m){\n  int l, i, v;\n\n  l=61;\n  i=l;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      if ((i%4)==0) {\n          v = v+v;\n      }\n      else {\n          v = v-v;\n      }\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(a, Pre)) && (i == 61) && (l == 61) && (m == \\at(m, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      if ((i%4)==0) {\n          v = v+v;\n      }\n      else {\n          v = v-v;\n      }\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 4 != 0; i@last > 0; i@last > 0). Changed: i: i@last -> i@last / 2; v: v@last -> v@last + v@last. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; m keeps m@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int m){\n  int l, i, v;\n\n  l=61;\n  i=l;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a,Pre);\n    loop invariant b == \\at(b,Pre);\n    loop invariant k == \\at(k,Pre);\n    loop invariant l == 61;\n    loop invariant i >= 0;\n    loop invariant i <= 61;\n\n    loop invariant (i == 61) ==> (v == \\at(a, Pre));\n    loop invariant (i != 61) ==> (v == 0);\n\n    loop invariant a == \\at(a, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant (i == 61) ==> (v == a);\n    loop assigns v, i;\n  */\n  while (i>0) {\n      if ((i%4)==0) {\n          v = v+v;\n      }\n      else {\n          v = v-v;\n      }\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v, t, e;\n\n  l=(n%6)+19;\n  i=0;\n  v=8;\n  t=n;\n  e=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      e = e+4;\n      t = t+i;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (e == \\at(p, Pre)) && (t == \\at(n, Pre)) && (v == 8) && (i == 0) && (l == \\at(n, Pre) % 6 + 19) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      e = e+4;\n      t = t+i;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: e: e@last -> e@last + 4; i: i@last -> i@last + 1; t: t@last -> t@last + i@last; v: v@last -> v@last + 1. Unchanged: a keeps a@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'e', 'i', 'l', 'n', 'p', 'q', 't', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v, t, e;\n\n  l=(n%6)+19;\n  i=0;\n  v=8;\n  t=n;\n  e=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant t == n + i*(i-1)/2;\n    loop invariant e == p + 4*i;\n    loop invariant v == 8 + i;\n    loop invariant i <= l;\n    loop invariant a == \\at(a, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n    loop invariant i >= 0;\n    loop invariant t == n + i*(i - 1)/2;\n    loop invariant a == \\at(a, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant 0 <= i <= l;\n    loop invariant l == ((\\at(n,Pre)) % 6) + 19;\n    loop invariant a == \\at(a,Pre);\n    loop invariant n == \\at(n,Pre);\n    loop invariant p == \\at(p,Pre);\n    loop invariant q == \\at(q,Pre);\n    loop invariant t == \\at(n, Pre) + i*(i-1)/2;\n    loop invariant e == \\at(p, Pre) + 4*i;\n    loop invariant l == (\\at(n, Pre) % 6) + 19;\n    loop assigns v, e, t, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      e = e+4;\n      t = t+i;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int p){\n  int l, i, v, w;\n\n  l=61;\n  i=0;\n  v=-3;\n  w=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+w+w;\n      v = v+1;\n      w = w+1;\n      if (i+2<=w+l) {\n          v = v+w;\n      }\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (w == -4) && (v == -3) && (i == 0) && (l == 61) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+w+w;\n      v = v+1;\n      w = w+1;\n      if (i+2<=w+l) {\n          v = v+w;\n      }\n      v = v+1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 2 <= w@last + 1 + l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + w@last + w@last + 1 + 1; w: w@last -> w@last + 1. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'p', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int p){\n  int l, i, v, w;\n\n  l=61;\n  i=0;\n  v=-3;\n  w=-4;\n\n  \n  /*@\n\n    loop invariant w == i - 4;\n\n    loop invariant v == -3 + (3*i*(i-1))/2 - 9*i;\n\n    loop invariant 0 <= i <= l;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant w - i == -4;\n\n    loop invariant i >= 0;\n\n    loop invariant l == 61;\n\n    loop invariant 0 <= i;\n\n    loop invariant w == -4 + i;\n\n    loop assigns v, w, i;\n\n  */\n  while (i<l) {\n      v = v+w+w;\n      v = v+1;\n      w = w+1;\n      if (i+2<=w+l) {\n          v = v+w;\n      }\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n,int q){\n  int l, i, v;\n\n  l=27;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+i;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 27) && (i == 27) && (l == 27) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+i;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + i@last. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n,int q){\n  int l, i, v;\n\n  l=27;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 27;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v == l + (l*(l+1))/2 - (i*(i+1))/2;\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant v == 405 - i*(i+1)/2;\n    loop invariant 0 <= i <= 27;\n    loop invariant b == \\at(b, Pre) && k == \\at(k, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n    loop invariant i <= 27;\n    loop invariant v >= 27;\n    loop invariant v >= i;\n    loop invariant 0 <= i <= l;\n    loop assigns i, v;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+i;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=15;\n  i=0;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (n<v+2) {\n          v = v+i;\n      }\n      i = i+5;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(n, Pre)) && (i == 0) && (l == 15) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (n<v+2) {\n          v = v+i;\n      }\n      i = i+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (n@last >= v@last + 2; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 5; v: v@last -> v@last + i@last. Unchanged: b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int m,int n,int p){\n  int l, i, v;\n\n  l=15;\n  i=0;\n  v=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant i % 5 == 0;\n    loop invariant v == n + (i * (i - 5)) / 10;\n    loop invariant n < v + 2;\n    loop invariant v >= n;\n    loop invariant n == \\at(n, Pre);\n    loop invariant b == \\at(b, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant l == 15;\n    loop invariant (v - n) % 5 == 0;\n\n    loop invariant v == n + (i*(i-5))/10;\n    loop invariant 0 <= i <= l;\n    loop assigns i, v;\n    loop variant l - i;\n  */\nwhile (i<l) {\n      if (n<v+2) {\n          v = v+i;\n      }\n      i = i+5;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int n,int p){\n  int l, i, v;\n\n  l=59;\n  i=0;\n  v=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%9)==0) {\n          v = v+3;\n      }\n      v = v+v;\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(k, Pre)) && (i == 0) && (l == 59) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%9)==0) {\n          v = v+3;\n      }\n      v = v+v;\n      v = v-v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 9 != 0; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 3 + (v@last + 3) - (v@last + 3 + (v@last + 3. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'n', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int n,int p){\n  int l, i, v;\n\n  l=59;\n  i=0;\n  v=k;\n\n  \n  /*@\n\n    loop invariant i <= l;\n\n    loop invariant (i == 0) ==> v == k;\n\n    loop invariant (i != 0) ==> v == 0;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant (i >= 1) ==> (v == 0);\n\n    loop invariant (i == 0) ==> (v == \\at(k, Pre));\n\n    loop invariant (i > 0) ==> (v == 0);\n\n    loop invariant (k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre));\n\n    loop invariant l == 59;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant (i == 0 && v == k) || (i > 0 && v == 0);\n\n    loop invariant k == \\at(k, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && p == \\at(p, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant i > 0 ==> v == 0;\n\n    loop invariant i == 0 || v == 0;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      if ((i%9)==0) {\n          v = v+3;\n      }\n      v = v+v;\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int p,int q){\n  int l, i, v;\n\n  l=26;\n  i=l;\n  v=5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      if ((i%5)==0) {\n          v = v+i;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 5) && (i == 26) && (l == 26) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      if ((i%5)==0) {\n          v = v+i;\n      }\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 5 != 0; i@last > 0; i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + i@last. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int p,int q){\n  int l, i, v;\n\n  l=26;\n  i=l;\n  v=5;\n\n  \n  /*@\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant l == 26;\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant 0 <= i <= 26;\n\n\n    loop invariant 0 <= i && i <= 26;\n\n\n    loop invariant v % 5 == 0;\n\n    loop invariant i <= 26;\n\n    loop assigns i, v;\n\n  */\nwhile (i>0) {\n      if ((i%5)==0) {\n          v = v+i;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n,int p,int q){\n  int l, i, v;\n\n  l=(p%7)+12;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%4)==0) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(p, Pre) % 7 + 12) && (i == 0) && (l == \\at(p, Pre) % 7 + 12) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%4)==0) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 4 != 0; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + v@last. Unchanged: l keeps l@last; m keeps m@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n,int p,int q){\n  int l, i, v;\n\n  l=(p%7)+12;\n  i=0;\n  v=l;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v >= l;\n\n\n    loop invariant l == (p % 7) + 12;\n\n    loop invariant 0 <= i;\n\n\n    loop invariant l == (\\at(p, Pre) % 7) + 12;\n\n    loop invariant (i == 0) ==> (v == l);\n\n    loop invariant p == \\at(p, Pre) && m == \\at(m, Pre) && n == \\at(n, Pre) && q == \\at(q, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns i, v;\n\n  */\n  while (i<l) {\n      if ((i%4)==0) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int q){\n  int l, i, v;\n\n  l=(q%31)+6;\n  i=0;\n  v=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-(-6);\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -2) && (i == 0) && (l == \\at(q, Pre) % 31 + 6) && (q == \\at(q, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-(-6);\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last - -6. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int q){\n  int l, i, v;\n\n  l=(q%31)+6;\n  i=0;\n  v=-2;\n\n  \n  /*@\n\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && m == \\at(m, Pre) && q == \\at(q, Pre);\n\n    loop invariant 0 <= i;\n\n\n    loop invariant v == -2 + 6*i;\n\n    loop invariant l == (q % 31) + 6;\n\n    loop invariant i >= 0;\n\n    loop invariant l == (\\at(q, Pre) % 31) + 6;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant (l > 0) ==> (0 <= i && i <= l && v == -2 + 6*i);\n\n    loop invariant l == ((\\at(q,Pre) % 31) + 6);\n\n    loop invariant a == \\at(a,Pre);\n\n    loop invariant b == \\at(b,Pre);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant q == \\at(q,Pre);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v-(-6);\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int k,int p){\n  int l, i, v;\n\n  l=a+24;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+6<l) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(a, Pre) + 24) && (i == 0) && (l == \\at(a, Pre) + 24) && (p == \\at(p, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+6<l) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last + 6 >= l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 1. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'k', 'l', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int k,int p){\n  int l, i, v;\n\n  l=a+24;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n\n   loop invariant 0 <= i;\n   loop invariant v == l;\n   loop invariant l == a + 24;\n   loop invariant a == \\at(a, Pre);\n   loop invariant i >= 0;\n   loop invariant b == \\at(b, Pre);\n   loop invariant k == \\at(k, Pre);\n   loop invariant p == \\at(p, Pre);\n   loop invariant i <= l || l < 0;\n   loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && k == \\at(k, Pre) && p == \\at(p, Pre);\n   loop assigns i, v;\n   loop variant l - i;\n */\nwhile (i<l) {\n      if (v+6<l) {\n          v = v+1;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int m,int n){\n  int l, i, v;\n\n  l=22;\n  i=0;\n  v=3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+5<l) {\n          v = v+i;\n      }\n      else {\n          v = v+i;\n      }\n      v = v+1;\n      i = i+4;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 3) && (i == 0) && (l == 22) && (n == \\at(n, Pre)) && (m == \\at(m, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+5<l) {\n          v = v+i;\n      }\n      else {\n          v = v+i;\n      }\n      v = v+1;\n      i = i+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last + 5 < l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 4; v: v@last -> v@last + i@last + 1. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int m,int n){\n  int l, i, v;\n\n  l=22;\n  i=0;\n  v=3;\n\n  \n  /*@\n\n    loop invariant 8*v == i*i - 2*i + 24;\n\n    loop invariant i % 4 == 0;\n\n    loop invariant 0 <= i;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant i <= l + 3;\n\n    loop invariant v == 3 + 2*(i/4)*(i/4) - (i/4);\n\n    loop invariant i <= l + 2;\n\n    loop invariant l == 22;\n\n    loop invariant v == 3 + (i / 4) * (2 * (i / 4) - 1);\n\n\n    loop invariant v >= 3;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      if (v+5<l) {\n          v = v+i;\n      }\n      else {\n          v = v+i;\n      }\n      v = v+1;\n      i = i+4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m,int p,int q){\n  int l, i, v, e, y;\n\n  l=70;\n  i=0;\n  v=5;\n  e=2;\n  y=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      e = e+v;\n      if (k<q+5) {\n          y = y+i;\n      }\n      else {\n          v = v+5;\n      }\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (y == \\at(m, Pre)) && (e == 2) && (v == 5) && (i == 0) && (l == 70) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      e = e+v;\n      if (k<q+5) {\n          y = y+i;\n      }\n      else {\n          v = v+5;\n      }\n      v = v+1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (k@last < q@last + 5; i@last < l@last; i@last < l@last). Changed: e: e@last -> e@last + (v@last + 1; i: i@last -> i@last + 1; v: v@last -> v@last + 1 + 5 + 1. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; p keeps p@last; q keeps q@last; y keeps y@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['e', 'i', 'k', 'l', 'm', 'p', 'q', 'v', 'y']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m,int p,int q){\n  int l, i, v, e, y;\n\n  l=70;\n  i=0;\n  v=5;\n  e=2;\n  y=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant (k < q + 5) ==> (v == 5 + 2*i);\n    loop invariant (k < q + 5) ==> (e == 2 + i*i + 5*i);\n    loop invariant (k < q + 5) ==> (0 <= i && i <= l);\n    loop invariant !(k < q + 5) ==> (v == 5 + 7*i);\n    loop invariant !(k < q + 5) ==> (y == m);\n    loop invariant 0 <= i <= l;\n    loop invariant 5 <= v && v <= 5 + 7*i;\n    loop invariant e >= 2;\n    loop invariant y >= m;\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i <= l;\n    loop invariant v >= 5 + 2*i;\n    loop invariant i >= 0;\n    loop invariant v >= 5;\n    loop invariant v <= 5 + 7*i;\n    loop invariant e <= 2 + 6*i + 7*(i*(i-1))/2;\n    loop invariant y <= m + (i*(i-1))/2;\n    loop invariant l == 70;\n    loop invariant (k >= q + 5) ==> (v == 5 + 7*i);\n    loop invariant (k >= q + 5) ==> (y == m);\n    loop invariant e >= i*i + 5*i + 2;\n    loop invariant e <= (7*i*i + 5*i + 4)/2;\n    loop invariant y <= m + i*(i-1)/2;\n    loop assigns v, e, y, i;\n  */\nwhile (i<l) {\n      v = v+1;\n      e = e+v;\n      if (k<q+5) {\n          y = y+i;\n      }\n      else {\n          v = v+5;\n      }\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int n,int p){\n  int l, i, v, s, b;\n\n  l=59;\n  i=0;\n  v=n;\n  s=k;\n  b=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      s = s-1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (b == \\at(n, Pre)) && (s == \\at(k, Pre)) && (v == \\at(n, Pre)) && (i == 0) && (l == 59) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      s = s-1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; s: s@last -> s@last - 1; v: v@last -> v@last + 1. Unchanged: a keeps a@last; b keeps b@last; k keeps k@last; l keeps l@last; n keeps n@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'n', 'p', 's', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int n,int p){\n  int l, i, v, s, b;\n\n  l=59;\n  i=0;\n  v=n;\n  s=k;\n  b=n;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant v == n + i;\n    loop invariant s == k - i;\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant i >= 0;\n    loop invariant l == 59;\n    loop invariant a == \\at(a,Pre);\n    loop invariant k == \\at(k,Pre);\n    loop invariant n == \\at(n,Pre);\n    loop invariant v == i + \\at(n,Pre);\n    loop invariant s == \\at(k,Pre) - i;\n    loop invariant v == \\at(n, Pre) + i;\n    loop invariant s == \\at(k, Pre) - i;\n    loop assigns i, v, s;\n  */\n  while (i<l) {\n      v = v+1;\n      s = s-1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k,int n,int q){\n  int l, i, v;\n\n  l=b-6;\n  i=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      v = l-4;\n      if (i<i+4) {\n          v = v+i;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(q, Pre)) && (i == 0) && (l == \\at(b, Pre) - 6) && (q == \\at(q, Pre)) && (n == \\at(n, Pre)) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      v = l-4;\n      if (i<i+4) {\n          v = v+i;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k,int n,int q){\n  int l, i, v;\n\n  l=b-6;\n  i=0;\n  v=q;\n\n  \n  /*@\n\n\n    loop invariant l == b - 6;\n\n    loop invariant v == q || v == l - 5 + i;\n\n    loop invariant i >= 0;\n\n    loop invariant (i == 0) ==> (v == q);\n\n    loop invariant (i > 0) ==> (v == l - 4 + i - 1);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant l == \\at(b, Pre) - 6;\n\n    loop invariant (i <= l) || (l < 0);\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v+i;\n      v = l-4;\n      if (i<i+4) {\n          v = v+i;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n,int p,int q){\n  int l, i, v, f, w;\n\n  l=(p%15)+16;\n  i=l;\n  v=n;\n  f=n;\n  w=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+f+w;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (w == \\at(p, Pre) % 15 + 16) && (f == \\at(n, Pre)) && (v == \\at(n, Pre)) && (i == \\at(p, Pre) % 15 + 16) && (l == \\at(p, Pre) % 15 + 16) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+f+w;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + f@last + w@last. Unchanged: a keeps a@last; f keeps f@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last; w keeps w@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'f', 'i', 'l', 'n', 'p', 'q', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n,int p,int q){\n  int l, i, v, f, w;\n\n  l=(p%15)+16;\n  i=l;\n  v=n;\n  f=n;\n  w=l;\n\n  \n  /*@\n\n    loop invariant l == (p % 15) + 16;\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant f == n;\n\n    loop invariant w == l;\n\n    loop invariant v == n + (l - i) * (f + w);\n\n    loop invariant v == \\at(n,Pre) + (((\\at(p,Pre) % 15) + 16) - i) * ( \\at(n,Pre) + ((\\at(p,Pre) % 15) + 16) );\n\n    loop invariant f == \\at(n,Pre);\n\n    loop invariant w == ((\\at(p,Pre) % 15) + 16);\n\n    loop invariant l == ((\\at(p,Pre) % 15) + 16);\n\n    loop invariant 0 <= i <= ((\\at(p,Pre) % 15) + 16);\n\n    loop invariant v == n + (l - i) * (n + l);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant v + i*(f + w) == n + l*(n + l);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+f+w;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int b,int p,int q){\n  int l, i, v, n, m;\n\n  l=65;\n  i=l;\n  v=l;\n  n=l;\n  m=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+4;\n      m = m+4;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (m == 4) && (n == 65) && (v == 65) && (i == 65) && (l == 65) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (b == \\at(b, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+4;\n      m = m+4;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; m: m@last -> m@last + 4; v: v@last -> v@last + 4. Unchanged: a keeps a@last; b keeps b@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'b', 'i', 'l', 'm', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int b,int p,int q){\n  int l, i, v, n, m;\n\n  l=65;\n  i=l;\n  v=l;\n  n=l;\n  m=4;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant v - m == l - 4;\n\n    loop invariant m + 4*i == 4 + 4*l;\n\n    loop invariant l == 65;\n\n    loop invariant v == 325 - 4*i;\n\n    loop invariant m == 264 - 4*i;\n\n    loop invariant a == \\at(a, Pre) && b == \\at(b, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n\n    loop invariant 0 <= i <= 65;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop assigns i, v, m;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+4;\n      m = m+4;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k,int p,int q){\n  int l, i, v;\n\n  l=60;\n  i=l;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+v;\n      v = v-v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 60) && (l == 60) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+v;\n      v = v-v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last + v@last - (v@last + v@last. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k,int p,int q){\n  int l, i, v;\n\n  l=60;\n  i=l;\n  v=0;\n\n  /*>>> LOOP INVARIANT TO FILL<<<*/\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= 60;\n    loop invariant v == 0;\n    loop invariant l == 60;\n    loop invariant a == \\at(a, Pre) && k == \\at(k, Pre) && p == \\at(p, Pre) && q == \\at(q, Pre);\n    loop invariant a == \\at(a, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant 0 <= i && i <= 60;\n    loop invariant p == \\at(p, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i <= l;\n    loop assigns i, v;\n  */\n  while (i>0) {\n      v = v+v;\n      v = v-v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n,int p,int q){\n  int l, i, v;\n\n  l=p+4;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(p, Pre) + 4) && (i == 0) && (l == \\at(p, Pre) + 4) && (q == \\at(q, Pre)) && (p == \\at(p, Pre)) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last - v@last. Unchanged: b keeps b@last; l keeps l@last; n keeps n@last; p keeps p@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n,int p,int q){\n  int l, i, v;\n\n  l=p+4;\n  i=0;\n  v=l;\n\n  \n  /*@\n\n    loop invariant l == p + 4 &&\n                   i <= l &&\n                   i >= 0 &&\n                   (i == 0) ==> (v == l) &&\n                   (i >= 1) ==> (v == 0);\n\n    loop invariant i >= 0;\n\n\n    loop invariant (i == 0) ==> (v == l);\n\n    loop invariant (i > 0) ==> (v == 0);\n\n    loop invariant l == \\at(p, Pre) + 4;\n\n    loop invariant l == p + 4;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant (i == 0 && v == l) || (i > 0 && v == 0);\n\n\n    loop invariant p == \\at(p, Pre) && q == \\at(q, Pre) && n == \\at(n, Pre) && b == \\at(b, Pre);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int l, i, v;\n\n  l=40;\n  i=0;\n  v=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = m-m;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -3) && (i == 0) && (l == 40) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = m-m;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> m@last - m@last. Unchanged: l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int l, i, v;\n\n  l=40;\n  i=0;\n  v=-3;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 40;\n    loop invariant 0 <= i && i <= l;\n    loop invariant m == \\at(m, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant v == -3 || v == 0;\n    loop invariant i <= l;\n    loop invariant (i == 0) ==> (v == -3);\n    loop invariant i >= 0;\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = m-m;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int q){\n  int l, i, v, m, g;\n\n  l=70;\n  i=0;\n  v=q;\n  m=-4;\n  g=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+2<=l) {\n          v = v+2;\n      }\n      else {\n          v = l;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (g == -8) && (m == -4) && (v == \\at(q, Pre)) && (i == 0) && (l == 70) && (q == \\at(q, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+2<=l) {\n          v = v+2;\n      }\n      else {\n          v = l;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last + 2 <= l@last; i@last < l@last; i@last < l@last). Changed: v: v@last -> l@last. Unchanged: a keeps a@last; g keeps g@last; i keeps i@last; l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int q){\n  int l, i, v, m, g;\n\n  l=70;\n  i=0;\n  v=q;\n  m=-4;\n  g=-8;\n\n  \n  /*@\n\n    loop invariant l == 70;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i <= l;\n\n    loop invariant (v != l) ==> ((v - q) % 2 == 0);\n\n    loop invariant i >= 0;\n\n\n    loop invariant i == 0;\n\n    loop assigns v;\n\n  */\n  while (i<l) {\n      if (v+2<=l) {\n          v = v+2;\n      }\n      else {\n          v = l;\n      }\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n){\n  int l, i, v;\n\n  l=41;\n  i=0;\n  v=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%5)==0) {\n          v = v*v;\n      }\n      else {\n          v = v*v+v;\n      }\n      i = i+5;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -2) && (i == 0) && (l == 41) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%5)==0) {\n          v = v*v;\n      }\n      else {\n          v = v*v+v;\n      }\n      i = i+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 5 != 0; i@last < l@last; i@last < l@last; v@last). Changed: i: i@last -> i@last + 5. Unchanged: a keeps a@last; l keeps l@last; n keeps n@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n){\n  int l, i, v;\n\n  l=41;\n  i=0;\n  v=-2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i % 5 == 0;\n    loop invariant l == 41;\n\n    loop invariant (v == -2) || (v > 0);\n    loop invariant (i % 5) == 0;\n    loop invariant a == \\at(a, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant i <= l + 4;\n    loop invariant i >= 0;\n    loop invariant v >= -2;\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      if ((i%5)==0) {\n          v = v*v;\n      }\n      else {\n          v = v*v+v;\n      }\n      i = i+5;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p){\n  int l, i, v;\n\n  l=p-4;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 0) && (l == \\at(p, Pre) - 4) && (p == \\at(p, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2). Changed: i: i@last -> i@last + 1. Unchanged: l keeps l@last; m keeps m@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p){\n  int l, i, v;\n\n  l=p-4;\n  i=0;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 0;\n    loop invariant i >= 0;\n    loop invariant l == p - 4;\n    loop invariant p == \\at(p, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant (i <= l) || (l <= 0);\n    loop invariant (l >= 0) ==> (i <= l);\n\n    loop invariant l == \\at(p, Pre) - 4;\n    loop assigns v, i;\n  */\n  while (i<l) {\n      v = v*2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n){\n  int l, i, v, q;\n\n  l=n+19;\n  i=0;\n  v=l;\n  q=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (q == 0) && (v == \\at(n, Pre) + 19) && (i == 0) && (l == \\at(n, Pre) + 19) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2). Changed: i: i@last -> i@last + 1. Unchanged: a keeps a@last; l keeps l@last; n keeps n@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n){\n  int l, i, v, q;\n\n  l=n+19;\n  i=0;\n  v=l;\n  q=i;\n\n  \n  /*@\n\n    loop invariant l == n + 19;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant 0 <= i;\n\n\n    loop invariant l == \\at(n, Pre) + 19;\n\n    loop invariant i >= 0;\n\n    loop invariant (i == 0) ==> (v == l);\n\n\n    loop invariant i <= l || l < 0;\n\n\n    loop invariant v >= l;\n\n    loop assigns v, i;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v*2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int l, i, v;\n\n  l=45;\n  i=l;\n  v=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      v = v%6;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 45) && (i == 45) && (l == 45) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      v = v%6;\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; 2 % 6). Changed: i: i@last -> i@last / 2. Unchanged: l keeps l@last; p keeps p@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int l, i, v;\n\n  l=45;\n  i=l;\n  v=i;\n\n  \n  /*@\n\n    loop invariant l == 45;\n\n    loop invariant i <= l;\n\n    loop invariant i >= 0;\n\n    loop invariant v == 0 || v == 45;\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i <= 45;\n\n    loop invariant 0 <= i && i <= 45;\n\n    loop invariant (i < 45) ==> (v == 0);\n\n    loop invariant 0 <= i && i <= l;\n\n\n    loop assigns v, i;\n\n  */\nwhile (i>0) {\n      v = v*2;\n      v = v%6;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int l, i, v, e, d;\n\n  l=11;\n  i=0;\n  v=m;\n  e=l;\n  d=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+2<=l) {\n          v = v+2;\n      }\n      else {\n          v = l;\n      }\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (d == \\at(m, Pre)) && (e == 11) && (v == \\at(m, Pre)) && (i == 0) && (l == 11) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+2<=l) {\n          v = v+2;\n      }\n      else {\n          v = l;\n      }\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last + 2 <= l@last; i@last < l@last; i@last < l@last). Changed: v: v@last -> l@last. Unchanged: d keeps d@last; e keeps e@last; i keeps i@last; k keeps k@last; l keeps l@last; m keeps m@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int l, i, v, e, d;\n\n  l=11;\n  i=0;\n  v=m;\n  e=l;\n  d=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 11;\n    loop invariant i == 0;\n    loop invariant m == \\at(m, Pre);\n    loop invariant i <= l;\n    loop invariant i >= 0;\n\n    loop invariant (v == l) || (((v - m) % 2) == 0);\n    loop invariant k == \\at(k, Pre);\n    loop invariant (v <= l) || (v <= m);\n    loop invariant (v <= l) || (v == m);\n    loop invariant 0 <= i && i <= l;\n    loop assigns v;\n  */\n  while (i<l) {\n      if (v+2<=l) {\n          v = v+2;\n      }\n      else {\n          v = l;\n      }\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int q){\n  int l, i, v, j;\n\n  l=51;\n  i=0;\n  v=i;\n  j=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*4+5;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (j == -5) && (v == 0) && (i == 0) && (l == 51) && (q == \\at(q, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*4+5;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 4 + 5). Changed: i: i@last -> i@last + 1. Unchanged: a keeps a@last; j keeps j@last; l keeps l@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int q){\n  int l, i, v, j;\n\n  l=51;\n  i=0;\n  v=i;\n  j=-5;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant l == 51;\n   loop invariant i >= 0;\n   loop invariant i <= l;\n   loop invariant v >= 0;\n   loop invariant a == \\at(a, Pre);\n   loop invariant q == \\at(q, Pre);\n   loop invariant v % 5 == 0;\n   loop invariant 0 <= i;\n   loop invariant v >= 5*i;\n   loop invariant (i == 0) <==> (v == 0);\n   loop assigns v, i;\n */\nwhile (i<l) {\n      v = v*4+5;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k){\n  int l, i, v, o, j;\n\n  l=35;\n  i=1;\n  v=8;\n  o=k;\n  j=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*4;\n      o = o/4;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (j == -4) && (o == \\at(k, Pre)) && (v == 8) && (i == 1) && (l == 35) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*4;\n      o = o/4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 4). Changed: o: o@last -> o@last / 4. Unchanged: a keeps a@last; i keeps i@last; j keeps j@last; k keeps k@last; l keeps l@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'o', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k){\n  int l, i, v, o, j;\n\n  l=35;\n  i=1;\n  v=8;\n  o=k;\n  j=-4;\n\n  \n  /*@\n\n    loop invariant k == \\at(k,Pre);\n\n    loop invariant a == \\at(a,Pre);\n\n    loop invariant i == 1;\n\n    loop invariant i <= l;\n\n    loop invariant v % 4 == 0;\n\n    loop invariant v >= 8;\n\n    loop invariant l == 35;\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant v % 8 == 0;\n\n    loop invariant ( (\\at(k,Pre) >= 0) ==> o <= \\at(k,Pre) ) && ( (\\at(k,Pre) < 0) ==> o >= \\at(k,Pre) );\n\n    loop invariant i >= 1;\n\n\n    loop assigns v, o;\n\n  */\nwhile (i<l) {\n      v = v*4;\n      o = o/4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int p){\n  int l, i, v, q;\n\n  l=p;\n  i=1;\n  v=i;\n  q=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*3+3;\n      i = i*3;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (q == \\at(p, Pre)) && (v == 1) && (i == 1) && (l == \\at(p, Pre)) && (p == \\at(p, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*3+3;\n      i = i*3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 3; 3 + 3). Unchanged: b keeps b@last; i keeps i@last; l keeps l@last; p keeps p@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int p){\n  int l, i, v, q;\n\n  l=p;\n  i=1;\n  v=i;\n  q=p;\n\n  \n  /*@\n\n    loop invariant 2*v == 5*i - 3;\n\n    loop invariant i >= 1;\n\n    loop invariant l == \\at(p, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant l == p;\n\n    loop invariant i > 0;\n\n\n    loop invariant v >= 1;\n\n    loop invariant v >= 2*i - 1;\n\n    loop invariant v > 0;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant v >= i;\n\n    loop invariant i % 2 == 1;\n\n    loop assigns v, i;\n\n  */\nwhile (i<l) {\n      v = v*3+3;\n      i = i*3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p){\n  int l, i, v;\n\n  l=23;\n  i=0;\n  v=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v;\n      i = i+4;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(p, Pre)) && (i == 0) && (l == 23) && (p == \\at(p, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v;\n      i = i+4;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last). Changed: i: i@last -> i@last + 4. Unchanged: l keeps l@last; m keeps m@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p){\n  int l, i, v;\n\n  l=23;\n  i=0;\n  v=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i % 4 == 0;\n    loop invariant m == \\at(m, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant l == 23;\n    loop invariant i >= 0;\n\n    loop invariant (i == 0) ==> (v == p);\n    loop invariant 0 <= i;\n    loop invariant v >= p;\n    loop invariant i <= l + 3;\n    loop invariant (i == 0) ==> (v == \\at(p, Pre));\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = v*v;\n      i = i+4;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int l, i, v;\n\n  l=q+8;\n  i=0;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (i+1<=q+l) {\n          v = v*2;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 2) && (i == 0) && (l == \\at(q, Pre) + 8) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (i+1<=q+l) {\n          v = v*2;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 1 > q@last + l@last; i@last < l@last; i@last < l@last; 2). Changed: i: i@last -> i@last + 1. Unchanged: l keeps l@last; n keeps n@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int l, i, v;\n\n  l=q+8;\n  i=0;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == q + 8;\n    loop invariant q == \\at(q, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant v % 2 == 0;\n    loop invariant i >= 0;\n    loop invariant i <= l || l < 0;\n\n    loop invariant v >= 2;\n    loop invariant 0 <= i;\n    loop invariant l == \\at(q, Pre) + 8;\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      if (i+1<=q+l) {\n          v = v*2;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n){\n  int l, i, v;\n\n  l=74;\n  i=1;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v;\n      v = v*2;\n      i = i*2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 2) && (i == 1) && (l == 74) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v;\n      v = v*2;\n      i = i*2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2; v@last; 2). Unchanged: b keeps b@last; i keeps i@last; l keeps l@last; n keeps n@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n){\n  int l, i, v;\n\n  l=74;\n  i=1;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 74;\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant i >= 1;\n    loop invariant v >= 2;\n\n    loop invariant i > 0;\n    loop invariant v > 0;\n    loop invariant v % 2 == 0;\n    loop invariant v >= i;\n    loop assigns i, v;\n  */\n  while (i<l) {\n      v = v*v;\n      v = v*2;\n      i = i*2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p){\n  int l, i, v;\n\n  l=41;\n  i=0;\n  v=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+7<l) {\n          v = v+1;\n      }\n      i = i+2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 8) && (i == 0) && (l == 41) && (p == \\at(p, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+7<l) {\n          v = v+1;\n      }\n      i = i+2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last + 7 >= l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 2; v: v@last -> v@last + 1. Unchanged: l keeps l@last; m keeps m@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p){\n  int l, i, v;\n\n  l=41;\n  i=0;\n  v=8;\n\n  \n  /*@\n\n    loop invariant i % 2 == 0;\n\n    loop invariant 0 <= i;\n\n    loop invariant 8 <= v <= l - 7;\n\n    loop invariant v <= 8 + i/2;\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l + 1;\n\n    loop invariant 8 <= v <= 34;\n\n    loop invariant p == \\at(p,Pre);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant l == 41;\n\n    loop invariant v == 8 + i/2;\n\n\n    loop invariant (i % 2) == 0;\n\n    loop invariant v >= 8;\n\n    loop invariant v <= l - 7;\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      if (v+7<l) {\n          v = v+1;\n      }\n      i = i+2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int q){\n  int l, i, v, t;\n\n  l=q-9;\n  i=0;\n  v=i;\n  t=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+1;\n      t = t-1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (t == 0) && (v == 0) && (i == 0) && (l == \\at(q, Pre) - 9) && (q == \\at(q, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+1;\n      t = t-1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; t: t@last -> t@last - 1; v: v@last -> v@last + 1. Unchanged: a keeps a@last; l keeps l@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'q', 't', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int q){\n  int l, i, v, t;\n\n  l=q-9;\n  i=0;\n  v=i;\n  t=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n\n    loop invariant v == i;\n    loop invariant t == -i;\n    loop invariant l == q - 9;\n    loop invariant i >= 0;\n    loop invariant v >= 0;\n    loop invariant l == \\at(q, Pre) - 9;\n    loop invariant a == \\at(a, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i <= l || l < 0;\n    loop assigns i, v, t;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+1;\n      t = t-1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int q){\n  int l, i, v;\n\n  l=20;\n  i=0;\n  v=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v%4;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 8) && (i == 0) && (l == 20) && (q == \\at(q, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v%4;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last % 4. Unchanged: a keeps a@last; l keeps l@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int q){\n  int l, i, v;\n\n  l=20;\n  i=0;\n  v=8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i <= l;\n    loop invariant l == 20;\n    loop invariant (i == 0) ==> (v == 8);\n    loop invariant a == \\at(a, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i <= l;\n    loop invariant 0 <= i;\n    loop invariant v % 4 == 0;\n    loop invariant 0 <= i && i <= l;\n    loop assigns v, i;\n  */\n  while (i<l) {\n      v = v%4;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int p){\n  int l, i, v;\n\n  l=36;\n  i=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 0) && (i == 0) && (l == 36) && (p == \\at(p, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last - v@last. Unchanged: a keeps a@last; l keeps l@last; p keeps p@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int p){\n  int l, i, v;\n\n  l=36;\n  i=0;\n  v=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant v == 0;\n    loop invariant a == \\at(a, Pre);\n    loop invariant p == \\at(p, Pre);\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant l == 36;\n    loop invariant 0 <= i && i <= l;\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v-v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n){\n  int l, i, v, w;\n\n  l=54;\n  i=l;\n  v=i;\n  w=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (w == 54) && (v == 54) && (i == 54) && (l == 54) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; 2). Changed: i: i@last -> i@last - 1. Unchanged: b keeps b@last; l keeps l@last; n keeps n@last; v keeps v@last; w keeps w@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n){\n  int l, i, v, w;\n\n  l=54;\n  i=l;\n  v=i;\n  w=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 54;\n    loop invariant i <= l;\n    loop invariant i >= 0;\n    loop invariant v % 54 == 0;\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant v >= l;\n    loop invariant i <= 54;\n    loop invariant v >= 54;\n    loop invariant 0 <= i;\n    loop assigns i, v;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v*2;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int k){\n  int l, i, v;\n\n  l=31;\n  i=0;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v;\n      v = v%8;\n      i = i+5;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(a, Pre)) && (i == 0) && (l == 31) && (k == \\at(k, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v;\n      v = v%8;\n      i = i+5;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last % 8). Changed: i: i@last -> i@last + 5. Unchanged: a keeps a@last; k keeps k@last; l keeps l@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'k', 'l', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int k){\n  int l, i, v;\n\n  l=31;\n  i=0;\n  v=a;\n\n  \n  /*@\n\n    loop invariant l == 31;\n\n    loop invariant i % 5 == 0;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant a == \\at(a, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant (i % 5) == 0;\n\n    loop invariant a == \\at(a,Pre);\n\n    loop invariant k == \\at(k,Pre);\n\n    loop invariant i <= l + 4;\n\n    loop invariant 0 <= i && i <= l + 4;\n\n\n    loop invariant v == a || (v >= 0 && v <= 7);\n\n    loop assigns v, i;\n\n  */\n  while (i<l) {\n      v = v*v;\n      v = v%8;\n      i = i+5;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int l, i, v, j, s;\n\n  l=76;\n  i=l;\n  v=i;\n  j=l;\n  s=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+j;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (s == 76) && (j == 76) && (v == 76) && (i == 76) && (l == 76) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+j;\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last / 2; v: v@last -> v@last + j@last. Unchanged: j keeps j@last; l keeps l@last; m keeps m@last; n keeps n@last; s keeps s@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'j', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int l, i, v, j, s;\n\n  l=76;\n  i=l;\n  v=i;\n  j=l;\n  s=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant j == l;\n    loop invariant v >= l;\n    loop invariant (v - l) % j == 0;\n    loop invariant m == \\at(m, Pre);\n    loop invariant i <= 76;\n    loop invariant l == 76;\n    loop invariant j != 0 ==> ((v - 76) % j == 0);\n    loop invariant v >= 76;\n    loop invariant n == \\at(n, Pre);\n    loop invariant m == \\at(m,Pre);\n    loop invariant n == \\at(n,Pre);\n\n    loop invariant v >= i;\n    loop assigns i, v;\n    loop variant i;\n  */\nwhile (i>0) {\n      v = v+j;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int n){\n  int l, i, v, f;\n\n  l=45;\n  i=l;\n  v=-5;\n  f=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+f;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (f == 45) && (v == -5) && (i == 45) && (l == 45) && (n == \\at(n, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+f;\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last / 2; v: v@last -> v@last + f@last. Unchanged: f keeps f@last; k keeps k@last; l keeps l@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['f', 'i', 'k', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int n){\n  int l, i, v, f;\n\n  l=45;\n  i=l;\n  v=-5;\n  f=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant f == 45;\n    loop invariant 0 <= i <= 45;\n    loop invariant k == \\at(k, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant l == 45;\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant v >= -5;\n    loop invariant i <= 45;\n    loop invariant (v + 5) % 45 == 0;\n    loop assigns v, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v+f;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int q){\n  int l, i, v, m, w;\n\n  l=53;\n  i=0;\n  v=8;\n  m=i;\n  w=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v+v;\n      v = v%4;\n      i = i+3;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (w == -4) && (m == 0) && (v == 8) && (i == 0) && (l == 53) && (q == \\at(q, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v+v;\n      v = v%4;\n      i = i+3;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last + v@last) % 4). Changed: i: i@last -> i@last + 3; v: v@last -> (v@last. Unchanged: b keeps b@last; l keeps l@last; m keeps m@last; q keeps q@last; w keeps w@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int q){\n  int l, i, v, m, w;\n\n  l=53;\n  i=0;\n  v=8;\n  m=i;\n  w=-4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 53;\n    loop invariant i % 3 == 0;\n    loop invariant (i == 0) ==> (v == 8);\n    loop invariant b == \\at(b, Pre);\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i <= l + 2;\n    loop invariant i >= 0;\n\n\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v*v+v;\n      v = v%4;\n      i = i+3;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int q){\n  int l, i, v;\n\n  l=k+8;\n  i=0;\n  v=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+6<l) {\n          v = v+2;\n      }\n      v = v+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 1) && (i == 0) && (l == \\at(k, Pre) + 8) && (q == \\at(q, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+6<l) {\n          v = v+2;\n      }\n      v = v+1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last + 6 < l@last; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + 1. Unchanged: k keeps k@last; l keeps l@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int q){\n  int l, i, v;\n\n  l=k+8;\n  i=0;\n  v=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == k + 8;\n\n    loop invariant 0 <= i;\n    loop invariant (v - i) % 2 == 1;\n    loop invariant v >= 1;\n    loop invariant k == \\at(k, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i >= 0;\n    loop invariant 1 + i <= v;\n    loop invariant v <= 1 + 3*i;\n    loop invariant k == \\at(k,Pre);\n    loop invariant q == \\at(q,Pre);\n    loop invariant v >= 1 + i;\n    loop invariant v >= i + 1;\n    loop invariant v - i >= 1;\n    loop invariant ((v - i) % 2 == 1);\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      if (v+6<l) {\n          v = v+2;\n      }\n      v = v+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n){\n  int l, i, v, z;\n\n  l=(n%8)+18;\n  i=0;\n  v=2;\n  z=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2+1;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (z == 2) && (v == 2) && (i == 0) && (l == \\at(n, Pre) % 8 + 18) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2+1;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2 + 1). Changed: i: i@last -> i@last + 1. Unchanged: a keeps a@last; l keeps l@last; n keeps n@last; v keeps v@last; z keeps z@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n){\n  int l, i, v, z;\n\n  l=(n%8)+18;\n  i=0;\n  v=2;\n  z=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant l == (n % 8) + 18;\n    loop invariant 0 <= i <= l;\n    loop invariant v >= 2;\n    loop invariant i >= 0;\n    loop invariant i <= l;\n    loop invariant l == (\\at(n, Pre) % 8) + 18;\n    loop invariant a == \\at(a,Pre);\n    loop invariant n == \\at(n,Pre);\n    loop invariant l == (\\at(n,Pre) % 8) + 18;\n    loop invariant (v + 1) % 3 == 0;\n    loop invariant v >= 2*i + 2;\n    loop invariant 0 <= i;\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v*2+1;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k){\n  int l, i, v, p, h;\n\n  l=64;\n  i=l;\n  v=l;\n  p=8;\n  h=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2+2;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (h == 64) && (p == 8) && (v == 64) && (i == 64) && (l == 64) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2+2;\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; 2 + 2). Changed: i: i@last -> i@last / 2. Unchanged: b keeps b@last; h keeps h@last; k keeps k@last; l keeps l@last; p keeps p@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k){\n  int l, i, v, p, h;\n\n  l=64;\n  i=l;\n  v=l;\n  p=8;\n  h=l;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= 64;\n\n    loop invariant l == 64;\n\n    loop invariant b == \\at(b, Pre);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant v >= 64;\n\n    loop invariant v % 2 == 0;\n\n    loop invariant v >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v >= l;\n\n\n    loop invariant v >= i;\n\n    loop assigns v, i;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v*2+2;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int l, i, v;\n\n  l=13;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(m, Pre)) && (i == 0) && (l == 13) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last). Changed: i: i@last -> i@last + 1. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int l, i, v;\n\n  l=13;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n  /*@\n   loop invariant 0 <= i <= l;\n   loop invariant l == 13;\n   loop invariant m == \\at(m, Pre);\n   loop invariant k == \\at(k, Pre);\n   loop invariant (i == 0) ==> (v == m);\n   loop invariant i <= l;\n   loop invariant i >= 0;\n   loop invariant i > 0 ==> v >= 0;\n   loop assigns i, v;\n   loop variant l - i;\n */\nwhile (i<l) {\n      v = v*v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int m){\n  int l, i, v;\n\n  l=13;\n  i=l;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      v = v*v;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(a, Pre)) && (i == 13) && (l == 13) && (m == \\at(m, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      v = v*v;\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; 2; v@last; 2). Changed: i: i@last -> i@last - 1. Unchanged: a keeps a@last; l keeps l@last; m keeps m@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int m){\n  int l, i, v;\n\n  l=13;\n  i=l;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant l == 13;\n    loop invariant i >= 0;\n    loop invariant i <= 13;\n    loop invariant (i == 13) ==> (v == a);\n    loop invariant v >= a;\n    loop invariant v >= 0 || v == \\at(a, Pre);\n    loop assigns v, i;\n    loop variant i;\n  */\n  while (i>0) {\n      v = v*2;\n      v = v*v;\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int q){\n  int l, i, v;\n\n  l=39;\n  i=l;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v+v;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(q, Pre)) && (i == 39) && (l == 39) && (q == \\at(q, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v+v;\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0). Changed: i: i@last -> i@last / 2; v: v@last -> v@last + v@last. Unchanged: l keeps l@last; m keeps m@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int q){\n  int l, i, v;\n\n  l=39;\n  i=l;\n  v=q;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant l == 39;\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant (q >= 0) ==> (i * v <= 39 * q);\n\n    loop invariant (q <= 0) ==> (i * v >= 39 * q);\n\n    loop invariant i <= 39;\n\n\n    loop invariant (q == 0) ==> (v == 0);\n\n    loop invariant i <= l;\n\n    loop invariant q == \\at(q,Pre);\n\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant (\\at(q,Pre) >= 0) ==> i * v <= 39 * \\at(q,Pre);\n\n    loop invariant (\\at(q,Pre) < 0)  ==> i * v >= 39 * \\at(q,Pre);\n\n    loop invariant (q >= 0) ==> (v >= 0);\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v+v;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int q){\n  int l, i, v, b, u;\n\n  l=k;\n  i=0;\n  v=i;\n  b=8;\n  u=4;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v+v;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int q){\n  int l, i, v, b, u;\n\n  l=k;\n  i=0;\n  v=i;\n  b=8;\n  u=4;\n\n  \n  /*@\n\n    loop invariant v == 0;\n\n\n    loop invariant i >= 0;\n\n    loop invariant l == k;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant 0 <= i;\n\n    loop invariant (i <= l) || (l <= 0);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v*v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int l, i, v;\n\n  l=k+18;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (l*l<=l+5) {\n          v = v*v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(k, Pre) + 18) && (i == 0) && (l == \\at(k, Pre) + 18) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (l*l<=l+5) {\n          v = v*v;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int l, i, v;\n\n  l=k+18;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == k + 18;\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant i >= 0;\n    loop invariant v >= l;\n    loop invariant 0 <= i;\n\n    loop invariant l == \\at(k, Pre) + 18;\n    loop invariant (l <= 0) || (0 <= i && i <= l);\n    loop invariant (l*l > l+5) ==> (v == l);\n\n    loop assigns i, v;\n    loop variant l - i;\n  */\n  while (i<l) {\n      if (l*l<=l+5) {\n          v = v*v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int p,int q){\n  int l, i, v, w, r;\n\n  l=50;\n  i=l;\n  v=i;\n  w=l;\n  r=i;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      i = i/2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (r == 50) && (w == 50) && (v == 50) && (i == 50) && (l == 50) && (q == \\at(q, Pre)) && (p == \\at(p, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      i = i/2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last > 0; 2). Changed: i: i@last -> i@last / 2. Unchanged: l keeps l@last; p keeps p@last; q keeps q@last; r keeps r@last; v keeps v@last; w keeps w@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'p', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int p,int q){\n  int l, i, v, w, r;\n\n  l=50;\n  i=l;\n  v=i;\n  w=l;\n  r=i;\n\n  \n  /*@\n\n    loop invariant l == 50;\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant i <= 50;\n\n    loop invariant v % 50 == 0;\n\n    loop invariant v >= 50;\n\n    loop invariant i * v <= 2500;\n\n    loop invariant i <= l;\n\n    loop invariant v >= i;\n\n    loop invariant v >= l;\n\n    loop invariant v >= 0;\n\n    loop invariant i * v <= l * l;\n\n    loop assigns i, v;\n\n    loop variant i;\n\n  */\n  while (i>0) {\n      v = v*2;\n      i = i/2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int p){\n  int l, i, v, a, o;\n\n  l=8;\n  i=l;\n  v=-4;\n  a=k;\n  o=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      v = v*2;\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      v = v*2;\n      i = i-1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int p){\n  int l, i, v, a, o;\n\n  l=8;\n  i=l;\n  v=-4;\n  a=k;\n  o=p;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v <= -4;\n\n    loop invariant v % 4 == 0;\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant v % 2 == 0;\n\n    loop invariant l == 8;\n\n\n    loop assigns i, v;\n\n  */\n  while (i>0) {\n        v = v*2;\n        i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int n){\n  int l, i, v;\n\n  l=n;\n  i=0;\n  v=m;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v%4;\n      v = v*v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(m, Pre)) && (i == 0) && (l == \\at(n, Pre)) && (n == \\at(n, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v%4;\n      v = v*v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last % 4). Changed: i: i@last -> i@last + 1; v: v@last -> v@last % 4. Unchanged: l keeps l@last; m keeps m@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int n){\n  int l, i, v;\n\n  l=n;\n  i=0;\n  v=m;\n\n  \n  /*@\n\n    loop invariant l == \\at(n, Pre);\n\n\n    loop invariant (i == 0) ==> (v == \\at(m, Pre));\n\n    loop invariant (i >= 2) ==> (v == 0 || v == 1);\n\n    loop invariant (i == 0) ==> (v == m);\n\n\n    loop invariant i >= 0;\n\n    loop invariant l == n;\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant (i > 0) ==> (v == 0 || v == 1 || v == 4 || v == 9);\n\n    loop invariant (l < 0) || (i <= l);\n\n    loop invariant (i >= 1) ==> (v >= 0);\n\n    loop invariant (i >= 1) ==> (v == 0 || v == 1 || v == 4 || v == 9);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      v = v%4;\n      v = v*v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int q){\n  int l, i, v, w;\n\n  l=35;\n  i=0;\n  v=5;\n  w=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      w = w*w;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (w == 1) && (v == 5) && (i == 0) && (l == 35) && (q == \\at(q, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      w = w*w;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; w@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + i@last. Unchanged: l keeps l@last; m keeps m@last; q keeps q@last; w keeps w@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'q', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int q){\n  int l, i, v, w;\n\n  l=35;\n  i=0;\n  v=5;\n  w=1;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == 35;\n    loop invariant w == 1;\n    loop invariant v == 5 + i*(i-1)/2;\n    loop invariant i <= l;\n    loop invariant 0 <= i;\n    loop invariant m == \\at(m, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant i >= 0;\n    loop invariant m == \\at(m,Pre);\n    loop invariant q == \\at(q,Pre);\n    loop invariant v == 5 + i*(i - 1) / 2;\n    loop invariant v == 5 + i*(i - 1)/2;\n    loop assigns v, w, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+i;\n      w = w*w;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int l, i, v;\n\n  l=k-5;\n  i=0;\n  v=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v;\n      v = v*2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -8) && (i == 0) && (l == \\at(k, Pre) - 5) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v;\n      v = v*2;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last; 2). Changed: i: i@last -> i@last + 1. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int l, i, v;\n\n  l=k-5;\n  i=0;\n  v=-8;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == k - 5;\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant i >= 0;\n    loop invariant v >= -8;\n\n    loop invariant (i == 0) ==> (v == -8);\n\n    loop invariant (i > 0) ==> (v >= 0);\n    loop invariant (i <= l) || (l < 0);\n    loop assigns i, v;\n  */\nwhile (i<l) {\n      v = v*v;\n      v = v*2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int p){\n  int l, i, v, a, f;\n\n  l=8;\n  i=0;\n  v=6;\n  a=6;\n  f=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*2+2;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   No state-before-entry available\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*2+2;\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int p){\n  int l, i, v, a, f;\n\n  l=8;\n  i=0;\n  v=6;\n  a=6;\n  f=0;\n\n  \n  /*@\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant p == \\at(p, Pre);\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant v >= 2*i + 4;\n\n    loop invariant l == 8;\n\n    loop invariant v >= 6;\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant v % 2 == 0;\n\n    loop invariant (v - 2) % 4 == 0;\n\n    loop assigns v, i;\n\n  */\n  while (i<l) {\n      v = v*2+2;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n){\n  int l, i, v, w, m;\n\n  l=21;\n  i=1;\n  v=n;\n  w=l;\n  m=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+w;\n      i = i*2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (m == 6) && (w == 21) && (v == \\at(n, Pre)) && (i == 1) && (l == 21) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+w;\n      i = i*2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2). Changed: v: v@last -> v@last + w@last. Unchanged: a keeps a@last; i keeps i@last; l keeps l@last; m keeps m@last; n keeps n@last; w keeps w@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'v', 'w']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n){\n  int l, i, v, w, m;\n\n  l=21;\n  i=1;\n  v=n;\n  w=l;\n  m=6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant (v - \\at(n, Pre)) % w == 0;\n    loop invariant i > 0;\n\n    loop invariant v >= \\at(n, Pre);\n    loop invariant w == l;\n    loop invariant l == 21;\n    loop invariant v >= n;\n    loop invariant ((v - n) % w) == 0;\n    loop invariant (v - n) % w == 0;\n    loop invariant i >= 1;\n    loop invariant i <= 2*l;\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+w;\n      i = i*2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int m,int p){\n  int l, i, v;\n\n  l=m+16;\n  i=0;\n  v=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v*v<=l+4) {\n          v = v*v+v;\n      }\n      if (v+6<l) {\n          v = v*v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(p, Pre)) && (i == 0) && (l == \\at(m, Pre) + 16) && (p == \\at(p, Pre)) && (m == \\at(m, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v*v<=l+4) {\n          v = v*v+v;\n      }\n      if (v+6<l) {\n          v = v*v;\n      }\n      i = i+1;\n  }\n```\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n  - \\at(p, Pre) (or \\at(\\at(p, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int m,int p){\n  int l, i, v;\n\n  l=m+16;\n  i=0;\n  v=p;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == m + 16;\n    loop invariant i >= 0;\n    loop invariant p == \\at(p, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant i <= l || l < 0;\n    loop invariant v >= p;\n    loop invariant (i <= l) || (l < 0);\n    loop invariant (i == 0) ==> (v == p);\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      if (v*v<=l+4) {\n          v = v*v+v;\n      }\n      if (v+6<l) {\n          v = v*v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int k){\n  int l, i, v, x, q;\n\n  l=48;\n  i=0;\n  v=0;\n  x=b;\n  q=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (q == 0) && (x == \\at(b, Pre)) && (v == 0) && (i == 0) && (l == 48) && (k == \\at(k, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last + v@last). Changed: i: i@last -> i@last + 1. Unchanged: b keeps b@last; k keeps k@last; l keeps l@last; q keeps q@last; v keeps v@last; x keeps x@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'k', 'l', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int k){\n  int l, i, v, x, q;\n\n  l=48;\n  i=0;\n  v=0;\n  x=b;\n  q=0;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant b == \\at(b, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant l == 48;\n    loop invariant 0 <= i;\n    loop invariant i <= l;\n    loop invariant v == 0;\n    loop invariant i >= 0;\n    loop assigns v, i;\n  */\n  while (i<l) {\n      v = v*v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int n){\n  int l, i, v;\n\n  l=n-2;\n  i=0;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v*v+v;\n      v = v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(a, Pre)) && (i == 0) && (l == \\at(n, Pre) - 2) && (n == \\at(n, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v*v+v;\n      v = v+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; v@last + v@last + (v@last; v@last + v@last). Changed: i: i@last -> i@last + 1. Unchanged: a keeps a@last; l keeps l@last; n keeps n@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int n){\n  int l, i, v;\n\n  l=n-2;\n  i=0;\n  v=a;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant a == \\at(a, Pre);\n    loop invariant l == n - 2;\n    loop invariant i >= 0;\n    loop invariant v >= a;\n    loop invariant n == \\at(n, Pre);\n    loop invariant (l >= 0) ==> (0 <= i && i <= l);\n    loop invariant (i == 0) ==> (v == a);\n    loop invariant (i > 0) ==> (v >= 0);\n    loop invariant 0 <= i;\n\n    loop invariant l == \\at(n, Pre) - 2;\n    loop invariant l == \\at(n,Pre) - 2;\n    loop invariant (v >= 0) || (i == 0);\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v*v+v;\n      v = v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int l, i, v;\n\n  l=28;\n  i=1;\n  v=-6;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+v;\n      v = v*v+v;\n      i = i*2;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == -6) && (i == 1) && (l == 28) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+v;\n      v = v*v+v;\n      i = i*2;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; 2; v@last + v@last) + (v@last + v@last). Changed: v: v@last -> (v@last + v@last. Unchanged: i keeps i@last; l keeps l@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int l, i, v;\n\n  l=28;\n  i=1;\n  v=-6;\n\n  \n  /*@\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant l == 28;\n\n    loop invariant i <= 2*l;\n\n    loop invariant i > 0;\n\n    loop invariant v % 2 == 0;\n\n\n    loop invariant v >= -6;\n\n    loop invariant i >= 1;\n\n    loop assigns i, v;\n\n  */\nwhile (i<l) {\n      v = v+v;\n      v = v*v+v;\n      i = i*2;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int l, i, v;\n\n  l=(k%14)+7;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (i+1<=v+l) {\n          v = v*v+v;\n      }\n      v = v*v+v;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(k, Pre) % 14 + 7) && (i == 0) && (l == \\at(k, Pre) % 14 + 7) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (i+1<=v+l) {\n          v = v*v+v;\n      }\n      v = v*v+v;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 1 <= v@last + l@last; i@last < l@last; v@last + v@last; v@last; v@last + v@last) + (v@last; v@last + v@last)) || i@last + 1 > v@last + l@last; i@last < l@last; v@last + v@last). Changed: i: i@last -> i@last + 1. Unchanged: k keeps k@last; l keeps l@last; m keeps m@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'm', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int l, i, v;\n\n  l=(k%14)+7;\n  i=0;\n  v=l;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == (k % 14) + 7;\n\n    loop invariant i >= 0;\n    loop invariant v >= l;\n    loop invariant k == \\at(k, Pre);\n    loop invariant m == \\at(m, Pre);\n    loop invariant l == (\\at(k, Pre) % 14) + 7;\n    loop invariant 0 <= i;\n    loop invariant i <= l || l <= 0;\n    loop invariant l <= 0 || v >= l;\n    loop invariant l == ((\\at(k,Pre) % 14) + 7);\n    loop invariant k == \\at(k,Pre);\n    loop invariant m == \\at(m,Pre);\n\n    loop invariant (i == 0) ==> v == l;\n    loop assigns v, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      if (i+1<=v+l) {\n          v = v*v+v;\n      }\n      v = v*v+v;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int a,int q){\n  int l, i, v, z;\n\n  l=q+16;\n  i=0;\n  v=i;\n  z=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      v = v+i;\n      z = z*z;\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (z == \\at(q, Pre)) && (v == 0) && (i == 0) && (l == \\at(q, Pre) + 16) && (q == \\at(q, Pre)) && (a == \\at(a, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      v = v+i;\n      z = z*z;\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last < l@last; z@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + i@last. Unchanged: a keeps a@last; l keeps l@last; q keeps q@last; z keeps z@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['a', 'i', 'l', 'q', 'v', 'z']\n\n**Function Parameters:**\n  - \\at(a, Pre) (or \\at(\\at(a, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int a,int q){\n  int l, i, v, z;\n\n  l=q+16;\n  i=0;\n  v=i;\n  z=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant 0 <= i;\n    loop invariant v == i*(i - 1)/2;\n    loop invariant l == q + 16;\n    loop invariant (i == 0) ==> (z == q);\n    loop invariant (i > 0) ==> (z >= 0);\n    loop invariant a == \\at(a, Pre);\n    loop invariant q == \\at(q, Pre);\n    loop invariant (l < 0) || (0 <= i && i <= l);\n    loop invariant v == i*(i-1)/2;\n\n    loop invariant v == i*(i - 1) / 2;\n    loop invariant i >= 0;\n\n    loop assigns v, z, i;\n    loop variant l - i;\n  */\n  while (i<l) {\n      v = v+i;\n      z = z*z;\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int m){\n  int l, i, v, p;\n\n  l=27;\n  i=0;\n  v=l;\n  p=k;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n      v = v+4;\n      p = p+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (p == \\at(k, Pre)) && (v == 27) && (i == 0) && (l == 27) && (m == \\at(m, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n      v = v+4;\n      p = p+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last < l@last; v@last < l@last). Changed: p: p@last -> p@last + 1; v: v@last -> v@last + 1 + 4. Unchanged: i keeps i@last; k keeps k@last; l keeps l@last; m keeps m@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['k', 'l', 'm', 'p', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(m, Pre) (or \\at(\\at(m, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int m){\n  int l, i, v, p;\n\n  l=27;\n  i=0;\n  v=l;\n  p=k;\n\n  \n  /*@\n\n    loop invariant v - 5*p == 27 - 5*k;\n\n    loop invariant v >= 27;\n\n    loop invariant p >= k;\n\n    loop invariant l == 27;\n\n    loop invariant m == \\at(m, Pre);\n\n    loop invariant v == 27 + 5*(p - k);\n\n    loop invariant k == \\at(k, Pre);\n\n    loop invariant v == l + 5*(p - k);\n\n    loop invariant v <= l;\n\n    loop assigns v, p;\n\n  */\n  while (v<l) {\n      if (v<l) {\n          v = v+1;\n      }\n      v = v+4;\n      p = p+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int b,int n){\n  int l, i, v;\n\n  l=46;\n  i=l;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i>0) {\n      if (i+7<=v+l) {\n          v = v%8;\n      }\n      else {\n          v = v*2;\n      }\n      i = i-1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == 2) && (i == 46) && (l == 46) && (n == \\at(n, Pre)) && (b == \\at(b, Pre))\n\n2. Loop Code:\n```c\nwhile (i>0) {\n      if (i+7<=v+l) {\n          v = v%8;\n      }\n      else {\n          v = v*2;\n      }\n      i = i-1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last + 7 > v@last + l@last; i@last > 0; 2) || i@last + 7 <= v@last + l@last; i@last > 0). Changed: i: i@last -> i@last - 1; v: v@last -> v@last % 8. Unchanged: b keeps b@last; l keeps l@last; n keeps n@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['b', 'i', 'l', 'n', 'v']\n\n**Function Parameters:**\n  - \\at(b, Pre) (or \\at(\\at(b, Pre), Pre) for initial value)\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int b,int n){\n  int l, i, v;\n\n  l=46;\n  i=l;\n  v=2;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant i >= 0;\n    loop invariant i <= 46;\n    loop invariant v % 2 == 0;\n    loop invariant l == 46;\n    loop invariant b == \\at(b, Pre);\n    loop invariant n == \\at(n, Pre);\n    loop invariant (0 <= i) && (i <= 46);\n    loop invariant (v == 0) || (v == 2) || (v == 4) || (v == 8);\n    loop invariant 0 <= i <= l;\n    loop invariant v >= 0;\n    loop invariant 0 <= i <= 46;\n    loop assigns i, v;\n  */\n  while (i>0) {\n      if (i+7<=v+l) {\n          v = v%8;\n      }\n      else {\n          v = v*2;\n      }\n      i = i-1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int n,int q){\n  int l, i, v;\n\n  l=21;\n  i=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if ((i%9)==0) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(q, Pre)) && (i == 0) && (l == 21) && (q == \\at(q, Pre)) && (n == \\at(n, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if ((i%9)==0) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (i@last % 9 != 0; i@last < l@last; i@last < l@last). Changed: i: i@last -> i@last + 1; v: v@last -> v@last + v@last. Unchanged: l keeps l@last; n keeps n@last; q keeps q@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'l', 'n', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(n, Pre) (or \\at(\\at(n, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int n,int q){\n  int l, i, v;\n\n  l=21;\n  i=0;\n  v=q;\n\n  \n  /*@\n\n    loop invariant i >= 0;\n\n    loop invariant i <= l;\n\n    loop invariant l == 21;\n\n    loop invariant q == \\at(q, Pre);\n\n    loop invariant n == \\at(n, Pre);\n\n    loop invariant 0 <= i && i <= l;\n\n    loop invariant 0 <= i;\n\n    loop invariant (i == 0) ==> (v == q);\n\n    loop invariant (i > 0) ==> ((i >= 1 && i <= 9) ==> v == q * 2);\n\n    loop assigns i, v;\n\n    loop variant l - i;\n\n  */\n  while (i<l) {\n      if ((i%9)==0) {\n          v = v+v;\n      }\n      i = i+1;\n  }\n\n}"}
{"instruction": "You are a formal verification expert specializing in loop invariant synthesis for Frama-C with the WP plugin.\n\n## TASK\n\nGiven a C function with a loop and a postcondition (`/*@ assert ... */`), generate ACSL loop annotations (invariants, assigns) that enable Frama-C/WP to verify the assertion.\n\n## CORE STRATEGY: Assertion-Driven Invariant Synthesis\n\nThe postcondition assertion is your primary guide. Follow this approach:\n\n1. **Decompose the assertion**: Split conjunctive assertions (connected by `&&`) into individual conjuncts. Each conjunct is a strong candidate for a loop invariant.\n   - If the assert is `(A) && (B) && (C)`, try `A`, `B`, and `C` each as a loop invariant.\n\n2. **Add boundary invariants**: For each loop variable, include bounds that connect the loop counter to its terminal value.\n   - Loop `while(i < n)` needs `i <= n` (not `i < n`, which is false at exit).\n   - Loop `while(n <= a)` needs `n <= a + 1`.\n\n3. **Preserve parameter values**: If a function parameter is not modified in the loop, assert it equals its initial value.\n   - `loop invariant x == \\at(x, Pre);` (only for unmodified parameters)\n\n4. **Verify sufficiency**: Check that `(invariants AND NOT(loop_condition))` logically implies the postcondition.\n\n## FORBIDDEN CONSTRUCTS\n\n| Forbidden | Reason |\n|-----------|--------|\n| `\\forall`, `\\exists` | Quantifiers not allowed in loop invariants |\n| `predicate`, `logic`, `axiomatic`, `lemma` | Custom definitions not supported |\n| Ternary `? :` | Not valid in ACSL annotations |\n| `\\at(local_var, Pre)` | `\\at(v, Pre)` works ONLY on function parameters |\n| `^` for exponentiation | `^` is bitwise XOR in C/ACSL; write `x*x*x` for x cubed |\n| Boolean in arithmetic | `x + (a > b)` is invalid; use `==>` to split cases |\n| Undefined variables | Only use variables declared in the given function |\n\n## ALLOWED OPERATORS\n\n- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical: `&&`, `||`, `!`, `==>`, `<==>`\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n\n## CRITICAL RULES\n\n1. **\\at(v, Pre) restriction**: Can ONLY be used with function PARAMETERS, never with local variables initialized inside the function.\n\n2. **Loop guard is NOT an invariant**: The loop condition (e.g., `x > y*q+r`) is FALSE at loop exit, so it cannot be a loop invariant. Weaken it:\n   - Guard `A > B` -> Invariant `A >= B`\n   - Guard `A < B` -> Invariant `A <= B`\n\n3. **Operator precedence**: In ACSL, `==` binds tighter than `<`/`>`. Use parentheses:\n   - WRONG: `z == x - 1 < y` (parsed as `(z == x - 1) < y`)\n   - RIGHT: `z == x - 1 && x - 1 < y`\n\n## ANNOTATION FORMAT\n\n```\n/*@\n  loop invariant <property>;\n  loop assigns <modified_vars>;\n  loop variant <decreasing_expr>;   // optional\n*/\nwhile (...) { ... }\n```\n\n- `loop invariant`: Properties preserved by each iteration (multiple allowed)\n- `loop assigns`: ALL variables modified inside the loop body\n- `loop variant`: Non-negative expression that strictly decreases (for termination)\n\n## OUTPUT\n\nReturn ONLY the annotated C function with ACSL loop annotations inserted before the while loop. Do not include explanations.\n", "input": "\n\nFollow the system prompt rules. This prompt adds only proof-oriented strategy.\n\nGoal: produce a small, strong, inductive invariant set for the current loop.\n\nGoal-specific guidance:\nNo explicit verification target is present.\n- Focus on inductive, non-empty invariants derived from loop semantics.\n- Prioritize transition/conservation relations and necessary bounds.\n- Do not mention or optimize for post-loop assert.\n\nRequired construction order:\n1. If a verification target is provided, map target terms to loop-preserved forms.\n2. Add one core conservation/relational equality that explains loop updates (state transition law).\n3. Add minimal progress bounds for loop counters and key arithmetic variables.\n4. If a verification target is provided, ensure `invariants && !guard` can imply it.\n5. Add complete and exact `loop assigns`.\n\nQuality requirements:\n- Prefer 3-6 strong invariants; avoid weak/tautological ones.\n- Do not add unrelated invariants just to increase count.\n- Reuse assert vocabulary/symbols directly whenever possible.\n- Keep original code unchanged except loop annotations.\n\nCode:\n```c\nint main1(int k,int q){\n  int l, i, v;\n\n  l=(q%12)+5;\n  i=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n/*@\n  loop invariant PLACE_HOLDER_VERIFICATION_GOAL;\n  loop assigns PLACE_HOLDER_ASSIGNMENTS;\n*/\nwhile (i<l) {\n      if (v+4<l) {\n          v = v*v+v;\n      }\n      else {\n          v = v*v;\n      }\n      i = i+1;\n  }\n\n}\n\n```\n\nLoop context:\n\n1. State Before Loop Entry:\n   (v == \\at(q, Pre)) && (i == 0) && (l == \\at(q, Pre) % 12 + 5) && (q == \\at(q, Pre)) && (k == \\at(k, Pre))\n\n2. Loop Code:\n```c\nwhile (i<l) {\n      if (v+4<l) {\n          v = v*v+v;\n      }\n      else {\n          v = v*v;\n      }\n      i = i+1;\n  }\n```\n\n3. Transition Relation:\n   One-step transition under loop guard (v@last + 4 >= l@last; i@last < l@last; v@last) || v@last + 4 < l@last; i@last < l@last; v@last + v@last). Changed: i: i@last -> i@last + 1. Unchanged: k keeps k@last; l keeps l@last; q keeps q@last; v keeps v@last.\n\n### AVAILABLE VARIABLES AND PARAMETERS ###\n\n**Available Variables:** ['i', 'k', 'l', 'q', 'v']\n\n**Function Parameters:**\n  - \\at(k, Pre) (or \\at(\\at(k, Pre), Pre) for initial value)\n  - \\at(q, Pre) (or \\at(\\at(q, Pre), Pre) for initial value)\n\nIMPORTANT:\n- You can ONLY use variables from the 'Available Variables' list\n- For function parameters, you can use:\n  * 'param' to refer to the current value\n  * '\\at(param, Pre)' to refer to the initial value at function entry\n- Using undefined variables or \\at() on non-parameters will cause validation errors\n\nReturn only complete C code with ACSL loop annotations.\n", "output": "int main1(int k,int q){\n  int l, i, v;\n\n  l=(q%12)+5;\n  i=0;\n  v=q;\n\n  /* >>> LOOP INVARIANT TO FILL <<< */\n    /*@\n    loop invariant l == (\\at(q, Pre) % 12) + 5;\n    loop invariant q == \\at(q, Pre);\n    loop invariant k == \\at(k, Pre);\n    loop invariant 0 <= i;\n    loop invariant (i <= l) || (l < 0);\n    loop invariant l == (q % 12) + 5;\n    loop invariant (l < 0) || (i <= l);\n    loop invariant i >= 0;\n    loop invariant (i > 0) ==> v >= 0;\n    loop invariant (i == 0) ==> v == q;\n\n    loop invariant (i == 0) ==> (v == \\at(q, Pre));\n    loop invariant l == (\\at(q,Pre) % 12) + 5;\n    loop invariant v >= (\\at(q,Pre));\n    loop assigns i, v;\n  */\n  while (i<l) {\n      if (v+4<l) {\n          v = v*v+v;\n      }\n      else {\n          v = v*v;\n      }\n      i = i+1;\n  }\n\n}"}
